{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$(),\n    _s11 = $RefreshSig$(),\n    _s12 = $RefreshSig$(),\n    _s13 = $RefreshSig$(),\n    _s14 = $RefreshSig$(),\n    _s15 = $RefreshSig$(),\n    _s16 = $RefreshSig$();\n\nimport { JSBI, Token, TokenAmount, Pair } from '@uniswap/sdk';\nimport dayjs from 'dayjs';\nimport { useMemo, useEffect } from 'react';\nimport { usePairs } from 'data/Reserves';\nimport { client } from 'apollo/client';\nimport { GLOBAL_DATA, PAIRS_BULK, PAIRS_HISTORICAL_BULK } from 'apollo/queries';\nimport { GlobalConst, GlobalValue } from 'constants/index';\nimport { STAKING_REWARDS_INTERFACE, STAKING_DUAL_REWARDS_INTERFACE } from 'constants/abis/staking-rewards';\nimport { useActiveWeb3React } from 'hooks';\nimport { NEVER_RELOAD, useMultipleContractSingleData, useSingleCallResult } from 'state/multicall/hooks';\nimport { tryParseAmount } from 'state/swap/hooks';\nimport Web3 from 'web3';\nimport { useLairContract, useNewLairContract, useNewQUICKContract, useQUICKContract } from 'hooks/useContract';\nimport { useUSDCPrices, useUSDCPricesToken } from 'utils/useUSDCPrice';\nimport { unwrappedToken } from 'utils/wrappedCurrency';\nimport { useTotalSupplys } from 'data/TotalSupply';\nimport { getBlockFromTimestamp, getDaysCurrentYear, getFarmLPToken, getOneYearFee, getSyrupLPToken, initTokenAmountFromCallResult, getCallStateResult } from 'utils';\nimport { useDefaultFarmList } from 'state/farms/hooks';\nimport { useDefaultDualFarmList } from 'state/dualfarms/hooks';\nimport { useDefaultSyrupList } from 'state/syrups/hooks';\nconst web3 = new Web3('https://rpc-sg.dogechain.dog/');\nexport const STAKING_GENESIS = 1620842940;\nexport const REWARDS_DURATION_DAYS = 7;\nlet pairs = undefined;\nlet oneDayVol = undefined;\nexport function useTotalRewardsDistributed(chainId) {\n  _s();\n\n  const syrupRewardsInfo = Object.values(useDefaultSyrupList()[chainId]);\n  const dualStakingRewardsInfo = Object.values(useDefaultDualFarmList()[chainId]).filter(x => !x.ended);\n  const stakingRewardsInfo = Object.values(useDefaultFarmList()[chainId]).filter(x => !x.ended);\n  const syrupTokenPairs = usePairs(syrupRewardsInfo.map(item => [unwrappedToken(item.token), unwrappedToken(item.baseToken)]));\n  const syrupUSDBaseTokenPrices = useUSDCPrices(syrupRewardsInfo.map(item => unwrappedToken(item.baseToken)));\n  const syrupRewardsUSD = syrupRewardsInfo.reduce((total, item, index) => {\n    const [, syrupTokenPair] = syrupTokenPairs[index];\n    const tokenPairPrice = syrupTokenPair === null || syrupTokenPair === void 0 ? void 0 : syrupTokenPair.priceOf(item.token);\n    const usdPriceBaseToken = syrupUSDBaseTokenPrices[index];\n    const priceOfRewardTokenInUSD = Number(tokenPairPrice === null || tokenPairPrice === void 0 ? void 0 : tokenPairPrice.toSignificant()) * Number(usdPriceBaseToken === null || usdPriceBaseToken === void 0 ? void 0 : usdPriceBaseToken.toSignificant());\n    return total + priceOfRewardTokenInUSD * item.rate;\n  }, 0);\n  const rewardTokenAPrices = useUSDCPricesToken(dualStakingRewardsInfo.map(item => item.rewardTokenA));\n  const rewardTokenBPrices = useUSDCPricesToken(dualStakingRewardsInfo.map(item => item.rewardTokenB));\n  const dualStakingRewardsUSD = dualStakingRewardsInfo.reduce((total, item, index) => total + item.rateA * rewardTokenAPrices[index] + item.rateB * rewardTokenBPrices[index], 0);\n  const rewardTokenPrices = useUSDCPricesToken(stakingRewardsInfo.map(item => item.rewardToken));\n  const stakingRewardsUSD = stakingRewardsInfo.reduce((total, item, index) => total + item.rate * rewardTokenPrices[index], 0);\n  return syrupRewardsUSD + dualStakingRewardsUSD + stakingRewardsUSD;\n}\n\n_s(useTotalRewardsDistributed, \"vefK9anoJdGPC8qlF/1fOf3tBwg=\", false, function () {\n  return [useDefaultSyrupList, useDefaultDualFarmList, useDefaultFarmList, usePairs, useUSDCPrices, useUSDCPricesToken, useUSDCPricesToken, useUSDCPricesToken];\n});\n\nexport function useUSDRewardsandFees(isLPFarm, bulkPairData, chainId) {\n  _s2();\n\n  const activeFarms = Object.values(useDefaultFarmList()[chainId]).filter(x => !x.ended);\n  const activeDualFarms = Object.values(useDefaultDualFarmList()[chainId]).filter(x => !x.ended);\n  const stakingRewardsInfo = isLPFarm ? activeFarms : [];\n  const dualStakingRewardsInfo = !isLPFarm ? activeDualFarms : [];\n  const rewardsInfos = isLPFarm ? stakingRewardsInfo : dualStakingRewardsInfo;\n  const rewardsAddresses = useMemo(() => rewardsInfos.map(_ref => {\n    let {\n      stakingRewardAddress\n    } = _ref;\n    return stakingRewardAddress;\n  }), [rewardsInfos]);\n  const stakingRewardTokens = stakingRewardsInfo.map(item => item.rewardToken);\n  const stakingRewardTokenPrices = useUSDCPricesToken(stakingRewardTokens);\n  const dualStakingRewardTokenAPrices = useUSDCPricesToken(dualStakingRewardsInfo.map(item => item.rewardTokenA));\n  const dualStakingRewardTokenBPrices = useUSDCPricesToken(dualStakingRewardsInfo.map(item => item.rewardTokenB));\n  const rewardPairs = useMemo(() => rewardsInfos.map(_ref2 => {\n    let {\n      pair\n    } = _ref2;\n    return pair;\n  }), [rewardsInfos]);\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, isLPFarm ? STAKING_REWARDS_INTERFACE : STAKING_DUAL_REWARDS_INTERFACE, 'totalSupply');\n  let rewardsUSD = null;\n\n  if (isLPFarm) {\n    rewardsUSD = stakingRewardsInfo.reduce((total, item, index) => total + item.rate * stakingRewardTokenPrices[index], 0);\n  } else {\n    rewardsUSD = dualStakingRewardsInfo.reduce((total, item, index) => total + item.rateA * dualStakingRewardTokenAPrices[index] + item.rateB * dualStakingRewardTokenBPrices[index], 0);\n  }\n\n  const stakingFees = bulkPairData ? rewardPairs.reduce((total, pair, index) => {\n    var _bulkPairData$pair$on, _bulkPairData$pair;\n\n    const oneYearFeeAPY = Number((_bulkPairData$pair$on = (_bulkPairData$pair = bulkPairData[pair]) === null || _bulkPairData$pair === void 0 ? void 0 : _bulkPairData$pair.oneDayVolumeUSD) !== null && _bulkPairData$pair$on !== void 0 ? _bulkPairData$pair$on : 0);\n    const totalSupplyState = totalSupplies[index];\n\n    if (oneYearFeeAPY) {\n      var _pairs$pair, _totalSupplyState$res;\n\n      const totalSupply = web3.utils.toWei((_pairs$pair = pairs[pair]) === null || _pairs$pair === void 0 ? void 0 : _pairs$pair.totalSupply, 'ether');\n      const ratio = Number((_totalSupplyState$res = totalSupplyState.result) === null || _totalSupplyState$res === void 0 ? void 0 : _totalSupplyState$res[0].toString()) / Number(totalSupply);\n      const oneDayFee = oneYearFeeAPY * GlobalConst.utils.FEEPERCENT * ratio;\n      return total + oneDayFee;\n    } else {\n      return total;\n    }\n  }, 0) : null;\n  return {\n    rewardsUSD,\n    stakingFees\n  };\n}\n\n_s2(useUSDRewardsandFees, \"mjrVypIKfG5Ap0RP1jalO860cx4=\", false, function () {\n  return [useDefaultFarmList, useDefaultDualFarmList, useUSDCPricesToken, useUSDCPricesToken, useUSDCPricesToken, useMultipleContractSingleData];\n});\n\nexport function useFilteredSyrupInfo(chainId, tokenToFilterBy, startIndex, endIndex, filter) {\n  _s3();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const currentTimestamp = dayjs().unix();\n  const allSyrups = useDefaultSyrupList()[chainId];\n  const info = useMemo(() => Object.values(allSyrups).slice(startIndex, endIndex).filter(syrupInfo => syrupInfo.ending > currentTimestamp && (tokenToFilterBy === undefined || tokenToFilterBy === null ? getSearchFiltered(syrupInfo, filter ? filter.search : '') : tokenToFilterBy.equals(syrupInfo.token))), [tokenToFilterBy, startIndex, endIndex, filter, currentTimestamp, allSyrups]);\n  const rewardsAddresses = useMemo(() => info.map(_ref3 => {\n    let {\n      stakingRewardAddress\n    } = _ref3;\n    return stakingRewardAddress;\n  }), [info]);\n  const accountArg = useMemo(() => [account !== null && account !== void 0 ? account : undefined], [account]); // get all the info from the staking rewards contracts\n\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg);\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg);\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply');\n  const rewardRates = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'rewardRate', undefined, NEVER_RELOAD);\n  const stakingTokenPairs = usePairs(info.map(item => [unwrappedToken(item.token), unwrappedToken(item.baseToken)]));\n  const usdBaseTokenPrices = useUSDCPrices(info.map(item => unwrappedToken(item.baseToken)));\n  const stakingTokenPrices = useUSDCPricesToken(info.map(item => item.stakingToken));\n  return useMemo(() => {\n    if (!chainId) return [];\n    return rewardsAddresses.reduce((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index];\n      const earnedAmountState = earnedAmounts[index];\n      const stakingTokenPrice = stakingTokenPrices[index]; // these get fetched regardless of account\n\n      const totalSupplyState = totalSupplies[index];\n      const rewardRateState = rewardRates[index];\n      const syrupInfo = info[index];\n\n      if ( // these may be undefined if not logged in\n      !(balanceState !== null && balanceState !== void 0 && balanceState.loading) && !(earnedAmountState !== null && earnedAmountState !== void 0 && earnedAmountState.loading) && // always need these\n      totalSupplyState && !totalSupplyState.loading && rewardRateState && !rewardRateState.loading) {\n        // get the LP token\n        const token = syrupInfo.token;\n        const [, stakingTokenPair] = stakingTokenPairs[index];\n        const tokenPairPrice = stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.priceOf(token);\n        const usdPriceBaseToken = usdBaseTokenPrices[index];\n        const priceOfRewardTokenInUSD = tokenPairPrice && usdPriceBaseToken ? Number(tokenPairPrice.toSignificant()) * Number(usdPriceBaseToken.toSignificant()) : undefined;\n        const rewards = syrupInfo.rate * (priceOfRewardTokenInUSD !== null && priceOfRewardTokenInUSD !== void 0 ? priceOfRewardTokenInUSD : 0); // check for account, if no account set to 0\n\n        const rate = web3.utils.toWei(syrupInfo.rate.toString());\n        const syrupToken = getSyrupLPToken(syrupInfo);\n        const stakedAmount = initTokenAmountFromCallResult(syrupToken, balanceState);\n        const totalStakedAmount = initTokenAmountFromCallResult(syrupToken, totalSupplyState);\n        const totalRewardRate = new TokenAmount(token, JSBI.BigInt(rate)); //const pair = info[index].pair.toLowerCase();\n        //const fees = (pairData && pairData[pair] ? pairData[pair].oneDayVolumeUSD * 0.0025: 0);\n\n        const rewardRate = initTokenAmountFromCallResult(token, rewardRateState);\n\n        const getHypotheticalRewardRate = (stakedAmount, totalStakedAmount) => {\n          if (!stakedAmount || !totalStakedAmount || !rewardRate) return;\n          return new TokenAmount(token, JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0)) ? JSBI.divide(JSBI.multiply(rewardRate.raw, stakedAmount.raw), totalStakedAmount.raw) : JSBI.BigInt(0));\n        };\n\n        const individualRewardRate = getHypotheticalRewardRate(stakedAmount, totalStakedAmount);\n        const periodFinishMs = syrupInfo.ending;\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          token: syrupInfo.token,\n          ended: syrupInfo.ended,\n          name: syrupInfo.name,\n          lp: syrupInfo.lp,\n          periodFinish: periodFinishMs,\n          earnedAmount: initTokenAmountFromCallResult(token, earnedAmountState),\n          rewardRate: individualRewardRate,\n          totalRewardRate: totalRewardRate,\n          stakedAmount: stakedAmount,\n          totalStakedAmount: totalStakedAmount,\n          getHypotheticalRewardRate,\n          baseToken: syrupInfo.baseToken,\n          rate: syrupInfo.rate,\n          rewardTokenPriceinUSD: priceOfRewardTokenInUSD,\n          rewards,\n          stakingToken: syrupInfo.stakingToken,\n          valueOfTotalStakedAmountInUSDC: totalStakedAmount ? Number(totalStakedAmount.toExact()) * stakingTokenPrice : undefined\n        });\n      }\n\n      return memo;\n    }, []);\n  }, [balances, chainId, earnedAmounts, info, rewardsAddresses, totalSupplies, rewardRates, stakingTokenPairs, usdBaseTokenPrices, stakingTokenPrices]).filter(syrupInfo => filter && filter.isStaked ? syrupInfo.stakedAmount && syrupInfo.stakedAmount.greaterThan('0') : true);\n}\n\n_s3(useFilteredSyrupInfo, \"JlJQk/AgoZqa+DZ61OW7gZ2PXD8=\", false, function () {\n  return [useActiveWeb3React, useDefaultSyrupList, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, usePairs, useUSDCPrices, useUSDCPricesToken];\n});\n\nexport function useOldSyrupInfo(chainId, tokenToFilterBy, startIndex, endIndex, filter) {\n  _s4();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const currentTimestamp = dayjs().unix();\n  const allOldSyrupInfos = useDefaultSyrupList()[chainId];\n  const info = useMemo(() => {\n    return Object.values(allOldSyrupInfos).filter(x => x.ending <= currentTimestamp).slice(startIndex, endIndex).filter(syrupInfo => tokenToFilterBy === undefined || tokenToFilterBy === null ? getSearchFiltered(syrupInfo, filter ? filter.search : '') : tokenToFilterBy.equals(syrupInfo.token));\n  }, [tokenToFilterBy, startIndex, endIndex, filter, currentTimestamp, allOldSyrupInfos]);\n  const rewardsAddresses = useMemo(() => info.map(_ref4 => {\n    let {\n      stakingRewardAddress\n    } = _ref4;\n    return stakingRewardAddress;\n  }), [info]);\n  const accountArg = useMemo(() => [account !== null && account !== void 0 ? account : undefined], [account]); // get all the info from the staking rewards contracts\n\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg);\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg);\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply');\n  const rewardRates = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'rewardRate', undefined, NEVER_RELOAD);\n  const stakingTokenPairs = usePairs(info.map(item => [unwrappedToken(item.token), unwrappedToken(item.baseToken)]));\n  const usdBaseTokenPrices = useUSDCPrices(info.map(item => unwrappedToken(item.baseToken)));\n  const stakingTokenPrices = useUSDCPricesToken(info.map(item => item.stakingToken));\n  return useMemo(() => {\n    if (!chainId) return [];\n    return rewardsAddresses.reduce((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index];\n      const earnedAmountState = earnedAmounts[index]; // these get fetched regardless of account\n\n      const totalSupplyState = totalSupplies[index];\n      const rewardRateState = rewardRates[index];\n      const syrupInfo = info[index];\n      const stakingTokenPrice = stakingTokenPrices[index];\n\n      if ( // these may be undefined if not logged in\n      !(balanceState !== null && balanceState !== void 0 && balanceState.loading) && !(earnedAmountState !== null && earnedAmountState !== void 0 && earnedAmountState.loading) && // always need these\n      totalSupplyState && !totalSupplyState.loading && rewardRateState && !rewardRateState.loading) {\n        // get the LP token\n        const token = syrupInfo.token; // check for account, if no account set to 0\n\n        const rate = web3.utils.toWei(syrupInfo.rate.toString());\n        const stakedAmount = initTokenAmountFromCallResult(getSyrupLPToken(syrupInfo), balanceState);\n        const totalStakedAmount = initTokenAmountFromCallResult(getSyrupLPToken(syrupInfo), totalSupplyState);\n        const totalRewardRate = new TokenAmount(token, JSBI.BigInt(rate)); //const pair = info[index].pair.toLowerCase();\n        //const fees = (pairData && pairData[pair] ? pairData[pair].oneDayVolumeUSD * 0.0025: 0);\n\n        const rewardRate = initTokenAmountFromCallResult(token, rewardRateState);\n\n        const getHypotheticalRewardRate = (stakedAmount, totalStakedAmount) => {\n          if (!stakedAmount || !totalStakedAmount || !rewardRate) return;\n          return new TokenAmount(token, JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0)) ? JSBI.divide(JSBI.multiply(rewardRate.raw, stakedAmount.raw), totalStakedAmount.raw) : JSBI.BigInt(0));\n        };\n\n        const individualRewardRate = getHypotheticalRewardRate(stakedAmount, totalStakedAmount);\n        const periodFinishMs = syrupInfo.ending;\n        const [, stakingTokenPair] = stakingTokenPairs[index];\n        const tokenPairPrice = stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.priceOf(token);\n        const usdPriceBaseToken = usdBaseTokenPrices[index];\n        const priceOfRewardTokenInUSD = Number(tokenPairPrice === null || tokenPairPrice === void 0 ? void 0 : tokenPairPrice.toSignificant()) * Number(usdPriceBaseToken === null || usdPriceBaseToken === void 0 ? void 0 : usdPriceBaseToken.toSignificant());\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          token: syrupInfo.token,\n          ended: true,\n          name: syrupInfo.name,\n          lp: syrupInfo.lp,\n          periodFinish: periodFinishMs,\n          earnedAmount: initTokenAmountFromCallResult(token, earnedAmountState),\n          rewardRate: individualRewardRate,\n          totalRewardRate: totalRewardRate,\n          stakedAmount: stakedAmount,\n          totalStakedAmount: totalStakedAmount,\n          getHypotheticalRewardRate,\n          baseToken: syrupInfo.baseToken,\n          rate: 0,\n          rewardTokenPriceinUSD: priceOfRewardTokenInUSD,\n          stakingToken: syrupInfo.stakingToken,\n          valueOfTotalStakedAmountInUSDC: totalStakedAmount ? Number(totalStakedAmount.toExact()) * stakingTokenPrice : undefined\n        });\n      }\n\n      return memo;\n    }, []);\n  }, [balances, chainId, earnedAmounts, info, rewardsAddresses, totalSupplies, rewardRates, stakingTokenPairs, usdBaseTokenPrices, stakingTokenPrices]).filter(syrupInfo => filter && filter.isStaked ? syrupInfo.stakedAmount && syrupInfo.stakedAmount.greaterThan('0') : true);\n}\n\n_s4(useOldSyrupInfo, \"JlJQk/AgoZqa+DZ61OW7gZ2PXD8=\", false, function () {\n  return [useActiveWeb3React, useDefaultSyrupList, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, usePairs, useUSDCPrices, useUSDCPricesToken];\n});\n\nexport const getBulkPairData = async pairList => {\n  // if (pairs !== undefined) {\n  //   return;\n  // }\n  const utcCurrentTime = dayjs();\n  const utcOneDayBack = utcCurrentTime.subtract(1, 'day').unix();\n  const oneDayOldBlock = await getBlockFromTimestamp(utcOneDayBack);\n\n  try {\n    var _oneDayResult$data;\n\n    const current = await client.query({\n      query: PAIRS_BULK(pairList),\n      fetchPolicy: 'network-only'\n    });\n    const [oneDayResult] = await Promise.all([oneDayOldBlock].map(async block => {\n      const cResult = await client.query({\n        query: PAIRS_HISTORICAL_BULK(block, pairList),\n        fetchPolicy: 'network-only'\n      });\n      return cResult;\n    }));\n    const oneDayData = oneDayResult === null || oneDayResult === void 0 ? void 0 : (_oneDayResult$data = oneDayResult.data) === null || _oneDayResult$data === void 0 ? void 0 : _oneDayResult$data.pairs.reduce((obj, cur, i) => {\n      return { ...obj,\n        [cur.id]: cur\n      };\n    }, {});\n    const pairData = current && current.data.pairs.map(pair => {\n      let data = pair;\n      const oneDayHistory = oneDayData === null || oneDayData === void 0 ? void 0 : oneDayData[pair.id];\n      data = parseData(data, oneDayHistory);\n      return data;\n    });\n    const object = convertArrayToObject(pairData, 'id');\n\n    if (Object.keys(object).length > 0) {\n      pairs = object;\n      return object;\n    }\n\n    return object;\n  } catch (e) {\n    console.log(e);\n    return;\n  }\n};\n\nconst getOneDayVolume = async () => {\n  let data = {};\n  let oneDayData = {};\n  const current = await web3.eth.getBlockNumber();\n  const utcCurrentTime = dayjs();\n  const utcOneDayBack = utcCurrentTime.subtract(1, 'day').unix();\n  const oneDayOldBlock = await getBlockFromTimestamp(utcOneDayBack);\n  const result = await client.query({\n    query: GLOBAL_DATA(current),\n    fetchPolicy: 'network-only'\n  });\n  data = result.data.uniswapFactories[0]; // fetch the historical data\n\n  const oneDayResult = await client.query({\n    query: GLOBAL_DATA(oneDayOldBlock),\n    fetchPolicy: 'network-only'\n  });\n  oneDayData = oneDayResult.data.uniswapFactories[0];\n  let oneDayVolumeUSD = 0;\n\n  if (data && oneDayData) {\n    oneDayVolumeUSD = get2DayPercentChange(data.totalVolumeUSD, oneDayData.totalVolumeUSD ? oneDayData.totalVolumeUSD : 0);\n    oneDayVol = oneDayVolumeUSD;\n  }\n\n  return oneDayVolumeUSD;\n};\n\nconst convertArrayToObject = (array, key) => {\n  const initialValue = {};\n  return array.reduce((obj, item) => {\n    return { ...obj,\n      [item[key]]: item\n    };\n  }, initialValue);\n};\n\nexport const get2DayPercentChange = (valueNow, value24HoursAgo) => {\n  // get volume info for both 24 hour periods\n  return Number(valueNow) - Number(value24HoursAgo);\n};\n\nfunction parseData(data, oneDayData) {\n  // get volume changes\n  const oneDayVolumeUSD = get2DayPercentChange(data === null || data === void 0 ? void 0 : data.volumeUSD, oneDayData !== null && oneDayData !== void 0 && oneDayData.volumeUSD ? oneDayData.volumeUSD : 0);\n  return {\n    id: data.id,\n    token0: data.token0,\n    token1: data.token1,\n    oneDayVolumeUSD,\n    reserveUSD: data.reserveUSD,\n    totalSupply: data.totalSupply\n  };\n}\n\nfunction getSearchFiltered(info, search) {\n  const searchLowered = search.toLowerCase();\n\n  if (info.tokens) {\n    var _infoToken0$symbol, _infoToken0$name, _infoToken0$address, _infoToken1$symbol, _infoToken1$name, _infoToken1$address;\n\n    const infoToken0 = info.tokens[0];\n    const infoToken1 = info.tokens[1];\n    return ((_infoToken0$symbol = infoToken0.symbol) !== null && _infoToken0$symbol !== void 0 ? _infoToken0$symbol : '').toLowerCase().indexOf(searchLowered) > -1 || ((_infoToken0$name = infoToken0.name) !== null && _infoToken0$name !== void 0 ? _infoToken0$name : '').toLowerCase().indexOf(searchLowered) > -1 || ((_infoToken0$address = infoToken0.address) !== null && _infoToken0$address !== void 0 ? _infoToken0$address : '').toLowerCase().indexOf(searchLowered) > -1 || ((_infoToken1$symbol = infoToken1.symbol) !== null && _infoToken1$symbol !== void 0 ? _infoToken1$symbol : '').toLowerCase().indexOf(searchLowered) > -1 || ((_infoToken1$name = infoToken1.name) !== null && _infoToken1$name !== void 0 ? _infoToken1$name : '').toLowerCase().indexOf(searchLowered) > -1 || ((_infoToken1$address = infoToken1.address) !== null && _infoToken1$address !== void 0 ? _infoToken1$address : '').toLowerCase().indexOf(searchLowered) > -1;\n  } else if (info.token) {\n    var _info$token$symbol, _info$token$name, _info$token$address;\n\n    return ((_info$token$symbol = info.token.symbol) !== null && _info$token$symbol !== void 0 ? _info$token$symbol : '').toLowerCase().indexOf(searchLowered) > -1 || ((_info$token$name = info.token.name) !== null && _info$token$name !== void 0 ? _info$token$name : '').toLowerCase().indexOf(searchLowered) > -1 || ((_info$token$address = info.token.address) !== null && _info$token$address !== void 0 ? _info$token$address : '').toLowerCase().indexOf(searchLowered) > -1;\n  } else {\n    return false;\n  }\n}\n\nexport function getStakingFees(stakingInfo, balanceState, totalSupplyState) {\n  let oneYearFeeAPY = 0;\n  let oneDayFee = 0;\n  let accountFee = 0;\n\n  if (pairs !== undefined) {\n    var _pairs$stakingInfo$pa;\n\n    oneYearFeeAPY = (_pairs$stakingInfo$pa = pairs[stakingInfo.pair]) === null || _pairs$stakingInfo$pa === void 0 ? void 0 : _pairs$stakingInfo$pa.oneDayVolumeUSD;\n    const balanceResult = getCallStateResult(balanceState);\n    const totalSupplyResult = getCallStateResult(totalSupplyState);\n\n    if (oneYearFeeAPY && balanceResult && totalSupplyResult) {\n      var _pairs$stakingInfo$pa2, _pairs$stakingInfo$pa3;\n\n      const totalSupply = web3.utils.toWei((_pairs$stakingInfo$pa2 = pairs[stakingInfo.pair]) === null || _pairs$stakingInfo$pa2 === void 0 ? void 0 : _pairs$stakingInfo$pa2.totalSupply, 'ether');\n      const ratio = Number(totalSupplyResult) / Number(totalSupply);\n      const myRatio = Number(balanceResult) / Number(totalSupplyResult);\n      oneDayFee = oneYearFeeAPY * GlobalConst.utils.FEEPERCENT * ratio;\n      accountFee = oneDayFee * myRatio;\n      oneYearFeeAPY = getOneYearFee(oneYearFeeAPY, (_pairs$stakingInfo$pa3 = pairs[stakingInfo.pair]) === null || _pairs$stakingInfo$pa3 === void 0 ? void 0 : _pairs$stakingInfo$pa3.reserveUSD);\n    }\n  }\n\n  return {\n    oneYearFeeAPY,\n    oneDayFee,\n    accountFee\n  };\n}\n\nconst getHypotheticalRewardRate = (token, stakedAmount, totalStakedAmount, totalRewardRate) => {\n  if (!stakedAmount || !totalStakedAmount || !totalRewardRate) return;\n  return new TokenAmount(token, JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0)) ? JSBI.divide(JSBI.multiply(totalRewardRate.raw, stakedAmount.raw), totalStakedAmount.raw) : JSBI.BigInt(0));\n}; // gets the dual rewards staking info from the network for the active chain id\n\n\nexport function useDualStakingInfo(chainId, pairToFilterBy, startIndex, endIndex, filter) {\n  _s5();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const dualStakingRewardsInfo = useDefaultDualFarmList();\n  const info = useMemo(() => Object.values(dualStakingRewardsInfo[chainId]).filter(x => filter !== null && filter !== void 0 && filter.isEndedFarm ? x.ended : !x.ended).slice(startIndex, endIndex).filter(stakingRewardInfo => pairToFilterBy === undefined || pairToFilterBy === null ? getSearchFiltered(stakingRewardInfo, filter ? filter.search : '') : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) && pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1])), [chainId, pairToFilterBy, startIndex, endIndex, filter, dualStakingRewardsInfo]);\n  const rewardsAddresses = useMemo(() => info.map(_ref5 => {\n    let {\n      stakingRewardAddress\n    } = _ref5;\n    return stakingRewardAddress;\n  }), [info]);\n  const accountArg = useMemo(() => [account !== null && account !== void 0 ? account : undefined], [account]); // get all the info from the staking rewards contracts\n\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_DUAL_REWARDS_INTERFACE, 'balanceOf', accountArg);\n  const earnedAAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_DUAL_REWARDS_INTERFACE, 'earnedA', accountArg);\n  const earnedBAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_DUAL_REWARDS_INTERFACE, 'earnedB', accountArg);\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_DUAL_REWARDS_INTERFACE, 'totalSupply');\n  const rewardRatesA = useMultipleContractSingleData(rewardsAddresses, STAKING_DUAL_REWARDS_INTERFACE, 'rewardRateA', undefined, NEVER_RELOAD);\n  const rewardRatesB = useMultipleContractSingleData(rewardsAddresses, STAKING_DUAL_REWARDS_INTERFACE, 'rewardRateB', undefined, NEVER_RELOAD);\n  const baseTokens = info.map(item => {\n    const unwrappedCurrency = unwrappedToken(item.baseToken);\n    const empty = unwrappedToken(GlobalValue.tokens.COMMON.EMPTY);\n    return unwrappedCurrency === empty ? item.tokens[0] : item.baseToken;\n  });\n  const usdPrices = useUSDCPrices(baseTokens);\n  const totalSupplys = useTotalSupplys(info.map(item => getFarmLPToken(item)));\n  const stakingPairs = usePairs(info.map(item => item.tokens));\n  const rewardTokenAPrices = useUSDCPricesToken(info.map(item => item.rewardTokenA));\n  const rewardTokenBPrices = useUSDCPricesToken(info.map(item => item.rewardTokenB));\n  return useMemo(() => {\n    if (!chainId) return [];\n    return rewardsAddresses.reduce((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index];\n      const earnedAAmountState = earnedAAmounts[index];\n      const earnedBAmountState = earnedBAmounts[index]; // these get fetched regardless of account\n\n      const totalSupplyState = totalSupplies[index];\n      const rewardRateAState = rewardRatesA[index];\n      const rewardRateBState = rewardRatesB[index];\n      const stakingInfo = info[index];\n      const rewardTokenAPrice = rewardTokenAPrices[index];\n      const rewardTokenBPrice = rewardTokenBPrices[index];\n\n      if ( // these may be undefined if not logged in\n      !(balanceState !== null && balanceState !== void 0 && balanceState.loading) && !(earnedAAmountState !== null && earnedAAmountState !== void 0 && earnedAAmountState.loading) && !(earnedBAmountState !== null && earnedBAmountState !== void 0 && earnedBAmountState.loading) && // always need these\n      totalSupplyState && !totalSupplyState.loading && rewardRateAState && !rewardRateAState.loading && rewardRateBState) {\n        var _valueOfTotalStakedAm;\n\n        const rateA = web3.utils.toWei(stakingInfo.rateA.toString());\n        const rateB = web3.utils.toWei(stakingInfo.rateB.toString());\n        const lpFarmToken = getFarmLPToken(stakingInfo);\n        const stakedAmount = initTokenAmountFromCallResult(lpFarmToken, balanceState);\n        const totalStakedAmount = initTokenAmountFromCallResult(lpFarmToken, totalSupplyState); // Previously Uni was used all over the place (which was an abstract to get the quick token)\n        // These rates are just used for informational purposes and the token should should not be used anywhere\n        // instead we will supply a dummy token, until this can be refactored properly.\n\n        const dummyToken = GlobalValue.tokens.COMMON.NEW_QUICK;\n        const totalRewardRateA = new TokenAmount(dummyToken, JSBI.BigInt(stakingInfo.ended ? 0 : rateA));\n        const totalRewardRateB = new TokenAmount(dummyToken, JSBI.BigInt(stakingInfo.ended ? 0 : rateB)); //const pair = info[index].pair.toLowerCase();\n        //const fees = (pairData && pairData[pair] ? pairData[pair].oneDayVolumeUSD * 0.0025: 0);\n\n        const totalRewardRateA01 = initTokenAmountFromCallResult(dummyToken, rewardRateAState);\n        const totalRewardRateB01 = initTokenAmountFromCallResult(dummyToken, rewardRateBState);\n        const individualRewardRateA = getHypotheticalRewardRate(dummyToken, stakedAmount, totalStakedAmount, totalRewardRateA01);\n        const individualRewardRateB = getHypotheticalRewardRate(dummyToken, stakedAmount, totalStakedAmount, totalRewardRateB01);\n        const {\n          oneDayFee,\n          accountFee\n        } = getStakingFees(stakingInfo, balanceState, totalSupplyState);\n        let valueOfTotalStakedAmountInBaseToken;\n        const [, stakingTokenPair] = stakingPairs[index];\n        const totalSupply = totalSupplys[index];\n        const usdPrice = usdPrices[index];\n\n        if (totalSupply && stakingTokenPair && baseTokens[index] && totalStakedAmount) {\n          // take the total amount of LP tokens staked, multiply by ETH value of all LP tokens, divide by all LP tokens\n          valueOfTotalStakedAmountInBaseToken = new TokenAmount(baseTokens[index], JSBI.divide(JSBI.multiply(JSBI.multiply(totalStakedAmount.raw, stakingTokenPair.reserveOf(baseTokens[index]).raw), JSBI.BigInt(2) // this is b/c the value of LP shares are ~double the value of the WETH they entitle owner to\n          ), totalSupply.raw));\n        }\n\n        const valueOfTotalStakedAmountInUSDC = valueOfTotalStakedAmountInBaseToken && (usdPrice === null || usdPrice === void 0 ? void 0 : usdPrice.quote(valueOfTotalStakedAmountInBaseToken));\n        const tvl = valueOfTotalStakedAmountInUSDC ? valueOfTotalStakedAmountInUSDC.toExact() : (_valueOfTotalStakedAm = valueOfTotalStakedAmountInBaseToken) === null || _valueOfTotalStakedAm === void 0 ? void 0 : _valueOfTotalStakedAm.toExact();\n        const perMonthReturnInRewards = (stakingInfo.rateA * rewardTokenAPrice + stakingInfo.rateB * rewardTokenBPrice) * (getDaysCurrentYear() / 12) / Number(valueOfTotalStakedAmountInUSDC === null || valueOfTotalStakedAmountInUSDC === void 0 ? void 0 : valueOfTotalStakedAmountInUSDC.toExact());\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          tokens: stakingInfo.tokens,\n          ended: stakingInfo.ended,\n          name: stakingInfo.name,\n          lp: stakingInfo.lp,\n          earnedAmountA: initTokenAmountFromCallResult(dummyToken, earnedAAmountState),\n          earnedAmountB: initTokenAmountFromCallResult(dummyToken, earnedBAmountState),\n          rewardRateA: individualRewardRateA,\n          rewardRateB: individualRewardRateB,\n          totalRewardRateA: totalRewardRateA,\n          totalRewardRateB: totalRewardRateB,\n          stakedAmount: stakedAmount,\n          totalStakedAmount: totalStakedAmount,\n          baseToken: stakingInfo.baseToken,\n          pair: stakingInfo.pair,\n          rateA: stakingInfo.rateA,\n          rateB: stakingInfo.rateB,\n          rewardTokenA: stakingInfo.rewardTokenA,\n          rewardTokenB: stakingInfo.rewardTokenB,\n          rewardTokenBBase: stakingInfo.rewardTokenBBase,\n          rewardTokenAPrice: stakingInfo.ended ? 0 : rewardTokenAPrice,\n          rewardTokenBPrice: stakingInfo.ended ? 0 : rewardTokenBPrice,\n          tvl,\n          perMonthReturnInRewards: stakingInfo.ended ? undefined : perMonthReturnInRewards,\n          totalSupply: stakingInfo.ended ? undefined : totalSupply,\n          usdPrice,\n          stakingTokenPair,\n          oneDayFee: stakingInfo.ended ? 0 : oneDayFee,\n          accountFee: stakingInfo.ended ? 0 : accountFee\n        });\n      }\n\n      return memo;\n    }, []);\n  }, [balances, chainId, earnedAAmounts, earnedBAmounts, info, rewardsAddresses, totalSupplies, rewardRatesA, rewardRatesB, baseTokens, totalSupplys, usdPrices, stakingPairs, rewardTokenAPrices, rewardTokenBPrices]).filter(stakingInfo => filter && filter.isStaked ? stakingInfo.stakedAmount && stakingInfo.stakedAmount.greaterThan('0') : true);\n}\n\n_s5(useDualStakingInfo, \"ISJhiroZskMCgHMFO54FiMwyc1Y=\", false, function () {\n  return [useActiveWeb3React, useDefaultDualFarmList, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useUSDCPrices, useTotalSupplys, usePairs, useUSDCPricesToken, useUSDCPricesToken];\n});\n\nexport function useOldLairInfo() {\n  _s6();\n\n  const lairContract = useLairContract();\n  const quickContract = useQUICKContract();\n  const lairAddress = GlobalConst.addresses.LAIR_ADDRESS;\n  const quickToken = GlobalValue.tokens.COMMON.OLD_QUICK;\n  const dQuickToken = GlobalValue.tokens.COMMON.OLD_DQUICK;\n  return useLairInfo(lairContract, quickContract, lairAddress, quickToken, dQuickToken);\n}\n\n_s6(useOldLairInfo, \"zDb0eSRbVrmq2ha+wHVOYUBoH/8=\", false, function () {\n  return [useLairContract, useQUICKContract, useLairInfo];\n});\n\nexport function useNewLairInfo() {\n  _s7();\n\n  const lairContract = useNewLairContract();\n  const quickContract = useNewQUICKContract();\n  const lairAddress = GlobalConst.addresses.NEW_LAIR_ADDRESS;\n  const quickToken = GlobalValue.tokens.COMMON.NEW_QUICK;\n  const dQuickToken = GlobalValue.tokens.COMMON.NEW_DQUICK;\n  return useLairInfo(lairContract, quickContract, lairAddress, quickToken, dQuickToken);\n}\n\n_s7(useNewLairInfo, \"ytjP0fhY/eQgBYcw4+/PUTJTPeA=\", false, function () {\n  return [useNewLairContract, useNewQUICKContract, useLairInfo];\n});\n\nfunction useLairInfo(lairContract, quickContract, lairAddress, quickToken, dQuickToken) {\n  _s8();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  let accountArg = useMemo(() => [account !== null && account !== void 0 ? account : undefined], [account]);\n  const inputs = ['1000000000000000000'];\n\n  const _dQuickTotalSupply = useSingleCallResult(lairContract, 'totalSupply', []);\n\n  const quickBalance = useSingleCallResult(lairContract, 'QUICKBalance', accountArg);\n  const dQuickBalance = useSingleCallResult(lairContract, 'balanceOf', accountArg);\n  const dQuickToQuick = useSingleCallResult(lairContract, 'dQUICKForQUICK', inputs);\n  const quickToDQuick = useSingleCallResult(lairContract, 'QUICKForDQUICK', inputs);\n  accountArg = [lairAddress !== null && lairAddress !== void 0 ? lairAddress : undefined];\n  const lairsQuickBalance = useSingleCallResult(quickContract, 'balanceOf', accountArg);\n  useEffect(() => {\n    getOneDayVolume();\n  }, []);\n  return useMemo(() => {\n    var _dQuickToQuick$result, _dQuickToQuick$result2, _quickToDQuick$result, _quickToDQuick$result2, _dQuickBalance$result, _dQuickBalance$result2, _quickBalance$result$, _quickBalance$result, _lairsQuickBalance$re, _lairsQuickBalance$re2, _dQuickTotalSupply$re, _dQuickTotalSupply$re2;\n\n    return {\n      lairAddress: lairAddress,\n      dQUICKtoQUICK: new TokenAmount(quickToken, JSBI.BigInt((_dQuickToQuick$result = dQuickToQuick === null || dQuickToQuick === void 0 ? void 0 : (_dQuickToQuick$result2 = dQuickToQuick.result) === null || _dQuickToQuick$result2 === void 0 ? void 0 : _dQuickToQuick$result2[0]) !== null && _dQuickToQuick$result !== void 0 ? _dQuickToQuick$result : 0)),\n      QUICKtodQUICK: new TokenAmount(dQuickToken, JSBI.BigInt((_quickToDQuick$result = quickToDQuick === null || quickToDQuick === void 0 ? void 0 : (_quickToDQuick$result2 = quickToDQuick.result) === null || _quickToDQuick$result2 === void 0 ? void 0 : _quickToDQuick$result2[0]) !== null && _quickToDQuick$result !== void 0 ? _quickToDQuick$result : 0)),\n      dQUICKBalance: new TokenAmount(dQuickToken, JSBI.BigInt((_dQuickBalance$result = dQuickBalance === null || dQuickBalance === void 0 ? void 0 : (_dQuickBalance$result2 = dQuickBalance.result) === null || _dQuickBalance$result2 === void 0 ? void 0 : _dQuickBalance$result2[0]) !== null && _dQuickBalance$result !== void 0 ? _dQuickBalance$result : 0)),\n      QUICKBalance: new TokenAmount(quickToken, JSBI.BigInt((_quickBalance$result$ = quickBalance === null || quickBalance === void 0 ? void 0 : (_quickBalance$result = quickBalance.result) === null || _quickBalance$result === void 0 ? void 0 : _quickBalance$result[0]) !== null && _quickBalance$result$ !== void 0 ? _quickBalance$result$ : 0)),\n      totalQuickBalance: new TokenAmount(quickToken, JSBI.BigInt((_lairsQuickBalance$re = lairsQuickBalance === null || lairsQuickBalance === void 0 ? void 0 : (_lairsQuickBalance$re2 = lairsQuickBalance.result) === null || _lairsQuickBalance$re2 === void 0 ? void 0 : _lairsQuickBalance$re2[0]) !== null && _lairsQuickBalance$re !== void 0 ? _lairsQuickBalance$re : 0)),\n      dQuickTotalSupply: new TokenAmount(dQuickToken, JSBI.BigInt((_dQuickTotalSupply$re = _dQuickTotalSupply === null || _dQuickTotalSupply === void 0 ? void 0 : (_dQuickTotalSupply$re2 = _dQuickTotalSupply.result) === null || _dQuickTotalSupply$re2 === void 0 ? void 0 : _dQuickTotalSupply$re2[0]) !== null && _dQuickTotalSupply$re !== void 0 ? _dQuickTotalSupply$re : 0)),\n      oneDayVol: oneDayVol\n    };\n  }, [lairAddress, quickBalance, dQuickBalance, _dQuickTotalSupply, lairsQuickBalance, dQuickToQuick, quickToDQuick, dQuickToken, quickToken]);\n} // gets the staking info from the network for the active chain id\n\n\n_s8(useLairInfo, \"mdOQdZiYt8ghu6P5dN+0pKvpKLU=\", false, function () {\n  return [useActiveWeb3React, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult];\n});\n\nexport function useStakingInfo(chainId, pairToFilterBy, startIndex, endIndex, filter) {\n  _s9();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const activeFarms = useDefaultFarmList()[chainId];\n  const info = useMemo(() => Object.values(activeFarms).filter(x => !x.ended).slice(startIndex, endIndex).filter(stakingRewardInfo => pairToFilterBy === undefined || pairToFilterBy === null ? getSearchFiltered(stakingRewardInfo, filter ? filter.search : '') : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) && pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1])), [pairToFilterBy, startIndex, endIndex, filter, activeFarms]);\n  const rewardsAddresses = useMemo(() => info.map(_ref6 => {\n    let {\n      stakingRewardAddress\n    } = _ref6;\n    return stakingRewardAddress;\n  }), [info]);\n  const accountArg = useMemo(() => [account !== null && account !== void 0 ? account : undefined], [account]); // get all the info from the staking rewards contracts\n\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg);\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg);\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply');\n  const rewardRates = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'rewardRate', undefined, NEVER_RELOAD);\n  const baseTokens = info.map(item => {\n    const unwrappedCurrency = unwrappedToken(item.baseToken);\n    const empty = GlobalValue.tokens.COMMON.EMPTY;\n    return unwrappedCurrency === empty ? item.tokens[0] : item.baseToken;\n  });\n  const rewardTokens = info.map(item => item.rewardToken);\n  const usdPrices = useUSDCPrices(baseTokens);\n  const usdPricesRewardTokens = useUSDCPricesToken(rewardTokens);\n  const totalSupplys = useTotalSupplys(info.map(item => {\n    const lp = item.lp;\n    const dummyPair = new Pair(new TokenAmount(item.tokens[0], '0'), new TokenAmount(item.tokens[1], '0'));\n    return lp && lp !== '' ? new Token(2000, lp, 18, 'SLP', 'Staked LP') : dummyPair.liquidityToken;\n  }));\n  const stakingPairs = usePairs(info.map(item => item.tokens));\n  return useMemo(() => {\n    if (!chainId) return [];\n    return rewardsAddresses.reduce((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index];\n      const earnedAmountState = earnedAmounts[index]; // these get fetched regardless of account\n\n      const totalSupplyState = totalSupplies[index];\n      const rewardRateState = rewardRates[index];\n      const stakingInfo = info[index];\n      const rewardTokenPrice = usdPricesRewardTokens[index];\n\n      if ( // these may be undefined if not logged in\n      !(balanceState !== null && balanceState !== void 0 && balanceState.loading) && !(earnedAmountState !== null && earnedAmountState !== void 0 && earnedAmountState.loading) && // always need these\n      totalSupplyState && !totalSupplyState.loading && rewardRateState && !rewardRateState.loading) {\n        var _valueOfTotalStakedAm2;\n\n        const rate = web3.utils.toWei(stakingInfo.rate.toString());\n        const lpFarmToken = getFarmLPToken(stakingInfo);\n        const stakedAmount = initTokenAmountFromCallResult(lpFarmToken, balanceState);\n        const totalStakedAmount = initTokenAmountFromCallResult(lpFarmToken, totalSupplyState); // Previously Uni was used all over the place (which was an abstract to get the quick token)\n        // These rates are just used for informational purposes and the token should should not be used anywhere\n        // instead we will supply a dummy token, until this can be refactored properly.\n\n        const dummyToken = GlobalValue.tokens.COMMON.NEW_QUICK;\n        const totalRewardRate = new TokenAmount(dummyToken, JSBI.BigInt(rate));\n        const totalRewardRate01 = initTokenAmountFromCallResult(dummyToken, rewardRateState);\n        const individualRewardRate = getHypotheticalRewardRate(dummyToken, stakedAmount, totalStakedAmount, totalRewardRate01);\n        const {\n          oneYearFeeAPY,\n          oneDayFee,\n          accountFee\n        } = getStakingFees(stakingInfo, balanceState, totalSupplyState);\n        let valueOfTotalStakedAmountInBaseToken;\n        const [, stakingTokenPair] = stakingPairs[index];\n        const totalSupply = totalSupplys[index];\n        const usdPrice = usdPrices[index];\n\n        if (totalSupply && stakingTokenPair && baseTokens[index] && totalStakedAmount) {\n          // take the total amount of LP tokens staked, multiply by ETH value of all LP tokens, divide by all LP tokens\n          valueOfTotalStakedAmountInBaseToken = new TokenAmount(baseTokens[index], JSBI.divide(JSBI.multiply(JSBI.multiply(totalStakedAmount.raw, stakingTokenPair.reserveOf(baseTokens[index]).raw), JSBI.BigInt(2) // this is b/c the value of LP shares are ~double the value of the WETH they entitle owner to\n          ), totalSupply.raw));\n        }\n\n        const valueOfTotalStakedAmountInUSDC = valueOfTotalStakedAmountInBaseToken && (usdPrice === null || usdPrice === void 0 ? void 0 : usdPrice.quote(valueOfTotalStakedAmountInBaseToken));\n        const tvl = valueOfTotalStakedAmountInUSDC ? valueOfTotalStakedAmountInUSDC.toExact() : (_valueOfTotalStakedAm2 = valueOfTotalStakedAmountInBaseToken) === null || _valueOfTotalStakedAm2 === void 0 ? void 0 : _valueOfTotalStakedAm2.toExact();\n        const perMonthReturnInRewards = Number(stakingInfo.rate) * rewardTokenPrice * (getDaysCurrentYear() / 12) / Number(valueOfTotalStakedAmountInUSDC === null || valueOfTotalStakedAmountInUSDC === void 0 ? void 0 : valueOfTotalStakedAmountInUSDC.toExact());\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          tokens: stakingInfo.tokens,\n          ended: stakingInfo.ended,\n          name: stakingInfo.name,\n          lp: stakingInfo.lp,\n          rewardToken: stakingInfo.rewardToken,\n          rewardTokenPrice,\n          earnedAmount: initTokenAmountFromCallResult(dummyToken, earnedAmountState),\n          rewardRate: individualRewardRate,\n          totalRewardRate: totalRewardRate,\n          stakedAmount: stakedAmount,\n          totalStakedAmount: totalStakedAmount,\n          baseToken: stakingInfo.baseToken,\n          pair: stakingInfo.pair,\n          rate: stakingInfo.rate,\n          oneYearFeeAPY: oneYearFeeAPY,\n          oneDayFee,\n          accountFee,\n          tvl,\n          perMonthReturnInRewards,\n          valueOfTotalStakedAmountInBaseToken,\n          usdPrice,\n          stakingTokenPair,\n          totalSupply\n        });\n      }\n\n      return memo;\n    }, []);\n  }, [balances, chainId, earnedAmounts, info, rewardsAddresses, totalSupplies, rewardRates, usdPricesRewardTokens, baseTokens, totalSupplys, usdPrices, stakingPairs]).filter(stakingInfo => filter && filter.isStaked ? stakingInfo.stakedAmount && stakingInfo.stakedAmount.greaterThan('0') : true);\n}\n\n_s9(useStakingInfo, \"PAmDkoCFhGuEYJXw9mp9IcSUW6I=\", false, function () {\n  return [useActiveWeb3React, useDefaultFarmList, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useUSDCPrices, useUSDCPricesToken, useTotalSupplys, usePairs];\n});\n\nexport function useOldStakingInfo(chainId, pairToFilterBy, startIndex, endIndex, filter) {\n  _s10();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const oldFarms = useDefaultFarmList()[chainId];\n  const info = useMemo(() => Object.values(oldFarms).filter(x => x.ended).slice(startIndex, endIndex).filter(stakingRewardInfo => pairToFilterBy === undefined || pairToFilterBy === null ? getSearchFiltered(stakingRewardInfo, filter ? filter.search : '') : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) && pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1])), [pairToFilterBy, startIndex, endIndex, filter, oldFarms]);\n  const rewardsAddresses = useMemo(() => info.map(_ref7 => {\n    let {\n      stakingRewardAddress\n    } = _ref7;\n    return stakingRewardAddress;\n  }), [info]);\n  const accountArg = useMemo(() => [account !== null && account !== void 0 ? account : undefined], [account]); // get all the info from the staking rewards contracts\n\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg);\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg);\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply');\n  const stakingPairs = usePairs(info.map(item => item.tokens));\n  return useMemo(() => {\n    if (!chainId) return [];\n    return rewardsAddresses.reduce((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index];\n      const earnedAmountState = earnedAmounts[index]; // these get fetched regardless of account\n\n      const totalSupplyState = totalSupplies[index];\n      const stakingInfo = info[index];\n\n      if ( // these may be undefined if not logged in\n      !(balanceState !== null && balanceState !== void 0 && balanceState.loading) && !(earnedAmountState !== null && earnedAmountState !== void 0 && earnedAmountState.loading) && // always need these\n      totalSupplyState && !totalSupplyState.loading) {\n        const lpFarmToken = getFarmLPToken(stakingInfo);\n        const stakedAmount = initTokenAmountFromCallResult(lpFarmToken, balanceState);\n        const totalStakedAmount = initTokenAmountFromCallResult(lpFarmToken, totalSupplyState); // Previously Uni was used all over the place (which was an abstract to get the quick token)\n        // These rates are just used for informational purposes and the token should should not be used anywhere\n        // instead we will supply a dummy token, until this can be refactored properly.\n\n        const dummyToken = GlobalValue.tokens.COMMON.NEW_QUICK;\n        const totalRewardRate = new TokenAmount(dummyToken, JSBI.BigInt(0));\n        const individualRewardRate = getHypotheticalRewardRate(dummyToken, stakedAmount, totalStakedAmount, totalRewardRate);\n        const [, stakingTokenPair] = stakingPairs[index];\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          tokens: stakingInfo.tokens,\n          ended: stakingInfo.ended,\n          name: stakingInfo.name,\n          lp: stakingInfo.lp,\n          rewardToken: stakingInfo.rewardToken,\n          rewardTokenPrice: 0,\n          earnedAmount: initTokenAmountFromCallResult(dummyToken, earnedAmountState),\n          rewardRate: individualRewardRate,\n          totalRewardRate: totalRewardRate,\n          stakedAmount: stakedAmount,\n          totalStakedAmount: totalStakedAmount,\n          baseToken: stakingInfo.baseToken,\n          pair: stakingInfo.pair,\n          rate: stakingInfo.rate,\n          oneYearFeeAPY: 0,\n          oneDayFee: 0,\n          accountFee: 0,\n          stakingTokenPair\n        });\n      }\n\n      return memo;\n    }, []);\n  }, [balances, chainId, earnedAmounts, info, rewardsAddresses, totalSupplies, stakingPairs]).filter(stakingInfo => filter && filter.isStaked ? stakingInfo.stakedAmount && stakingInfo.stakedAmount.greaterThan('0') : true);\n}\n\n_s10(useOldStakingInfo, \"+sbAZZvrRK622fLbAQDdf/Ux780=\", false, function () {\n  return [useActiveWeb3React, useDefaultFarmList, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, usePairs];\n});\n\nexport function useDQUICKtoQUICK() {\n  _s11();\n\n  var _dQuickToQuickState$r, _dQuickToQuickState$r2;\n\n  const lair = useLairContract();\n  const inputs = ['1000000000000000000'];\n  const dQuickToQuickState = useSingleCallResult(lair, 'dQUICKForQUICK', inputs);\n  if (dQuickToQuickState.loading || dQuickToQuickState.error) return 0;\n  return Number(new TokenAmount(GlobalValue.tokens.COMMON.OLD_QUICK, JSBI.BigInt((_dQuickToQuickState$r = dQuickToQuickState === null || dQuickToQuickState === void 0 ? void 0 : (_dQuickToQuickState$r2 = dQuickToQuickState.result) === null || _dQuickToQuickState$r2 === void 0 ? void 0 : _dQuickToQuickState$r2[0]) !== null && _dQuickToQuickState$r !== void 0 ? _dQuickToQuickState$r : 0)).toExact());\n}\n\n_s11(useDQUICKtoQUICK, \"zGHp7+1iVdw9qiWfO+qu5NgsAj8=\", false, function () {\n  return [useLairContract, useSingleCallResult];\n});\n\nexport function useDerivedSyrupInfo(typedValue, stakingToken, userLiquidityUnstaked) {\n  _s12();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const parsedInput = tryParseAmount(typedValue, stakingToken);\n  const parsedAmount = parsedInput && userLiquidityUnstaked && JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw) ? parsedInput : undefined;\n  let error;\n\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n\n  if (!parsedAmount) {\n    var _error;\n\n    error = (_error = error) !== null && _error !== void 0 ? _error : 'Enter an amount';\n  }\n\n  return {\n    parsedAmount,\n    error\n  };\n} // based on typed value\n\n_s12(useDerivedSyrupInfo, \"SBDWLFuvTxBgnBUfJpXeYDOlPck=\", false, function () {\n  return [useActiveWeb3React];\n});\n\nexport function useDerivedStakeInfo(typedValue, stakingToken, userLiquidityUnstaked) {\n  _s13();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const parsedInput = tryParseAmount(typedValue, stakingToken);\n  const parsedAmount = parsedInput && userLiquidityUnstaked && JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw) ? parsedInput : undefined;\n  let error;\n\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n\n  if (!parsedAmount) {\n    var _error2;\n\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 : 'Enter an amount';\n  }\n\n  return {\n    parsedAmount,\n    error\n  };\n}\n\n_s13(useDerivedStakeInfo, \"SBDWLFuvTxBgnBUfJpXeYDOlPck=\", false, function () {\n  return [useActiveWeb3React];\n});\n\nexport function useDerivedLairInfo(typedValue, stakingToken, userLiquidityUnstaked) {\n  _s14();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const parsedInput = tryParseAmount(typedValue, stakingToken);\n  const parsedAmount = parsedInput && userLiquidityUnstaked && JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw) ? parsedInput : undefined;\n  let error;\n\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n\n  if (!parsedAmount) {\n    var _error3;\n\n    error = (_error3 = error) !== null && _error3 !== void 0 ? _error3 : 'Enter an amount';\n  }\n\n  return {\n    parsedAmount,\n    error\n  };\n} // based on typed value\n\n_s14(useDerivedLairInfo, \"SBDWLFuvTxBgnBUfJpXeYDOlPck=\", false, function () {\n  return [useActiveWeb3React];\n});\n\nexport function useDerivedUnstakeInfo(typedValue, stakingAmount) {\n  _s15();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const parsedInput = tryParseAmount(typedValue, stakingAmount.token);\n  const parsedAmount = parsedInput && JSBI.lessThanOrEqual(parsedInput.raw, stakingAmount.raw) ? parsedInput : undefined;\n  let error;\n\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n\n  if (!parsedAmount) {\n    var _error4;\n\n    error = (_error4 = error) !== null && _error4 !== void 0 ? _error4 : 'Enter an amount';\n  }\n\n  return {\n    parsedAmount,\n    error\n  };\n} // based on typed value\n\n_s15(useDerivedUnstakeInfo, \"SBDWLFuvTxBgnBUfJpXeYDOlPck=\", false, function () {\n  return [useActiveWeb3React];\n});\n\nexport function useDerivedUnstakeLairInfo(typedValue, stakingAmount) {\n  _s16();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const parsedInput = tryParseAmount(typedValue, stakingAmount.token);\n  const parsedAmount = parsedInput && JSBI.lessThanOrEqual(parsedInput.raw, stakingAmount.raw) ? parsedInput : undefined;\n  let error;\n\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n\n  if (!parsedAmount) {\n    var _error5;\n\n    error = (_error5 = error) !== null && _error5 !== void 0 ? _error5 : 'Enter an amount';\n  }\n\n  return {\n    parsedAmount,\n    error\n  };\n}\n\n_s16(useDerivedUnstakeLairInfo, \"SBDWLFuvTxBgnBUfJpXeYDOlPck=\", false, function () {\n  return [useActiveWeb3React];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/state/stake/hooks.ts"],"names":["JSBI","Token","TokenAmount","Pair","dayjs","useMemo","useEffect","usePairs","client","GLOBAL_DATA","PAIRS_BULK","PAIRS_HISTORICAL_BULK","GlobalConst","GlobalValue","STAKING_REWARDS_INTERFACE","STAKING_DUAL_REWARDS_INTERFACE","useActiveWeb3React","NEVER_RELOAD","useMultipleContractSingleData","useSingleCallResult","tryParseAmount","Web3","useLairContract","useNewLairContract","useNewQUICKContract","useQUICKContract","useUSDCPrices","useUSDCPricesToken","unwrappedToken","useTotalSupplys","getBlockFromTimestamp","getDaysCurrentYear","getFarmLPToken","getOneYearFee","getSyrupLPToken","initTokenAmountFromCallResult","getCallStateResult","useDefaultFarmList","useDefaultDualFarmList","useDefaultSyrupList","web3","STAKING_GENESIS","REWARDS_DURATION_DAYS","pairs","undefined","oneDayVol","useTotalRewardsDistributed","chainId","syrupRewardsInfo","Object","values","dualStakingRewardsInfo","filter","x","ended","stakingRewardsInfo","syrupTokenPairs","map","item","token","baseToken","syrupUSDBaseTokenPrices","syrupRewardsUSD","reduce","total","index","syrupTokenPair","tokenPairPrice","priceOf","usdPriceBaseToken","priceOfRewardTokenInUSD","Number","toSignificant","rate","rewardTokenAPrices","rewardTokenA","rewardTokenBPrices","rewardTokenB","dualStakingRewardsUSD","rateA","rateB","rewardTokenPrices","rewardToken","stakingRewardsUSD","useUSDRewardsandFees","isLPFarm","bulkPairData","activeFarms","activeDualFarms","rewardsInfos","rewardsAddresses","stakingRewardAddress","stakingRewardTokens","stakingRewardTokenPrices","dualStakingRewardTokenAPrices","dualStakingRewardTokenBPrices","rewardPairs","pair","totalSupplies","rewardsUSD","stakingFees","oneYearFeeAPY","oneDayVolumeUSD","totalSupplyState","totalSupply","utils","toWei","ratio","result","toString","oneDayFee","FEEPERCENT","useFilteredSyrupInfo","tokenToFilterBy","startIndex","endIndex","account","currentTimestamp","unix","allSyrups","info","slice","syrupInfo","ending","getSearchFiltered","search","equals","accountArg","balances","earnedAmounts","rewardRates","stakingTokenPairs","usdBaseTokenPrices","stakingTokenPrices","stakingToken","memo","rewardsAddress","balanceState","earnedAmountState","stakingTokenPrice","rewardRateState","loading","stakingTokenPair","rewards","syrupToken","stakedAmount","totalStakedAmount","totalRewardRate","BigInt","rewardRate","getHypotheticalRewardRate","greaterThan","raw","divide","multiply","individualRewardRate","periodFinishMs","push","name","lp","periodFinish","earnedAmount","rewardTokenPriceinUSD","valueOfTotalStakedAmountInUSDC","toExact","isStaked","useOldSyrupInfo","allOldSyrupInfos","getBulkPairData","pairList","utcCurrentTime","utcOneDayBack","subtract","oneDayOldBlock","current","query","fetchPolicy","oneDayResult","Promise","all","block","cResult","oneDayData","data","obj","cur","i","id","pairData","oneDayHistory","parseData","object","convertArrayToObject","keys","length","e","console","log","getOneDayVolume","eth","getBlockNumber","uniswapFactories","get2DayPercentChange","totalVolumeUSD","array","key","initialValue","valueNow","value24HoursAgo","volumeUSD","token0","token1","reserveUSD","searchLowered","toLowerCase","tokens","infoToken0","infoToken1","symbol","indexOf","address","getStakingFees","stakingInfo","accountFee","balanceResult","totalSupplyResult","myRatio","useDualStakingInfo","pairToFilterBy","isEndedFarm","stakingRewardInfo","involvesToken","earnedAAmounts","earnedBAmounts","rewardRatesA","rewardRatesB","baseTokens","unwrappedCurrency","empty","COMMON","EMPTY","usdPrices","totalSupplys","stakingPairs","earnedAAmountState","earnedBAmountState","rewardRateAState","rewardRateBState","rewardTokenAPrice","rewardTokenBPrice","lpFarmToken","dummyToken","NEW_QUICK","totalRewardRateA","totalRewardRateB","totalRewardRateA01","totalRewardRateB01","individualRewardRateA","individualRewardRateB","valueOfTotalStakedAmountInBaseToken","usdPrice","reserveOf","quote","tvl","perMonthReturnInRewards","earnedAmountA","earnedAmountB","rewardRateA","rewardRateB","rewardTokenBBase","useOldLairInfo","lairContract","quickContract","lairAddress","addresses","LAIR_ADDRESS","quickToken","OLD_QUICK","dQuickToken","OLD_DQUICK","useLairInfo","useNewLairInfo","NEW_LAIR_ADDRESS","NEW_DQUICK","inputs","_dQuickTotalSupply","quickBalance","dQuickBalance","dQuickToQuick","quickToDQuick","lairsQuickBalance","dQUICKtoQUICK","QUICKtodQUICK","dQUICKBalance","QUICKBalance","totalQuickBalance","dQuickTotalSupply","useStakingInfo","rewardTokens","usdPricesRewardTokens","dummyPair","liquidityToken","rewardTokenPrice","totalRewardRate01","useOldStakingInfo","oldFarms","useDQUICKtoQUICK","lair","dQuickToQuickState","error","useDerivedSyrupInfo","typedValue","userLiquidityUnstaked","parsedInput","parsedAmount","lessThanOrEqual","useDerivedStakeInfo","useDerivedLairInfo","useDerivedUnstakeInfo","stakingAmount","useDerivedUnstakeLairInfo"],"mappings":"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","sourcesContent":["import {\n  CurrencyAmount,\n  JSBI,\n  Token,\n  TokenAmount,\n  Pair,\n  ChainId,\n} from '@uniswap/sdk';\nimport dayjs from 'dayjs';\nimport { useMemo, useEffect } from 'react';\nimport { usePairs } from 'data/Reserves';\n\nimport { client } from 'apollo/client';\nimport { GLOBAL_DATA, PAIRS_BULK, PAIRS_HISTORICAL_BULK } from 'apollo/queries';\nimport { GlobalConst, GlobalValue } from 'constants/index';\nimport {\n  STAKING_REWARDS_INTERFACE,\n  STAKING_DUAL_REWARDS_INTERFACE,\n} from 'constants/abis/staking-rewards';\nimport { useActiveWeb3React } from 'hooks';\nimport {\n  CallState,\n  NEVER_RELOAD,\n  useMultipleContractSingleData,\n  useSingleCallResult,\n} from 'state/multicall/hooks';\nimport { tryParseAmount } from 'state/swap/hooks';\nimport Web3 from 'web3';\nimport {\n  useLairContract,\n  useNewLairContract,\n  useNewQUICKContract,\n  useQUICKContract,\n} from 'hooks/useContract';\nimport { useUSDCPrices, useUSDCPricesToken } from 'utils/useUSDCPrice';\nimport { unwrappedToken } from 'utils/wrappedCurrency';\nimport { useTotalSupplys } from 'data/TotalSupply';\nimport {\n  getBlockFromTimestamp,\n  getDaysCurrentYear,\n  getFarmLPToken,\n  getOneYearFee,\n  getSyrupLPToken,\n  initTokenAmountFromCallResult,\n  getCallStateResult,\n} from 'utils';\n\nimport {\n  SyrupInfo,\n  LairInfo,\n  StakingInfo,\n  DualStakingInfo,\n  StakingBasic,\n  DualStakingBasic,\n} from 'types';\nimport { useDefaultFarmList } from 'state/farms/hooks';\nimport { useDefaultDualFarmList } from 'state/dualfarms/hooks';\nimport { useDefaultSyrupList } from 'state/syrups/hooks';\nimport { Contract } from '@ethersproject/contracts';\n\nconst web3 = new Web3('https://rpc-sg.dogechain.dog/');\n\nexport const STAKING_GENESIS = 1620842940;\n\nexport const REWARDS_DURATION_DAYS = 7;\n\nlet pairs: any = undefined;\n\nlet oneDayVol: any = undefined;\n\nexport function useTotalRewardsDistributed(chainId: ChainId): number {\n  const syrupRewardsInfo = Object.values(useDefaultSyrupList()[chainId]);\n  const dualStakingRewardsInfo = Object.values(\n    useDefaultDualFarmList()[chainId],\n  ).filter((x) => !x.ended);\n  const stakingRewardsInfo = Object.values(\n    useDefaultFarmList()[chainId],\n  ).filter((x) => !x.ended);\n\n  const syrupTokenPairs = usePairs(\n    syrupRewardsInfo.map((item) => [\n      unwrappedToken(item.token),\n      unwrappedToken(item.baseToken),\n    ]),\n  );\n  const syrupUSDBaseTokenPrices = useUSDCPrices(\n    syrupRewardsInfo.map((item) => unwrappedToken(item.baseToken)),\n  );\n  const syrupRewardsUSD = syrupRewardsInfo.reduce((total, item, index) => {\n    const [, syrupTokenPair] = syrupTokenPairs[index];\n    const tokenPairPrice = syrupTokenPair?.priceOf(item.token);\n    const usdPriceBaseToken = syrupUSDBaseTokenPrices[index];\n    const priceOfRewardTokenInUSD =\n      Number(tokenPairPrice?.toSignificant()) *\n      Number(usdPriceBaseToken?.toSignificant());\n    return total + priceOfRewardTokenInUSD * item.rate;\n  }, 0);\n\n  const rewardTokenAPrices = useUSDCPricesToken(\n    dualStakingRewardsInfo.map((item) => item.rewardTokenA),\n  );\n  const rewardTokenBPrices = useUSDCPricesToken(\n    dualStakingRewardsInfo.map((item) => item.rewardTokenB),\n  );\n  const dualStakingRewardsUSD = dualStakingRewardsInfo.reduce(\n    (total, item, index) =>\n      total +\n      item.rateA * rewardTokenAPrices[index] +\n      item.rateB * rewardTokenBPrices[index],\n    0,\n  );\n\n  const rewardTokenPrices = useUSDCPricesToken(\n    stakingRewardsInfo.map((item) => item.rewardToken),\n  );\n  const stakingRewardsUSD = stakingRewardsInfo.reduce(\n    (total, item, index) => total + item.rate * rewardTokenPrices[index],\n    0,\n  );\n\n  return syrupRewardsUSD + dualStakingRewardsUSD + stakingRewardsUSD;\n}\n\nexport function useUSDRewardsandFees(\n  isLPFarm: boolean,\n  bulkPairData: any,\n  chainId: ChainId,\n): { rewardsUSD: number; stakingFees: number | null } {\n  const activeFarms = Object.values(useDefaultFarmList()[chainId]).filter(\n    (x) => !x.ended,\n  );\n  const activeDualFarms = Object.values(\n    useDefaultDualFarmList()[chainId],\n  ).filter((x) => !x.ended);\n  const stakingRewardsInfo = isLPFarm ? activeFarms : [];\n  const dualStakingRewardsInfo = !isLPFarm ? activeDualFarms : [];\n  const rewardsInfos = isLPFarm ? stakingRewardsInfo : dualStakingRewardsInfo;\n  const rewardsAddresses = useMemo(\n    () => rewardsInfos.map(({ stakingRewardAddress }) => stakingRewardAddress),\n    [rewardsInfos],\n  );\n  const stakingRewardTokens = stakingRewardsInfo.map(\n    (item) => item.rewardToken,\n  );\n  const stakingRewardTokenPrices = useUSDCPricesToken(stakingRewardTokens);\n  const dualStakingRewardTokenAPrices = useUSDCPricesToken(\n    dualStakingRewardsInfo.map((item) => item.rewardTokenA),\n  );\n  const dualStakingRewardTokenBPrices = useUSDCPricesToken(\n    dualStakingRewardsInfo.map((item) => item.rewardTokenB),\n  );\n  const rewardPairs = useMemo(() => rewardsInfos.map(({ pair }) => pair), [\n    rewardsInfos,\n  ]);\n  const totalSupplies = useMultipleContractSingleData(\n    rewardsAddresses,\n    isLPFarm ? STAKING_REWARDS_INTERFACE : STAKING_DUAL_REWARDS_INTERFACE,\n    'totalSupply',\n  );\n  let rewardsUSD: number | null = null;\n  if (isLPFarm) {\n    rewardsUSD = stakingRewardsInfo.reduce(\n      (total, item, index) =>\n        total + item.rate * stakingRewardTokenPrices[index],\n      0,\n    );\n  } else {\n    rewardsUSD = dualStakingRewardsInfo.reduce(\n      (total, item, index) =>\n        total +\n        item.rateA * dualStakingRewardTokenAPrices[index] +\n        item.rateB * dualStakingRewardTokenBPrices[index],\n      0,\n    );\n  }\n  const stakingFees = bulkPairData\n    ? rewardPairs.reduce((total, pair, index) => {\n        const oneYearFeeAPY = Number(bulkPairData[pair]?.oneDayVolumeUSD ?? 0);\n        const totalSupplyState = totalSupplies[index];\n        if (oneYearFeeAPY) {\n          const totalSupply = web3.utils.toWei(\n            pairs[pair]?.totalSupply,\n            'ether',\n          );\n          const ratio =\n            Number(totalSupplyState.result?.[0].toString()) /\n            Number(totalSupply);\n          const oneDayFee =\n            oneYearFeeAPY * GlobalConst.utils.FEEPERCENT * ratio;\n          return total + oneDayFee;\n        } else {\n          return total;\n        }\n      }, 0)\n    : null;\n\n  return { rewardsUSD, stakingFees };\n}\n\nexport function useFilteredSyrupInfo(\n  chainId: ChainId,\n  tokenToFilterBy?: Token | null,\n  startIndex?: number,\n  endIndex?: number,\n  filter?: { search: string; isStaked: boolean },\n): SyrupInfo[] {\n  const { account } = useActiveWeb3React();\n  const currentTimestamp = dayjs().unix();\n  const allSyrups = useDefaultSyrupList()[chainId];\n  const info = useMemo(\n    () =>\n      Object.values(allSyrups)\n        .slice(startIndex, endIndex)\n        .filter(\n          (syrupInfo) =>\n            syrupInfo.ending > currentTimestamp &&\n            (tokenToFilterBy === undefined || tokenToFilterBy === null\n              ? getSearchFiltered(syrupInfo, filter ? filter.search : '')\n              : tokenToFilterBy.equals(syrupInfo.token)),\n        ),\n    [\n      tokenToFilterBy,\n      startIndex,\n      endIndex,\n      filter,\n      currentTimestamp,\n      allSyrups,\n    ],\n  );\n\n  const rewardsAddresses = useMemo(\n    () => info.map(({ stakingRewardAddress }) => stakingRewardAddress),\n    [info],\n  );\n\n  const accountArg = useMemo(() => [account ?? undefined], [account]);\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'balanceOf',\n    accountArg,\n  );\n  const earnedAmounts = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'earned',\n    accountArg,\n  );\n  const totalSupplies = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'totalSupply',\n  );\n  const rewardRates = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'rewardRate',\n    undefined,\n    NEVER_RELOAD,\n  );\n\n  const stakingTokenPairs = usePairs(\n    info.map((item) => [\n      unwrappedToken(item.token),\n      unwrappedToken(item.baseToken),\n    ]),\n  );\n\n  const usdBaseTokenPrices = useUSDCPrices(\n    info.map((item) => unwrappedToken(item.baseToken)),\n  );\n\n  const stakingTokenPrices = useUSDCPricesToken(\n    info.map((item) => item.stakingToken),\n  );\n\n  return useMemo(() => {\n    if (!chainId) return [];\n\n    return rewardsAddresses.reduce<SyrupInfo[]>(\n      (memo, rewardsAddress, index) => {\n        // these two are dependent on account\n        const balanceState = balances[index];\n        const earnedAmountState = earnedAmounts[index];\n        const stakingTokenPrice = stakingTokenPrices[index];\n\n        // these get fetched regardless of account\n        const totalSupplyState = totalSupplies[index];\n        const rewardRateState = rewardRates[index];\n        const syrupInfo = info[index];\n\n        if (\n          // these may be undefined if not logged in\n          !balanceState?.loading &&\n          !earnedAmountState?.loading &&\n          // always need these\n          totalSupplyState &&\n          !totalSupplyState.loading &&\n          rewardRateState &&\n          !rewardRateState.loading\n        ) {\n          // get the LP token\n          const token = syrupInfo.token;\n          const [, stakingTokenPair] = stakingTokenPairs[index];\n          const tokenPairPrice = stakingTokenPair?.priceOf(token);\n          const usdPriceBaseToken = usdBaseTokenPrices[index];\n          const priceOfRewardTokenInUSD =\n            tokenPairPrice && usdPriceBaseToken\n              ? Number(tokenPairPrice.toSignificant()) *\n                Number(usdPriceBaseToken.toSignificant())\n              : undefined;\n\n          const rewards = syrupInfo.rate * (priceOfRewardTokenInUSD ?? 0);\n\n          // check for account, if no account set to 0\n          const rate = web3.utils.toWei(syrupInfo.rate.toString());\n          const syrupToken = getSyrupLPToken(syrupInfo);\n          const stakedAmount = initTokenAmountFromCallResult(\n            syrupToken,\n            balanceState,\n          );\n          const totalStakedAmount = initTokenAmountFromCallResult(\n            syrupToken,\n            totalSupplyState,\n          );\n          const totalRewardRate = new TokenAmount(token, JSBI.BigInt(rate));\n          //const pair = info[index].pair.toLowerCase();\n          //const fees = (pairData && pairData[pair] ? pairData[pair].oneDayVolumeUSD * 0.0025: 0);\n          const rewardRate = initTokenAmountFromCallResult(\n            token,\n            rewardRateState,\n          );\n          const getHypotheticalRewardRate = (\n            stakedAmount?: TokenAmount,\n            totalStakedAmount?: TokenAmount,\n          ): TokenAmount | undefined => {\n            if (!stakedAmount || !totalStakedAmount || !rewardRate) return;\n            return new TokenAmount(\n              token,\n              JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0))\n                ? JSBI.divide(\n                    JSBI.multiply(rewardRate.raw, stakedAmount.raw),\n                    totalStakedAmount.raw,\n                  )\n                : JSBI.BigInt(0),\n            );\n          };\n\n          const individualRewardRate = getHypotheticalRewardRate(\n            stakedAmount,\n            totalStakedAmount,\n          );\n\n          const periodFinishMs = syrupInfo.ending;\n\n          memo.push({\n            stakingRewardAddress: rewardsAddress,\n            token: syrupInfo.token,\n            ended: syrupInfo.ended,\n            name: syrupInfo.name,\n            lp: syrupInfo.lp,\n            periodFinish: periodFinishMs,\n            earnedAmount: initTokenAmountFromCallResult(\n              token,\n              earnedAmountState,\n            ),\n            rewardRate: individualRewardRate,\n            totalRewardRate: totalRewardRate,\n            stakedAmount: stakedAmount,\n            totalStakedAmount: totalStakedAmount,\n            getHypotheticalRewardRate,\n            baseToken: syrupInfo.baseToken,\n            rate: syrupInfo.rate,\n            rewardTokenPriceinUSD: priceOfRewardTokenInUSD,\n            rewards,\n            stakingToken: syrupInfo.stakingToken,\n            valueOfTotalStakedAmountInUSDC: totalStakedAmount\n              ? Number(totalStakedAmount.toExact()) * stakingTokenPrice\n              : undefined,\n          });\n        }\n        return memo;\n      },\n      [],\n    );\n  }, [\n    balances,\n    chainId,\n    earnedAmounts,\n    info,\n    rewardsAddresses,\n    totalSupplies,\n    rewardRates,\n    stakingTokenPairs,\n    usdBaseTokenPrices,\n    stakingTokenPrices,\n  ]).filter((syrupInfo) =>\n    filter && filter.isStaked\n      ? syrupInfo.stakedAmount && syrupInfo.stakedAmount.greaterThan('0')\n      : true,\n  );\n}\n\nexport function useOldSyrupInfo(\n  chainId: ChainId,\n  tokenToFilterBy?: Token | null,\n  startIndex?: number,\n  endIndex?: number,\n  filter?: { search: string; isStaked: boolean },\n): SyrupInfo[] {\n  const { account } = useActiveWeb3React();\n  const currentTimestamp = dayjs().unix();\n  const allOldSyrupInfos = useDefaultSyrupList()[chainId];\n\n  const info = useMemo(() => {\n    return Object.values(allOldSyrupInfos)\n      .filter((x) => x.ending <= currentTimestamp)\n      .slice(startIndex, endIndex)\n      .filter((syrupInfo) =>\n        tokenToFilterBy === undefined || tokenToFilterBy === null\n          ? getSearchFiltered(syrupInfo, filter ? filter.search : '')\n          : tokenToFilterBy.equals(syrupInfo.token),\n      );\n  }, [\n    tokenToFilterBy,\n    startIndex,\n    endIndex,\n    filter,\n    currentTimestamp,\n    allOldSyrupInfos,\n  ]);\n\n  const rewardsAddresses = useMemo(\n    () => info.map(({ stakingRewardAddress }) => stakingRewardAddress),\n    [info],\n  );\n\n  const accountArg = useMemo(() => [account ?? undefined], [account]);\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'balanceOf',\n    accountArg,\n  );\n  const earnedAmounts = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'earned',\n    accountArg,\n  );\n  const totalSupplies = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'totalSupply',\n  );\n\n  const rewardRates = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'rewardRate',\n    undefined,\n    NEVER_RELOAD,\n  );\n\n  const stakingTokenPairs = usePairs(\n    info.map((item) => [\n      unwrappedToken(item.token),\n      unwrappedToken(item.baseToken),\n    ]),\n  );\n\n  const usdBaseTokenPrices = useUSDCPrices(\n    info.map((item) => unwrappedToken(item.baseToken)),\n  );\n\n  const stakingTokenPrices = useUSDCPricesToken(\n    info.map((item) => item.stakingToken),\n  );\n\n  return useMemo(() => {\n    if (!chainId) return [];\n\n    return rewardsAddresses.reduce<SyrupInfo[]>(\n      (memo, rewardsAddress, index) => {\n        // these two are dependent on account\n        const balanceState = balances[index];\n        const earnedAmountState = earnedAmounts[index];\n\n        // these get fetched regardless of account\n        const totalSupplyState = totalSupplies[index];\n        const rewardRateState = rewardRates[index];\n        const syrupInfo = info[index];\n        const stakingTokenPrice = stakingTokenPrices[index];\n\n        if (\n          // these may be undefined if not logged in\n          !balanceState?.loading &&\n          !earnedAmountState?.loading &&\n          // always need these\n          totalSupplyState &&\n          !totalSupplyState.loading &&\n          rewardRateState &&\n          !rewardRateState.loading\n        ) {\n          // get the LP token\n          const token = syrupInfo.token;\n\n          // check for account, if no account set to 0\n          const rate = web3.utils.toWei(syrupInfo.rate.toString());\n          const stakedAmount = initTokenAmountFromCallResult(\n            getSyrupLPToken(syrupInfo),\n            balanceState,\n          );\n          const totalStakedAmount = initTokenAmountFromCallResult(\n            getSyrupLPToken(syrupInfo),\n            totalSupplyState,\n          );\n          const totalRewardRate = new TokenAmount(token, JSBI.BigInt(rate));\n          //const pair = info[index].pair.toLowerCase();\n          //const fees = (pairData && pairData[pair] ? pairData[pair].oneDayVolumeUSD * 0.0025: 0);\n          const rewardRate = initTokenAmountFromCallResult(\n            token,\n            rewardRateState,\n          );\n          const getHypotheticalRewardRate = (\n            stakedAmount?: TokenAmount,\n            totalStakedAmount?: TokenAmount,\n          ): TokenAmount | undefined => {\n            if (!stakedAmount || !totalStakedAmount || !rewardRate) return;\n            return new TokenAmount(\n              token,\n              JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0))\n                ? JSBI.divide(\n                    JSBI.multiply(rewardRate.raw, stakedAmount.raw),\n                    totalStakedAmount.raw,\n                  )\n                : JSBI.BigInt(0),\n            );\n          };\n\n          const individualRewardRate = getHypotheticalRewardRate(\n            stakedAmount,\n            totalStakedAmount,\n          );\n\n          const periodFinishMs = syrupInfo.ending;\n\n          const [, stakingTokenPair] = stakingTokenPairs[index];\n          const tokenPairPrice = stakingTokenPair?.priceOf(token);\n          const usdPriceBaseToken = usdBaseTokenPrices[index];\n          const priceOfRewardTokenInUSD =\n            Number(tokenPairPrice?.toSignificant()) *\n            Number(usdPriceBaseToken?.toSignificant());\n\n          memo.push({\n            stakingRewardAddress: rewardsAddress,\n            token: syrupInfo.token,\n            ended: true,\n            name: syrupInfo.name,\n            lp: syrupInfo.lp,\n            periodFinish: periodFinishMs,\n            earnedAmount: initTokenAmountFromCallResult(\n              token,\n              earnedAmountState,\n            ),\n            rewardRate: individualRewardRate,\n            totalRewardRate: totalRewardRate,\n            stakedAmount: stakedAmount,\n            totalStakedAmount: totalStakedAmount,\n            getHypotheticalRewardRate,\n            baseToken: syrupInfo.baseToken,\n            rate: 0,\n            rewardTokenPriceinUSD: priceOfRewardTokenInUSD,\n            stakingToken: syrupInfo.stakingToken,\n            valueOfTotalStakedAmountInUSDC: totalStakedAmount\n              ? Number(totalStakedAmount.toExact()) * stakingTokenPrice\n              : undefined,\n          });\n        }\n        return memo;\n      },\n      [],\n    );\n  }, [\n    balances,\n    chainId,\n    earnedAmounts,\n    info,\n    rewardsAddresses,\n    totalSupplies,\n    rewardRates,\n    stakingTokenPairs,\n    usdBaseTokenPrices,\n    stakingTokenPrices,\n  ]).filter((syrupInfo) =>\n    filter && filter.isStaked\n      ? syrupInfo.stakedAmount && syrupInfo.stakedAmount.greaterThan('0')\n      : true,\n  );\n}\n\nexport const getBulkPairData = async (pairList: any) => {\n  // if (pairs !== undefined) {\n  //   return;\n  // }\n  const utcCurrentTime = dayjs();\n  const utcOneDayBack = utcCurrentTime.subtract(1, 'day').unix();\n\n  const oneDayOldBlock = await getBlockFromTimestamp(utcOneDayBack);\n\n  try {\n    const current = await client.query({\n      query: PAIRS_BULK(pairList),\n      fetchPolicy: 'network-only',\n    });\n\n    const [oneDayResult] = await Promise.all(\n      [oneDayOldBlock].map(async (block) => {\n        const cResult = await client.query({\n          query: PAIRS_HISTORICAL_BULK(block, pairList),\n          fetchPolicy: 'network-only',\n        });\n\n        return cResult;\n      }),\n    );\n\n    const oneDayData = oneDayResult?.data?.pairs.reduce(\n      (obj: any, cur: any, i: any) => {\n        return { ...obj, [cur.id]: cur };\n      },\n      {},\n    );\n\n    const pairData =\n      current &&\n      current.data.pairs.map((pair: any) => {\n        let data = pair;\n        const oneDayHistory = oneDayData?.[pair.id];\n\n        data = parseData(data, oneDayHistory);\n        return data;\n      });\n\n    const object = convertArrayToObject(pairData, 'id');\n    if (Object.keys(object).length > 0) {\n      pairs = object;\n      return object;\n    }\n    return object;\n  } catch (e) {\n    console.log(e);\n    return;\n  }\n};\n\nconst getOneDayVolume = async () => {\n  let data: any = {};\n  let oneDayData: any = {};\n\n  const current = await web3.eth.getBlockNumber();\n  const utcCurrentTime = dayjs();\n  const utcOneDayBack = utcCurrentTime.subtract(1, 'day').unix();\n\n  const oneDayOldBlock = await getBlockFromTimestamp(utcOneDayBack);\n\n  const result = await client.query({\n    query: GLOBAL_DATA(current),\n    fetchPolicy: 'network-only',\n  });\n\n  data = result.data.uniswapFactories[0];\n\n  // fetch the historical data\n  const oneDayResult = await client.query({\n    query: GLOBAL_DATA(oneDayOldBlock),\n    fetchPolicy: 'network-only',\n  });\n  oneDayData = oneDayResult.data.uniswapFactories[0];\n\n  let oneDayVolumeUSD: any = 0;\n\n  if (data && oneDayData) {\n    oneDayVolumeUSD = get2DayPercentChange(\n      data.totalVolumeUSD,\n      oneDayData.totalVolumeUSD ? oneDayData.totalVolumeUSD : 0,\n    );\n    oneDayVol = oneDayVolumeUSD;\n  }\n\n  return oneDayVolumeUSD;\n};\n\nconst convertArrayToObject = (array: any, key: any) => {\n  const initialValue = {};\n  return array.reduce((obj: any, item: any) => {\n    return {\n      ...obj,\n      [item[key]]: item,\n    };\n  }, initialValue);\n};\n\nexport const get2DayPercentChange = (valueNow: any, value24HoursAgo: any) => {\n  // get volume info for both 24 hour periods\n  return Number(valueNow) - Number(value24HoursAgo);\n};\n\nfunction parseData(data: any, oneDayData: any) {\n  // get volume changes\n  const oneDayVolumeUSD = get2DayPercentChange(\n    data?.volumeUSD,\n    oneDayData?.volumeUSD ? oneDayData.volumeUSD : 0,\n  );\n  return {\n    id: data.id,\n    token0: data.token0,\n    token1: data.token1,\n    oneDayVolumeUSD,\n    reserveUSD: data.reserveUSD,\n    totalSupply: data.totalSupply,\n  };\n}\n\nfunction getSearchFiltered(info: any, search: string) {\n  const searchLowered = search.toLowerCase();\n  if (info.tokens) {\n    const infoToken0 = info.tokens[0];\n    const infoToken1 = info.tokens[1];\n    return (\n      (infoToken0.symbol ?? '').toLowerCase().indexOf(searchLowered) > -1 ||\n      (infoToken0.name ?? '').toLowerCase().indexOf(searchLowered) > -1 ||\n      (infoToken0.address ?? '').toLowerCase().indexOf(searchLowered) > -1 ||\n      (infoToken1.symbol ?? '').toLowerCase().indexOf(searchLowered) > -1 ||\n      (infoToken1.name ?? '').toLowerCase().indexOf(searchLowered) > -1 ||\n      (infoToken1.address ?? '').toLowerCase().indexOf(searchLowered) > -1\n    );\n  } else if (info.token) {\n    return (\n      (info.token.symbol ?? '').toLowerCase().indexOf(searchLowered) > -1 ||\n      (info.token.name ?? '').toLowerCase().indexOf(searchLowered) > -1 ||\n      (info.token.address ?? '').toLowerCase().indexOf(searchLowered) > -1\n    );\n  } else {\n    return false;\n  }\n}\n\nexport function getStakingFees(\n  stakingInfo: StakingBasic | DualStakingBasic,\n  balanceState?: CallState,\n  totalSupplyState?: CallState,\n) {\n  let oneYearFeeAPY = 0;\n  let oneDayFee = 0;\n  let accountFee = 0;\n  if (pairs !== undefined) {\n    oneYearFeeAPY = pairs[stakingInfo.pair]?.oneDayVolumeUSD;\n    const balanceResult = getCallStateResult(balanceState);\n    const totalSupplyResult = getCallStateResult(totalSupplyState);\n\n    if (oneYearFeeAPY && balanceResult && totalSupplyResult) {\n      const totalSupply = web3.utils.toWei(\n        pairs[stakingInfo.pair]?.totalSupply,\n        'ether',\n      );\n      const ratio = Number(totalSupplyResult) / Number(totalSupply);\n      const myRatio = Number(balanceResult) / Number(totalSupplyResult);\n      oneDayFee = oneYearFeeAPY * GlobalConst.utils.FEEPERCENT * ratio;\n      accountFee = oneDayFee * myRatio;\n      oneYearFeeAPY = getOneYearFee(\n        oneYearFeeAPY,\n        pairs[stakingInfo.pair]?.reserveUSD,\n      );\n    }\n  }\n  return { oneYearFeeAPY, oneDayFee, accountFee };\n}\n\nconst getHypotheticalRewardRate = (\n  token: Token,\n  stakedAmount?: TokenAmount,\n  totalStakedAmount?: TokenAmount,\n  totalRewardRate?: TokenAmount,\n): TokenAmount | undefined => {\n  if (!stakedAmount || !totalStakedAmount || !totalRewardRate) return;\n  return new TokenAmount(\n    token,\n    JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0))\n      ? JSBI.divide(\n          JSBI.multiply(totalRewardRate.raw, stakedAmount.raw),\n          totalStakedAmount.raw,\n        )\n      : JSBI.BigInt(0),\n  );\n};\n\n// gets the dual rewards staking info from the network for the active chain id\nexport function useDualStakingInfo(\n  chainId: ChainId,\n  pairToFilterBy?: Pair | null,\n  startIndex?: number,\n  endIndex?: number,\n  filter?: { search: string; isStaked: boolean; isEndedFarm: boolean },\n): DualStakingInfo[] {\n  const { account } = useActiveWeb3React();\n  const dualStakingRewardsInfo = useDefaultDualFarmList();\n\n  const info = useMemo(\n    () =>\n      Object.values(dualStakingRewardsInfo[chainId])\n        .filter((x) => (filter?.isEndedFarm ? x.ended : !x.ended))\n        .slice(startIndex, endIndex)\n        .filter((stakingRewardInfo) =>\n          pairToFilterBy === undefined || pairToFilterBy === null\n            ? getSearchFiltered(stakingRewardInfo, filter ? filter.search : '')\n            : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) &&\n              pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1]),\n        ),\n    [\n      chainId,\n      pairToFilterBy,\n      startIndex,\n      endIndex,\n      filter,\n      dualStakingRewardsInfo,\n    ],\n  );\n\n  const rewardsAddresses = useMemo(\n    () => info.map(({ stakingRewardAddress }) => stakingRewardAddress),\n    [info],\n  );\n\n  const accountArg = useMemo(() => [account ?? undefined], [account]);\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_DUAL_REWARDS_INTERFACE,\n    'balanceOf',\n    accountArg,\n  );\n  const earnedAAmounts = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_DUAL_REWARDS_INTERFACE,\n    'earnedA',\n    accountArg,\n  );\n  const earnedBAmounts = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_DUAL_REWARDS_INTERFACE,\n    'earnedB',\n    accountArg,\n  );\n  const totalSupplies = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_DUAL_REWARDS_INTERFACE,\n    'totalSupply',\n  );\n  const rewardRatesA = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_DUAL_REWARDS_INTERFACE,\n    'rewardRateA',\n    undefined,\n    NEVER_RELOAD,\n  );\n\n  const rewardRatesB = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_DUAL_REWARDS_INTERFACE,\n    'rewardRateB',\n    undefined,\n    NEVER_RELOAD,\n  );\n\n  const baseTokens = info.map((item) => {\n    const unwrappedCurrency = unwrappedToken(item.baseToken);\n    const empty = unwrappedToken(GlobalValue.tokens.COMMON.EMPTY);\n    return unwrappedCurrency === empty ? item.tokens[0] : item.baseToken;\n  });\n\n  const usdPrices = useUSDCPrices(baseTokens);\n  const totalSupplys = useTotalSupplys(\n    info.map((item) => getFarmLPToken(item)),\n  );\n  const stakingPairs = usePairs(info.map((item) => item.tokens));\n  const rewardTokenAPrices = useUSDCPricesToken(\n    info.map((item) => item.rewardTokenA),\n  );\n  const rewardTokenBPrices = useUSDCPricesToken(\n    info.map((item) => item.rewardTokenB),\n  );\n\n  return useMemo(() => {\n    if (!chainId) return [];\n\n    return rewardsAddresses.reduce<DualStakingInfo[]>(\n      (memo, rewardsAddress, index) => {\n        // these two are dependent on account\n        const balanceState = balances[index];\n        const earnedAAmountState = earnedAAmounts[index];\n        const earnedBAmountState = earnedBAmounts[index];\n\n        // these get fetched regardless of account\n        const totalSupplyState = totalSupplies[index];\n        const rewardRateAState = rewardRatesA[index];\n        const rewardRateBState = rewardRatesB[index];\n        const stakingInfo = info[index];\n        const rewardTokenAPrice = rewardTokenAPrices[index];\n        const rewardTokenBPrice = rewardTokenBPrices[index];\n\n        if (\n          // these may be undefined if not logged in\n          !balanceState?.loading &&\n          !earnedAAmountState?.loading &&\n          !earnedBAmountState?.loading &&\n          // always need these\n          totalSupplyState &&\n          !totalSupplyState.loading &&\n          rewardRateAState &&\n          !rewardRateAState.loading &&\n          rewardRateBState\n        ) {\n          const rateA = web3.utils.toWei(stakingInfo.rateA.toString());\n          const rateB = web3.utils.toWei(stakingInfo.rateB.toString());\n          const lpFarmToken = getFarmLPToken(stakingInfo);\n          const stakedAmount = initTokenAmountFromCallResult(\n            lpFarmToken,\n            balanceState,\n          );\n          const totalStakedAmount = initTokenAmountFromCallResult(\n            lpFarmToken,\n            totalSupplyState,\n          );\n\n          // Previously Uni was used all over the place (which was an abstract to get the quick token)\n          // These rates are just used for informational purposes and the token should should not be used anywhere\n          // instead we will supply a dummy token, until this can be refactored properly.\n          const dummyToken = GlobalValue.tokens.COMMON.NEW_QUICK;\n          const totalRewardRateA = new TokenAmount(\n            dummyToken,\n            JSBI.BigInt(stakingInfo.ended ? 0 : rateA),\n          );\n          const totalRewardRateB = new TokenAmount(\n            dummyToken,\n            JSBI.BigInt(stakingInfo.ended ? 0 : rateB),\n          );\n          //const pair = info[index].pair.toLowerCase();\n          //const fees = (pairData && pairData[pair] ? pairData[pair].oneDayVolumeUSD * 0.0025: 0);\n          const totalRewardRateA01 = initTokenAmountFromCallResult(\n            dummyToken,\n            rewardRateAState,\n          );\n          const totalRewardRateB01 = initTokenAmountFromCallResult(\n            dummyToken,\n            rewardRateBState,\n          );\n\n          const individualRewardRateA = getHypotheticalRewardRate(\n            dummyToken,\n            stakedAmount,\n            totalStakedAmount,\n            totalRewardRateA01,\n          );\n          const individualRewardRateB = getHypotheticalRewardRate(\n            dummyToken,\n            stakedAmount,\n            totalStakedAmount,\n            totalRewardRateB01,\n          );\n\n          const { oneDayFee, accountFee } = getStakingFees(\n            stakingInfo,\n            balanceState,\n            totalSupplyState,\n          );\n\n          let valueOfTotalStakedAmountInBaseToken: TokenAmount | undefined;\n\n          const [, stakingTokenPair] = stakingPairs[index];\n          const totalSupply = totalSupplys[index];\n          const usdPrice = usdPrices[index];\n\n          if (\n            totalSupply &&\n            stakingTokenPair &&\n            baseTokens[index] &&\n            totalStakedAmount\n          ) {\n            // take the total amount of LP tokens staked, multiply by ETH value of all LP tokens, divide by all LP tokens\n            valueOfTotalStakedAmountInBaseToken = new TokenAmount(\n              baseTokens[index],\n              JSBI.divide(\n                JSBI.multiply(\n                  JSBI.multiply(\n                    totalStakedAmount.raw,\n                    stakingTokenPair.reserveOf(baseTokens[index]).raw,\n                  ),\n                  JSBI.BigInt(2), // this is b/c the value of LP shares are ~double the value of the WETH they entitle owner to\n                ),\n                totalSupply.raw,\n              ),\n            );\n          }\n\n          const valueOfTotalStakedAmountInUSDC =\n            valueOfTotalStakedAmountInBaseToken &&\n            usdPrice?.quote(valueOfTotalStakedAmountInBaseToken);\n\n          const tvl = valueOfTotalStakedAmountInUSDC\n            ? valueOfTotalStakedAmountInUSDC.toExact()\n            : valueOfTotalStakedAmountInBaseToken?.toExact();\n\n          const perMonthReturnInRewards =\n            ((stakingInfo.rateA * rewardTokenAPrice +\n              stakingInfo.rateB * rewardTokenBPrice) *\n              (getDaysCurrentYear() / 12)) /\n            Number(valueOfTotalStakedAmountInUSDC?.toExact());\n\n          memo.push({\n            stakingRewardAddress: rewardsAddress,\n            tokens: stakingInfo.tokens,\n            ended: stakingInfo.ended,\n            name: stakingInfo.name,\n            lp: stakingInfo.lp,\n            earnedAmountA: initTokenAmountFromCallResult(\n              dummyToken,\n              earnedAAmountState,\n            ),\n            earnedAmountB: initTokenAmountFromCallResult(\n              dummyToken,\n              earnedBAmountState,\n            ),\n            rewardRateA: individualRewardRateA,\n            rewardRateB: individualRewardRateB,\n            totalRewardRateA: totalRewardRateA,\n            totalRewardRateB: totalRewardRateB,\n            stakedAmount: stakedAmount,\n            totalStakedAmount: totalStakedAmount,\n            baseToken: stakingInfo.baseToken,\n            pair: stakingInfo.pair,\n            rateA: stakingInfo.rateA,\n            rateB: stakingInfo.rateB,\n            rewardTokenA: stakingInfo.rewardTokenA,\n            rewardTokenB: stakingInfo.rewardTokenB,\n            rewardTokenBBase: stakingInfo.rewardTokenBBase,\n            rewardTokenAPrice: stakingInfo.ended ? 0 : rewardTokenAPrice,\n            rewardTokenBPrice: stakingInfo.ended ? 0 : rewardTokenBPrice,\n            tvl,\n            perMonthReturnInRewards: stakingInfo.ended\n              ? undefined\n              : perMonthReturnInRewards,\n            totalSupply: stakingInfo.ended ? undefined : totalSupply,\n            usdPrice,\n            stakingTokenPair,\n            oneDayFee: stakingInfo.ended ? 0 : oneDayFee,\n            accountFee: stakingInfo.ended ? 0 : accountFee,\n          });\n        }\n        return memo;\n      },\n      [],\n    );\n  }, [\n    balances,\n    chainId,\n    earnedAAmounts,\n    earnedBAmounts,\n    info,\n    rewardsAddresses,\n    totalSupplies,\n    rewardRatesA,\n    rewardRatesB,\n    baseTokens,\n    totalSupplys,\n    usdPrices,\n    stakingPairs,\n    rewardTokenAPrices,\n    rewardTokenBPrices,\n  ]).filter((stakingInfo) =>\n    filter && filter.isStaked\n      ? stakingInfo.stakedAmount && stakingInfo.stakedAmount.greaterThan('0')\n      : true,\n  );\n}\n\nexport function useOldLairInfo(): LairInfo {\n  const lairContract = useLairContract();\n  const quickContract = useQUICKContract();\n  const lairAddress = GlobalConst.addresses.LAIR_ADDRESS;\n  const quickToken = GlobalValue.tokens.COMMON.OLD_QUICK;\n  const dQuickToken = GlobalValue.tokens.COMMON.OLD_DQUICK;\n\n  return useLairInfo(\n    lairContract,\n    quickContract,\n    lairAddress,\n    quickToken,\n    dQuickToken,\n  );\n}\n\nexport function useNewLairInfo(): LairInfo {\n  const lairContract = useNewLairContract();\n  const quickContract = useNewQUICKContract();\n  const lairAddress = GlobalConst.addresses.NEW_LAIR_ADDRESS;\n  const quickToken = GlobalValue.tokens.COMMON.NEW_QUICK;\n  const dQuickToken = GlobalValue.tokens.COMMON.NEW_DQUICK;\n\n  return useLairInfo(\n    lairContract,\n    quickContract,\n    lairAddress,\n    quickToken,\n    dQuickToken,\n  );\n}\n\nfunction useLairInfo(\n  lairContract: Contract | null,\n  quickContract: Contract | null,\n  lairAddress: string,\n  quickToken: Token,\n  dQuickToken: Token,\n) {\n  const { account } = useActiveWeb3React();\n\n  let accountArg = useMemo(() => [account ?? undefined], [account]);\n  const inputs = ['1000000000000000000'];\n  const _dQuickTotalSupply = useSingleCallResult(\n    lairContract,\n    'totalSupply',\n    [],\n  );\n\n  const quickBalance = useSingleCallResult(\n    lairContract,\n    'QUICKBalance',\n    accountArg,\n  );\n  const dQuickBalance = useSingleCallResult(\n    lairContract,\n    'balanceOf',\n    accountArg,\n  );\n  const dQuickToQuick = useSingleCallResult(\n    lairContract,\n    'dQUICKForQUICK',\n    inputs,\n  );\n  const quickToDQuick = useSingleCallResult(\n    lairContract,\n    'QUICKForDQUICK',\n    inputs,\n  );\n\n  accountArg = [lairAddress ?? undefined];\n\n  const lairsQuickBalance = useSingleCallResult(\n    quickContract,\n    'balanceOf',\n    accountArg,\n  );\n\n  useEffect(() => {\n    getOneDayVolume();\n  }, []);\n\n  return useMemo(() => {\n    return {\n      lairAddress: lairAddress,\n      dQUICKtoQUICK: new TokenAmount(\n        quickToken,\n        JSBI.BigInt(dQuickToQuick?.result?.[0] ?? 0),\n      ),\n      QUICKtodQUICK: new TokenAmount(\n        dQuickToken,\n        JSBI.BigInt(quickToDQuick?.result?.[0] ?? 0),\n      ),\n      dQUICKBalance: new TokenAmount(\n        dQuickToken,\n        JSBI.BigInt(dQuickBalance?.result?.[0] ?? 0),\n      ),\n      QUICKBalance: new TokenAmount(\n        quickToken,\n        JSBI.BigInt(quickBalance?.result?.[0] ?? 0),\n      ),\n      totalQuickBalance: new TokenAmount(\n        quickToken,\n        JSBI.BigInt(lairsQuickBalance?.result?.[0] ?? 0),\n      ),\n      dQuickTotalSupply: new TokenAmount(\n        dQuickToken,\n        JSBI.BigInt(_dQuickTotalSupply?.result?.[0] ?? 0),\n      ),\n      oneDayVol: oneDayVol,\n    };\n  }, [\n    lairAddress,\n    quickBalance,\n    dQuickBalance,\n    _dQuickTotalSupply,\n    lairsQuickBalance,\n    dQuickToQuick,\n    quickToDQuick,\n    dQuickToken,\n    quickToken,\n  ]);\n}\n\n// gets the staking info from the network for the active chain id\nexport function useStakingInfo(\n  chainId: ChainId,\n  pairToFilterBy?: Pair | null,\n  startIndex?: number,\n  endIndex?: number,\n  filter?: { search: string; isStaked: boolean },\n): StakingInfo[] {\n  const { account } = useActiveWeb3React();\n  const activeFarms = useDefaultFarmList()[chainId];\n  const info = useMemo(\n    () =>\n      Object.values(activeFarms)\n        .filter((x) => !x.ended)\n        .slice(startIndex, endIndex)\n        .filter((stakingRewardInfo) =>\n          pairToFilterBy === undefined || pairToFilterBy === null\n            ? getSearchFiltered(stakingRewardInfo, filter ? filter.search : '')\n            : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) &&\n              pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1]),\n        ),\n    [pairToFilterBy, startIndex, endIndex, filter, activeFarms],\n  );\n\n  const rewardsAddresses = useMemo(\n    () => info.map(({ stakingRewardAddress }) => stakingRewardAddress),\n    [info],\n  );\n\n  const accountArg = useMemo(() => [account ?? undefined], [account]);\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'balanceOf',\n    accountArg,\n  );\n  const earnedAmounts = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'earned',\n    accountArg,\n  );\n  const totalSupplies = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'totalSupply',\n  );\n  const rewardRates = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'rewardRate',\n    undefined,\n    NEVER_RELOAD,\n  );\n\n  const baseTokens = info.map((item) => {\n    const unwrappedCurrency = unwrappedToken(item.baseToken);\n    const empty = GlobalValue.tokens.COMMON.EMPTY;\n    return unwrappedCurrency === empty ? item.tokens[0] : item.baseToken;\n  });\n  const rewardTokens = info.map((item) => item.rewardToken);\n\n  const usdPrices = useUSDCPrices(baseTokens);\n  const usdPricesRewardTokens = useUSDCPricesToken(rewardTokens);\n  const totalSupplys = useTotalSupplys(\n    info.map((item) => {\n      const lp = item.lp;\n      const dummyPair = new Pair(\n        new TokenAmount(item.tokens[0], '0'),\n        new TokenAmount(item.tokens[1], '0'),\n      );\n      return lp && lp !== ''\n        ? new Token(2000, lp, 18, 'SLP', 'Staked LP')\n        : dummyPair.liquidityToken;\n    }),\n  );\n  const stakingPairs = usePairs(info.map((item) => item.tokens));\n\n  return useMemo(() => {\n    if (!chainId) return [];\n\n    return rewardsAddresses.reduce<StakingInfo[]>(\n      (memo, rewardsAddress, index) => {\n        // these two are dependent on account\n        const balanceState = balances[index];\n        const earnedAmountState = earnedAmounts[index];\n\n        // these get fetched regardless of account\n        const totalSupplyState = totalSupplies[index];\n        const rewardRateState = rewardRates[index];\n        const stakingInfo = info[index];\n        const rewardTokenPrice = usdPricesRewardTokens[index];\n\n        if (\n          // these may be undefined if not logged in\n          !balanceState?.loading &&\n          !earnedAmountState?.loading &&\n          // always need these\n          totalSupplyState &&\n          !totalSupplyState.loading &&\n          rewardRateState &&\n          !rewardRateState.loading\n        ) {\n          const rate = web3.utils.toWei(stakingInfo.rate.toString());\n          const lpFarmToken = getFarmLPToken(stakingInfo);\n          const stakedAmount = initTokenAmountFromCallResult(\n            lpFarmToken,\n            balanceState,\n          );\n          const totalStakedAmount = initTokenAmountFromCallResult(\n            lpFarmToken,\n            totalSupplyState,\n          );\n\n          // Previously Uni was used all over the place (which was an abstract to get the quick token)\n          // These rates are just used for informational purposes and the token should should not be used anywhere\n          // instead we will supply a dummy token, until this can be refactored properly.\n          const dummyToken = GlobalValue.tokens.COMMON.NEW_QUICK;\n          const totalRewardRate = new TokenAmount(\n            dummyToken,\n            JSBI.BigInt(rate),\n          );\n          const totalRewardRate01 = initTokenAmountFromCallResult(\n            dummyToken,\n            rewardRateState,\n          );\n\n          const individualRewardRate = getHypotheticalRewardRate(\n            dummyToken,\n            stakedAmount,\n            totalStakedAmount,\n            totalRewardRate01,\n          );\n\n          const { oneYearFeeAPY, oneDayFee, accountFee } = getStakingFees(\n            stakingInfo,\n            balanceState,\n            totalSupplyState,\n          );\n\n          let valueOfTotalStakedAmountInBaseToken: TokenAmount | undefined;\n\n          const [, stakingTokenPair] = stakingPairs[index];\n          const totalSupply = totalSupplys[index];\n          const usdPrice = usdPrices[index];\n\n          if (\n            totalSupply &&\n            stakingTokenPair &&\n            baseTokens[index] &&\n            totalStakedAmount\n          ) {\n            // take the total amount of LP tokens staked, multiply by ETH value of all LP tokens, divide by all LP tokens\n            valueOfTotalStakedAmountInBaseToken = new TokenAmount(\n              baseTokens[index],\n              JSBI.divide(\n                JSBI.multiply(\n                  JSBI.multiply(\n                    totalStakedAmount.raw,\n                    stakingTokenPair.reserveOf(baseTokens[index]).raw,\n                  ),\n                  JSBI.BigInt(2), // this is b/c the value of LP shares are ~double the value of the WETH they entitle owner to\n                ),\n                totalSupply.raw,\n              ),\n            );\n          }\n\n          const valueOfTotalStakedAmountInUSDC =\n            valueOfTotalStakedAmountInBaseToken &&\n            usdPrice?.quote(valueOfTotalStakedAmountInBaseToken);\n\n          const tvl = valueOfTotalStakedAmountInUSDC\n            ? valueOfTotalStakedAmountInUSDC.toExact()\n            : valueOfTotalStakedAmountInBaseToken?.toExact();\n\n          const perMonthReturnInRewards =\n            (Number(stakingInfo.rate) *\n              rewardTokenPrice *\n              (getDaysCurrentYear() / 12)) /\n            Number(valueOfTotalStakedAmountInUSDC?.toExact());\n\n          memo.push({\n            stakingRewardAddress: rewardsAddress,\n            tokens: stakingInfo.tokens,\n            ended: stakingInfo.ended,\n            name: stakingInfo.name,\n            lp: stakingInfo.lp,\n            rewardToken: stakingInfo.rewardToken,\n            rewardTokenPrice,\n            earnedAmount: initTokenAmountFromCallResult(\n              dummyToken,\n              earnedAmountState,\n            ),\n            rewardRate: individualRewardRate,\n            totalRewardRate: totalRewardRate,\n            stakedAmount: stakedAmount,\n            totalStakedAmount: totalStakedAmount,\n            baseToken: stakingInfo.baseToken,\n            pair: stakingInfo.pair,\n            rate: stakingInfo.rate,\n            oneYearFeeAPY: oneYearFeeAPY,\n            oneDayFee,\n            accountFee,\n            tvl,\n            perMonthReturnInRewards,\n            valueOfTotalStakedAmountInBaseToken,\n            usdPrice,\n            stakingTokenPair,\n            totalSupply,\n          });\n        }\n        return memo;\n      },\n      [],\n    );\n  }, [\n    balances,\n    chainId,\n    earnedAmounts,\n    info,\n    rewardsAddresses,\n    totalSupplies,\n    rewardRates,\n    usdPricesRewardTokens,\n    baseTokens,\n    totalSupplys,\n    usdPrices,\n    stakingPairs,\n  ]).filter((stakingInfo) =>\n    filter && filter.isStaked\n      ? stakingInfo.stakedAmount && stakingInfo.stakedAmount.greaterThan('0')\n      : true,\n  );\n}\n\nexport function useOldStakingInfo(\n  chainId: ChainId,\n  pairToFilterBy?: Pair | null,\n  startIndex?: number,\n  endIndex?: number,\n  filter?: { search: string; isStaked: boolean },\n): StakingInfo[] {\n  const { account } = useActiveWeb3React();\n  const oldFarms = useDefaultFarmList()[chainId];\n  const info = useMemo(\n    () =>\n      Object.values(oldFarms)\n        .filter((x) => x.ended)\n        .slice(startIndex, endIndex)\n        .filter((stakingRewardInfo) =>\n          pairToFilterBy === undefined || pairToFilterBy === null\n            ? getSearchFiltered(stakingRewardInfo, filter ? filter.search : '')\n            : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) &&\n              pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1]),\n        ),\n    [pairToFilterBy, startIndex, endIndex, filter, oldFarms],\n  );\n\n  const rewardsAddresses = useMemo(\n    () => info.map(({ stakingRewardAddress }) => stakingRewardAddress),\n    [info],\n  );\n\n  const accountArg = useMemo(() => [account ?? undefined], [account]);\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'balanceOf',\n    accountArg,\n  );\n  const earnedAmounts = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'earned',\n    accountArg,\n  );\n  const totalSupplies = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'totalSupply',\n  );\n\n  const stakingPairs = usePairs(info.map((item) => item.tokens));\n\n  return useMemo(() => {\n    if (!chainId) return [];\n\n    return rewardsAddresses.reduce<StakingInfo[]>(\n      (memo, rewardsAddress, index) => {\n        // these two are dependent on account\n        const balanceState = balances[index];\n        const earnedAmountState = earnedAmounts[index];\n\n        // these get fetched regardless of account\n        const totalSupplyState = totalSupplies[index];\n\n        const stakingInfo = info[index];\n\n        if (\n          // these may be undefined if not logged in\n          !balanceState?.loading &&\n          !earnedAmountState?.loading &&\n          // always need these\n          totalSupplyState &&\n          !totalSupplyState.loading\n        ) {\n          const lpFarmToken = getFarmLPToken(stakingInfo);\n          const stakedAmount = initTokenAmountFromCallResult(\n            lpFarmToken,\n            balanceState,\n          );\n          const totalStakedAmount = initTokenAmountFromCallResult(\n            lpFarmToken,\n            totalSupplyState,\n          );\n\n          // Previously Uni was used all over the place (which was an abstract to get the quick token)\n          // These rates are just used for informational purposes and the token should should not be used anywhere\n          // instead we will supply a dummy token, until this can be refactored properly.\n          const dummyToken = GlobalValue.tokens.COMMON.NEW_QUICK;\n          const totalRewardRate = new TokenAmount(dummyToken, JSBI.BigInt(0));\n\n          const individualRewardRate = getHypotheticalRewardRate(\n            dummyToken,\n            stakedAmount,\n            totalStakedAmount,\n            totalRewardRate,\n          );\n\n          const [, stakingTokenPair] = stakingPairs[index];\n\n          memo.push({\n            stakingRewardAddress: rewardsAddress,\n            tokens: stakingInfo.tokens,\n            ended: stakingInfo.ended,\n            name: stakingInfo.name,\n            lp: stakingInfo.lp,\n            rewardToken: stakingInfo.rewardToken,\n            rewardTokenPrice: 0,\n            earnedAmount: initTokenAmountFromCallResult(\n              dummyToken,\n              earnedAmountState,\n            ),\n            rewardRate: individualRewardRate,\n            totalRewardRate: totalRewardRate,\n            stakedAmount: stakedAmount,\n            totalStakedAmount: totalStakedAmount,\n            baseToken: stakingInfo.baseToken,\n            pair: stakingInfo.pair,\n            rate: stakingInfo.rate,\n            oneYearFeeAPY: 0,\n            oneDayFee: 0,\n            accountFee: 0,\n            stakingTokenPair,\n          });\n        }\n        return memo;\n      },\n      [],\n    );\n  }, [\n    balances,\n    chainId,\n    earnedAmounts,\n    info,\n    rewardsAddresses,\n    totalSupplies,\n    stakingPairs,\n  ]).filter((stakingInfo) =>\n    filter && filter.isStaked\n      ? stakingInfo.stakedAmount && stakingInfo.stakedAmount.greaterThan('0')\n      : true,\n  );\n}\n\nexport function useDQUICKtoQUICK() {\n  const lair = useLairContract();\n  const inputs = ['1000000000000000000'];\n  const dQuickToQuickState = useSingleCallResult(\n    lair,\n    'dQUICKForQUICK',\n    inputs,\n  );\n  if (dQuickToQuickState.loading || dQuickToQuickState.error) return 0;\n  return Number(\n    new TokenAmount(\n      GlobalValue.tokens.COMMON.OLD_QUICK,\n      JSBI.BigInt(dQuickToQuickState?.result?.[0] ?? 0),\n    ).toExact(),\n  );\n}\n\nexport function useDerivedSyrupInfo(\n  typedValue: string,\n  stakingToken: Token | undefined,\n  userLiquidityUnstaked: TokenAmount | undefined,\n): {\n  parsedAmount?: CurrencyAmount;\n  error?: string;\n} {\n  const { account } = useActiveWeb3React();\n\n  const parsedInput: CurrencyAmount | undefined = tryParseAmount(\n    typedValue,\n    stakingToken,\n  );\n\n  const parsedAmount =\n    parsedInput &&\n    userLiquidityUnstaked &&\n    JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw)\n      ? parsedInput\n      : undefined;\n\n  let error: string | undefined;\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n  if (!parsedAmount) {\n    error = error ?? 'Enter an amount';\n  }\n\n  return {\n    parsedAmount,\n    error,\n  };\n}\n\n// based on typed value\nexport function useDerivedStakeInfo(\n  typedValue: string,\n  stakingToken: Token | undefined,\n  userLiquidityUnstaked: TokenAmount | undefined,\n): {\n  parsedAmount?: CurrencyAmount;\n  error?: string;\n} {\n  const { account } = useActiveWeb3React();\n\n  const parsedInput: CurrencyAmount | undefined = tryParseAmount(\n    typedValue,\n    stakingToken,\n  );\n\n  const parsedAmount =\n    parsedInput &&\n    userLiquidityUnstaked &&\n    JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw)\n      ? parsedInput\n      : undefined;\n\n  let error: string | undefined;\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n  if (!parsedAmount) {\n    error = error ?? 'Enter an amount';\n  }\n\n  return {\n    parsedAmount,\n    error,\n  };\n}\n\nexport function useDerivedLairInfo(\n  typedValue: string,\n  stakingToken: Token,\n  userLiquidityUnstaked: TokenAmount | undefined,\n): {\n  parsedAmount?: CurrencyAmount;\n  error?: string;\n} {\n  const { account } = useActiveWeb3React();\n\n  const parsedInput: CurrencyAmount | undefined = tryParseAmount(\n    typedValue,\n    stakingToken,\n  );\n\n  const parsedAmount =\n    parsedInput &&\n    userLiquidityUnstaked &&\n    JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw)\n      ? parsedInput\n      : undefined;\n\n  let error: string | undefined;\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n  if (!parsedAmount) {\n    error = error ?? 'Enter an amount';\n  }\n\n  return {\n    parsedAmount,\n    error,\n  };\n}\n\n// based on typed value\nexport function useDerivedUnstakeInfo(\n  typedValue: string,\n  stakingAmount: TokenAmount,\n): {\n  parsedAmount?: CurrencyAmount;\n  error?: string;\n} {\n  const { account } = useActiveWeb3React();\n\n  const parsedInput: CurrencyAmount | undefined = tryParseAmount(\n    typedValue,\n    stakingAmount.token,\n  );\n\n  const parsedAmount =\n    parsedInput && JSBI.lessThanOrEqual(parsedInput.raw, stakingAmount.raw)\n      ? parsedInput\n      : undefined;\n\n  let error: string | undefined;\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n  if (!parsedAmount) {\n    error = error ?? 'Enter an amount';\n  }\n\n  return {\n    parsedAmount,\n    error,\n  };\n}\n\n// based on typed value\nexport function useDerivedUnstakeLairInfo(\n  typedValue: string,\n  stakingAmount: TokenAmount,\n): {\n  parsedAmount?: CurrencyAmount;\n  error?: string;\n} {\n  const { account } = useActiveWeb3React();\n\n  const parsedInput: CurrencyAmount | undefined = tryParseAmount(\n    typedValue,\n    stakingAmount.token,\n  );\n\n  const parsedAmount =\n    parsedInput && JSBI.lessThanOrEqual(parsedInput.raw, stakingAmount.raw)\n      ? parsedInput\n      : undefined;\n\n  let error: string | undefined;\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n  if (!parsedAmount) {\n    error = error ?? 'Enter an amount';\n  }\n\n  return {\n    parsedAmount,\n    error,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}