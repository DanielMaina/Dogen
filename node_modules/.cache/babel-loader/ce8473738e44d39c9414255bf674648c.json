{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { namehash } from 'ethers/lib/utils';\nimport { useMemo } from 'react';\nimport { useSingleCallResult } from 'state/multicall/hooks';\nimport { isAddress, isZero } from 'utils';\nimport { useENSRegistrarContract, useENSResolverContract } from 'hooks/useContract';\nimport useDebounce from 'hooks/useDebounce';\n/**\n * Does a reverse lookup for an address to find its ENS name.\n * Note this is not the same as looking up an ENS name to find an address.\n */\n\nexport default function useENSName(address) {\n  _s();\n\n  var _resolverAddress$resu, _name$result$, _name$result;\n\n  const debouncedAddress = useDebounce(address, 200);\n  const ensNodeArgument = useMemo(() => {\n    if (!debouncedAddress || !isAddress(debouncedAddress)) return [undefined];\n\n    try {\n      return debouncedAddress ? [namehash(`${debouncedAddress.toLowerCase().substr(2)}.addr.reverse`)] : [undefined];\n    } catch (error) {\n      return [undefined];\n    }\n  }, [debouncedAddress]);\n  const registrarContract = useENSRegistrarContract(false);\n  const resolverAddress = useSingleCallResult(registrarContract, 'resolver', ensNodeArgument);\n  const resolverAddressResult = (_resolverAddress$resu = resolverAddress.result) === null || _resolverAddress$resu === void 0 ? void 0 : _resolverAddress$resu[0];\n  const resolverContract = useENSResolverContract(resolverAddressResult && !isZero(resolverAddressResult) ? resolverAddressResult : undefined, false);\n  const name = useSingleCallResult(resolverContract, 'name', ensNodeArgument);\n  const changed = debouncedAddress !== address;\n  return {\n    ENSName: changed ? null : (_name$result$ = (_name$result = name.result) === null || _name$result === void 0 ? void 0 : _name$result[0]) !== null && _name$result$ !== void 0 ? _name$result$ : null,\n    loading: changed || resolverAddress.loading || name.loading\n  };\n}\n\n_s(useENSName, \"8g3MyTb9JnGx6yiMJXxKZlnslKc=\", false, function () {\n  return [useDebounce, useENSRegistrarContract, useSingleCallResult, useENSResolverContract, useSingleCallResult];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/hooks/useENSName.ts"],"names":["namehash","useMemo","useSingleCallResult","isAddress","isZero","useENSRegistrarContract","useENSResolverContract","useDebounce","useENSName","address","debouncedAddress","ensNodeArgument","undefined","toLowerCase","substr","error","registrarContract","resolverAddress","resolverAddressResult","result","resolverContract","name","changed","ENSName","loading"],"mappings":";;AAAA,SAASA,QAAT,QAAyB,kBAAzB;AACA,SAASC,OAAT,QAAwB,OAAxB;AACA,SAASC,mBAAT,QAAoC,uBAApC;AACA,SAASC,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;AACA,SACEC,uBADF,EAEEC,sBAFF,QAGO,mBAHP;AAIA,OAAOC,WAAP,MAAwB,mBAAxB;AAEA;AACA;AACA;AACA;;AACA,eAAe,SAASC,UAAT,CACbC,OADa,EAEiC;AAAA;;AAAA;;AAC9C,QAAMC,gBAAgB,GAAGH,WAAW,CAACE,OAAD,EAAU,GAAV,CAApC;AACA,QAAME,eAAe,GAAGV,OAAO,CAAC,MAAM;AACpC,QAAI,CAACS,gBAAD,IAAqB,CAACP,SAAS,CAACO,gBAAD,CAAnC,EAAuD,OAAO,CAACE,SAAD,CAAP;;AACvD,QAAI;AACF,aAAOF,gBAAgB,GACnB,CAACV,QAAQ,CAAE,GAAEU,gBAAgB,CAACG,WAAjB,GAA+BC,MAA/B,CAAsC,CAAtC,CAAyC,eAA7C,CAAT,CADmB,GAEnB,CAACF,SAAD,CAFJ;AAGD,KAJD,CAIE,OAAOG,KAAP,EAAc;AACd,aAAO,CAACH,SAAD,CAAP;AACD;AACF,GAT8B,EAS5B,CAACF,gBAAD,CAT4B,CAA/B;AAUA,QAAMM,iBAAiB,GAAGX,uBAAuB,CAAC,KAAD,CAAjD;AACA,QAAMY,eAAe,GAAGf,mBAAmB,CACzCc,iBADyC,EAEzC,UAFyC,EAGzCL,eAHyC,CAA3C;AAKA,QAAMO,qBAAqB,4BAAGD,eAAe,CAACE,MAAnB,0DAAG,sBAAyB,CAAzB,CAA9B;AACA,QAAMC,gBAAgB,GAAGd,sBAAsB,CAC7CY,qBAAqB,IAAI,CAACd,MAAM,CAACc,qBAAD,CAAhC,GACIA,qBADJ,GAEIN,SAHyC,EAI7C,KAJ6C,CAA/C;AAMA,QAAMS,IAAI,GAAGnB,mBAAmB,CAACkB,gBAAD,EAAmB,MAAnB,EAA2BT,eAA3B,CAAhC;AAEA,QAAMW,OAAO,GAAGZ,gBAAgB,KAAKD,OAArC;AACA,SAAO;AACLc,IAAAA,OAAO,EAAED,OAAO,GAAG,IAAH,oCAAUD,IAAI,CAACF,MAAf,iDAAU,aAAc,CAAd,CAAV,yDAA8B,IADzC;AAELK,IAAAA,OAAO,EAAEF,OAAO,IAAIL,eAAe,CAACO,OAA3B,IAAsCH,IAAI,CAACG;AAF/C,GAAP;AAID;;GAlCuBhB,U;UAGGD,W,EAWCF,uB,EACFH,mB,EAMCI,sB,EAMZJ,mB","sourcesContent":["import { namehash } from 'ethers/lib/utils';\nimport { useMemo } from 'react';\nimport { useSingleCallResult } from 'state/multicall/hooks';\nimport { isAddress, isZero } from 'utils';\nimport {\n  useENSRegistrarContract,\n  useENSResolverContract,\n} from 'hooks/useContract';\nimport useDebounce from 'hooks/useDebounce';\n\n/**\n * Does a reverse lookup for an address to find its ENS name.\n * Note this is not the same as looking up an ENS name to find an address.\n */\nexport default function useENSName(\n  address?: string,\n): { ENSName: string | null; loading: boolean } {\n  const debouncedAddress = useDebounce(address, 200);\n  const ensNodeArgument = useMemo(() => {\n    if (!debouncedAddress || !isAddress(debouncedAddress)) return [undefined];\n    try {\n      return debouncedAddress\n        ? [namehash(`${debouncedAddress.toLowerCase().substr(2)}.addr.reverse`)]\n        : [undefined];\n    } catch (error) {\n      return [undefined];\n    }\n  }, [debouncedAddress]);\n  const registrarContract = useENSRegistrarContract(false);\n  const resolverAddress = useSingleCallResult(\n    registrarContract,\n    'resolver',\n    ensNodeArgument,\n  );\n  const resolverAddressResult = resolverAddress.result?.[0];\n  const resolverContract = useENSResolverContract(\n    resolverAddressResult && !isZero(resolverAddressResult)\n      ? resolverAddressResult\n      : undefined,\n    false,\n  );\n  const name = useSingleCallResult(resolverContract, 'name', ensNodeArgument);\n\n  const changed = debouncedAddress !== address;\n  return {\n    ENSName: changed ? null : name.result?.[0] ?? null,\n    loading: changed || resolverAddress.loading || name.loading,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}