{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { Token, CurrencyAmount, ETHER, JSBI, Percent, Price } from '@uniswap/sdk';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { PairState, usePair } from 'data/Reserves';\nimport { useTotalSupply } from 'data/TotalSupply';\nimport { useActiveWeb3React } from 'hooks';\nimport { wrappedCurrency, wrappedCurrencyAmount } from 'utils/wrappedCurrency';\nimport { tryParseAmount } from 'state/swap/hooks';\nimport { useCurrencyBalances } from 'state/wallet/hooks';\nimport { useCurrency } from 'hooks/Tokens';\nimport { Field, typeInput, selectCurrency } from './actions';\nconst ZERO = JSBI.BigInt(0);\nexport function useMintState() {\n  _s();\n\n  return useSelector(state => state.mint);\n}\n\n_s(useMintState, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useDerivedMintInfo() {\n  _s2();\n\n  var _currencyBalances$Fie, _currencyBalances$Fie2;\n\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const {\n    independentField,\n    typedValue,\n    [Field.CURRENCY_A]: {\n      currencyId: currencyAId\n    },\n    [Field.CURRENCY_B]: {\n      currencyId: currencyBId\n    },\n    otherTypedValue\n  } = useMintState();\n  const currencyA = useCurrency(currencyAId);\n  const currencyB = useCurrency(currencyBId);\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A; // tokens\n\n  const currencies = useMemo(() => ({\n    [Field.CURRENCY_A]: currencyA !== null && currencyA !== void 0 ? currencyA : undefined,\n    [Field.CURRENCY_B]: currencyB !== null && currencyB !== void 0 ? currencyB : undefined\n  }), [currencyA, currencyB]); // pair\n\n  const [pairState, pair] = usePair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]);\n  const totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  const noLiquidity = pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO)); // balances\n\n  const balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]]);\n  const currencyBalances = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  }; // amounts\n\n  const independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n  const dependentAmount = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField]);\n      }\n\n      return undefined;\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = wrappedCurrencyAmount(independentAmount, chainId);\n      const [tokenA, tokenB] = [wrappedCurrency(currencyA !== null && currencyA !== void 0 ? currencyA : undefined, chainId), wrappedCurrency(currencyB !== null && currencyB !== void 0 ? currencyB : undefined, chainId)];\n\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n        const dependentTokenAmount = dependentField === Field.CURRENCY_B ? pair.priceOf(tokenA).quote(wrappedIndependentAmount) : pair.priceOf(tokenB).quote(wrappedIndependentAmount);\n        return dependentCurrency === ETHER ? CurrencyAmount.ether(dependentTokenAmount.raw) : dependentTokenAmount;\n      }\n\n      return undefined;\n    } else {\n      return undefined;\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, chainId, currencyB, pair]);\n  const parsedAmounts = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n    };\n  }, [dependentAmount, independentAmount, independentField]);\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const {\n        [Field.CURRENCY_A]: currencyAAmount,\n        [Field.CURRENCY_B]: currencyBAmount\n      } = parsedAmounts;\n\n      if (currencyAAmount && currencyBAmount) {\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, currencyAAmount.raw, currencyBAmount.raw);\n      }\n\n      return undefined;\n    } else {\n      const wrappedCurrencyA = wrappedCurrency(currencyA !== null && currencyA !== void 0 ? currencyA : undefined, chainId);\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n    }\n  }, [chainId, currencyA, noLiquidity, pair, parsedAmounts]); // liquidity minted\n\n  const liquidityMinted = useMemo(() => {\n    const {\n      [Field.CURRENCY_A]: currencyAAmount,\n      [Field.CURRENCY_B]: currencyBAmount\n    } = parsedAmounts;\n    const [tokenAmountA, tokenAmountB] = [wrappedCurrencyAmount(currencyAAmount, chainId), wrappedCurrencyAmount(currencyBAmount, chainId)];\n\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, chainId, pair, totalSupply]);\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw);\n    } else {\n      return undefined;\n    }\n  }, [liquidityMinted, totalSupply]);\n  let error;\n\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n\n  if (pairState === PairState.INVALID) {\n    var _error;\n\n    error = (_error = error) !== null && _error !== void 0 ? _error : 'Invalid pair';\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    var _error2;\n\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 : 'Enter an amount';\n  }\n\n  const {\n    [Field.CURRENCY_A]: currencyAAmount,\n    [Field.CURRENCY_B]: currencyBAmount\n  } = parsedAmounts;\n\n  if (currencyAAmount && currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) !== null && _currencyBalances$Fie !== void 0 && _currencyBalances$Fie.lessThan(currencyAAmount)) {\n    var _currencies$Field$CUR;\n\n    error = 'Insufficient ' + ((_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.symbol) + ' balance';\n  }\n\n  if (currencyBAmount && currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_B]) !== null && _currencyBalances$Fie2 !== void 0 && _currencyBalances$Fie2.lessThan(currencyBAmount)) {\n    var _currencies$Field$CUR2;\n\n    error = 'Insufficient ' + ((_currencies$Field$CUR2 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.symbol) + ' balance';\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error\n  };\n}\n\n_s2(useDerivedMintInfo, \"r06B5ZGqlmZJU+3gX+D6Wn2sQos=\", false, function () {\n  return [useActiveWeb3React, useMintState, useCurrency, useCurrency, usePair, useTotalSupply, useCurrencyBalances];\n});\n\nexport function useMintActionHandlers(noLiquidity) {\n  _s3();\n\n  const dispatch = useDispatch();\n  const onFieldAInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const onFieldBInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const onCurrencySelection = useCallback((field, currency) => {\n    dispatch(selectCurrency({\n      field,\n      currencyId: currency instanceof Token ? currency.address : currency === ETHER ? 'ETH' : ''\n    }));\n  }, [dispatch]);\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onCurrencySelection\n  };\n}\n\n_s3(useMintActionHandlers, \"0zg/yt+F8xRAv9du/gffO8XrfyI=\", false, function () {\n  return [useDispatch];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/state/mint/hooks.ts"],"names":["Token","CurrencyAmount","ETHER","JSBI","Percent","Price","useCallback","useMemo","useDispatch","useSelector","PairState","usePair","useTotalSupply","useActiveWeb3React","wrappedCurrency","wrappedCurrencyAmount","tryParseAmount","useCurrencyBalances","useCurrency","Field","typeInput","selectCurrency","ZERO","BigInt","useMintState","state","mint","useDerivedMintInfo","account","chainId","independentField","typedValue","CURRENCY_A","currencyId","currencyAId","CURRENCY_B","currencyBId","otherTypedValue","currencyA","currencyB","dependentField","currencies","undefined","pairState","pair","totalSupply","liquidityToken","noLiquidity","NOT_EXISTS","Boolean","equal","raw","balances","currencyBalances","independentAmount","dependentAmount","wrappedIndependentAmount","tokenA","tokenB","dependentCurrency","dependentTokenAmount","priceOf","quote","ether","parsedAmounts","price","currencyAAmount","currencyBAmount","currency","wrappedCurrencyA","liquidityMinted","tokenAmountA","tokenAmountB","getLiquidityMinted","poolTokenPercentage","add","error","INVALID","lessThan","symbol","useMintActionHandlers","dispatch","onFieldAInput","field","onFieldBInput","onCurrencySelection","address"],"mappings":"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","sourcesContent":["import {\n  Currency,\n  Token,\n  CurrencyAmount,\n  ETHER,\n  JSBI,\n  Pair,\n  Percent,\n  Price,\n  TokenAmount,\n} from '@uniswap/sdk';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { PairState, usePair } from 'data/Reserves';\nimport { useTotalSupply } from 'data/TotalSupply';\n\nimport { useActiveWeb3React } from 'hooks';\nimport { wrappedCurrency, wrappedCurrencyAmount } from 'utils/wrappedCurrency';\nimport { AppDispatch, AppState } from 'state';\nimport { tryParseAmount } from 'state/swap/hooks';\nimport { useCurrencyBalances } from 'state/wallet/hooks';\nimport { useCurrency } from 'hooks/Tokens';\nimport { Field, typeInput, selectCurrency } from './actions';\n\nconst ZERO = JSBI.BigInt(0);\n\nexport function useMintState(): AppState['mint'] {\n  return useSelector<AppState, AppState['mint']>((state) => state.mint);\n}\n\nexport function useDerivedMintInfo(): {\n  dependentField: Field;\n  currencies: { [field in Field]?: Currency };\n  pair?: Pair | null;\n  pairState: PairState;\n  currencyBalances: { [field in Field]?: CurrencyAmount };\n  parsedAmounts: { [field in Field]?: CurrencyAmount };\n  price?: Price;\n  noLiquidity?: boolean;\n  liquidityMinted?: TokenAmount;\n  poolTokenPercentage?: Percent;\n  error?: string;\n} {\n  const { account, chainId } = useActiveWeb3React();\n\n  const {\n    independentField,\n    typedValue,\n    [Field.CURRENCY_A]: { currencyId: currencyAId },\n    [Field.CURRENCY_B]: { currencyId: currencyBId },\n    otherTypedValue,\n  } = useMintState();\n\n  const currencyA = useCurrency(currencyAId);\n  const currencyB = useCurrency(currencyBId);\n\n  const dependentField =\n    independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A;\n\n  // tokens\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA ?? undefined,\n      [Field.CURRENCY_B]: currencyB ?? undefined,\n    }),\n    [currencyA, currencyB],\n  );\n\n  // pair\n  const [pairState, pair] = usePair(\n    currencies[Field.CURRENCY_A],\n    currencies[Field.CURRENCY_B],\n  );\n  const totalSupply = useTotalSupply(pair?.liquidityToken);\n\n  const noLiquidity: boolean =\n    pairState === PairState.NOT_EXISTS ||\n    Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO));\n\n  // balances\n  const balances = useCurrencyBalances(account ?? undefined, [\n    currencies[Field.CURRENCY_A],\n    currencies[Field.CURRENCY_B],\n  ]);\n  const currencyBalances: { [field in Field]?: CurrencyAmount } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  };\n\n  // amounts\n  const independentAmount: CurrencyAmount | undefined = tryParseAmount(\n    typedValue,\n    currencies[independentField],\n  );\n  const dependentAmount: CurrencyAmount | undefined = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField]);\n      }\n      return undefined;\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = wrappedCurrencyAmount(\n        independentAmount,\n        chainId,\n      );\n      const [tokenA, tokenB] = [\n        wrappedCurrency(currencyA ?? undefined, chainId),\n        wrappedCurrency(currencyB ?? undefined, chainId),\n      ];\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentCurrency =\n          dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n        const dependentTokenAmount =\n          dependentField === Field.CURRENCY_B\n            ? pair.priceOf(tokenA).quote(wrappedIndependentAmount)\n            : pair.priceOf(tokenB).quote(wrappedIndependentAmount);\n        return dependentCurrency === ETHER\n          ? CurrencyAmount.ether(dependentTokenAmount.raw)\n          : dependentTokenAmount;\n      }\n      return undefined;\n    } else {\n      return undefined;\n    }\n  }, [\n    noLiquidity,\n    otherTypedValue,\n    currencies,\n    dependentField,\n    independentAmount,\n    currencyA,\n    chainId,\n    currencyB,\n    pair,\n  ]);\n  const parsedAmounts: {\n    [field in Field]: CurrencyAmount | undefined;\n  } = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]:\n        independentField === Field.CURRENCY_A\n          ? independentAmount\n          : dependentAmount,\n      [Field.CURRENCY_B]:\n        independentField === Field.CURRENCY_A\n          ? dependentAmount\n          : independentAmount,\n    };\n  }, [dependentAmount, independentAmount, independentField]);\n\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const {\n        [Field.CURRENCY_A]: currencyAAmount,\n        [Field.CURRENCY_B]: currencyBAmount,\n      } = parsedAmounts;\n      if (currencyAAmount && currencyBAmount) {\n        return new Price(\n          currencyAAmount.currency,\n          currencyBAmount.currency,\n          currencyAAmount.raw,\n          currencyBAmount.raw,\n        );\n      }\n      return undefined;\n    } else {\n      const wrappedCurrencyA = wrappedCurrency(currencyA ?? undefined, chainId);\n      return pair && wrappedCurrencyA\n        ? pair.priceOf(wrappedCurrencyA)\n        : undefined;\n    }\n  }, [chainId, currencyA, noLiquidity, pair, parsedAmounts]);\n\n  // liquidity minted\n  const liquidityMinted = useMemo(() => {\n    const {\n      [Field.CURRENCY_A]: currencyAAmount,\n      [Field.CURRENCY_B]: currencyBAmount,\n    } = parsedAmounts;\n    const [tokenAmountA, tokenAmountB] = [\n      wrappedCurrencyAmount(currencyAAmount, chainId),\n      wrappedCurrencyAmount(currencyBAmount, chainId),\n    ];\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, chainId, pair, totalSupply]);\n\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(\n        liquidityMinted.raw,\n        totalSupply.add(liquidityMinted).raw,\n      );\n    } else {\n      return undefined;\n    }\n  }, [liquidityMinted, totalSupply]);\n\n  let error: string | undefined;\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n\n  if (pairState === PairState.INVALID) {\n    error = error ?? 'Invalid pair';\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    error = error ?? 'Enter an amount';\n  }\n\n  const {\n    [Field.CURRENCY_A]: currencyAAmount,\n    [Field.CURRENCY_B]: currencyBAmount,\n  } = parsedAmounts;\n\n  if (\n    currencyAAmount &&\n    currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)\n  ) {\n    error = 'Insufficient ' + currencies[Field.CURRENCY_A]?.symbol + ' balance';\n  }\n\n  if (\n    currencyBAmount &&\n    currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)\n  ) {\n    error = 'Insufficient ' + currencies[Field.CURRENCY_B]?.symbol + ' balance';\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error,\n  };\n}\n\nexport function useMintActionHandlers(\n  noLiquidity: boolean | undefined,\n): {\n  onFieldAInput: (typedValue: string) => void;\n  onFieldBInput: (typedValue: string) => void;\n  onCurrencySelection: (field: Field, currency: Currency) => void;\n} {\n  const dispatch = useDispatch<AppDispatch>();\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(\n        typeInput({\n          field: Field.CURRENCY_A,\n          typedValue,\n          noLiquidity: noLiquidity === true,\n        }),\n      );\n    },\n    [dispatch, noLiquidity],\n  );\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(\n        typeInput({\n          field: Field.CURRENCY_B,\n          typedValue,\n          noLiquidity: noLiquidity === true,\n        }),\n      );\n    },\n    [dispatch, noLiquidity],\n  );\n\n  const onCurrencySelection = useCallback(\n    (field: Field, currency: Currency) => {\n      dispatch(\n        selectCurrency({\n          field,\n          currencyId:\n            currency instanceof Token\n              ? currency.address\n              : currency === ETHER\n              ? 'ETH'\n              : '',\n        }),\n      );\n    },\n    [dispatch],\n  );\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onCurrencySelection,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}