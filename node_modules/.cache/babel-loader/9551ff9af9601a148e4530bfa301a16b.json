{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IntDataType = void 0;\n\nconst ethereum_types_1 = require(\"ethereum-types\");\n\nconst configured_bignumber_1 = require(\"../../configured_bignumber\");\n\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\n\nconst constants_1 = require(\"../utils/constants\");\n\nconst EncoderMath = require(\"../utils/math\"); // tslint:disable:custom-no-magic-numbers\n\n\nclass IntDataType extends blob_1.AbstractBlobDataType {\n  constructor(dataItem, dataTypeFactory) {\n    super(dataItem, dataTypeFactory, IntDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n\n    if (!IntDataType.matchType(dataItem.type)) {\n      throw new Error(`Tried to instantiate Int with bad input: ${dataItem}`);\n    }\n\n    this._width = IntDataType._decodeWidthFromType(dataItem.type);\n    this._minValue = IntDataType._WIDTH_TO_MIN_VALUE[this._width];\n    this._maxValue = IntDataType._WIDTH_TO_MAX_VALUE[this._width];\n  }\n\n  static matchType(type) {\n    return IntDataType._MATCHER.test(type);\n  }\n\n  static _decodeWidthFromType(type) {\n    const matches = IntDataType._MATCHER.exec(type);\n\n    const width = matches !== null && matches.length === 2 && matches[1] !== undefined ? parseInt(matches[1], constants_1.constants.DEC_BASE) : IntDataType._DEFAULT_WIDTH;\n    return width;\n  }\n\n  encodeValue(value) {\n    const encodedValue = EncoderMath.safeEncodeNumericValue(value, this._minValue, this._maxValue);\n    return encodedValue;\n  }\n\n  decodeValue(calldata) {\n    const valueBuf = calldata.popWord();\n    const value = EncoderMath.safeDecodeNumericValue(valueBuf, this._minValue, this._maxValue);\n\n    if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_INT8) {\n      return value.toNumber();\n    }\n\n    return value;\n  }\n\n  getDefaultValue() {\n    const defaultValue = IntDataType._DEFAULT_VALUE;\n\n    if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_INT8) {\n      return defaultValue.toNumber();\n    }\n\n    return defaultValue;\n  }\n\n  getSignatureType() {\n    return `${ethereum_types_1.SolidityTypes.Int}${this._width}`;\n  }\n\n}\n\nexports.IntDataType = IntDataType;\nIntDataType._MATCHER = RegExp('^int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256){0,1}$');\nIntDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\nIntDataType._MAX_WIDTH = 256;\nIntDataType._DEFAULT_WIDTH = IntDataType._MAX_WIDTH;\nIntDataType._DEFAULT_VALUE = new configured_bignumber_1.BigNumber(0);\nIntDataType._WIDTH_TO_MIN_VALUE = Object.assign({}, ...[...new Array(32)].map((_x, i) => {\n  const width = (i + 1) * 8;\n  return {\n    [width]: new configured_bignumber_1.BigNumber(2).exponentiatedBy(width - 1).times(-1)\n  };\n}));\nIntDataType._WIDTH_TO_MAX_VALUE = Object.assign({}, ...[...new Array(32)].map((_x, i) => {\n  const width = (i + 1) * 8;\n  return {\n    [width]: new configured_bignumber_1.BigNumber(2).exponentiatedBy(width - 1).minus(1)\n  };\n}));","map":{"version":3,"sources":["../../../../src/abi_encoder/evm_data_types/int.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IntDataType = void 0;\nconst ethereum_types_1 = require(\"ethereum-types\");\nconst configured_bignumber_1 = require(\"../../configured_bignumber\");\nconst blob_1 = require(\"../abstract_data_types/types/blob\");\nconst constants_1 = require(\"../utils/constants\");\nconst EncoderMath = require(\"../utils/math\");\n// tslint:disable:custom-no-magic-numbers\nclass IntDataType extends blob_1.AbstractBlobDataType {\n    constructor(dataItem, dataTypeFactory) {\n        super(dataItem, dataTypeFactory, IntDataType._SIZE_KNOWN_AT_COMPILE_TIME);\n        if (!IntDataType.matchType(dataItem.type)) {\n            throw new Error(`Tried to instantiate Int with bad input: ${dataItem}`);\n        }\n        this._width = IntDataType._decodeWidthFromType(dataItem.type);\n        this._minValue = IntDataType._WIDTH_TO_MIN_VALUE[this._width];\n        this._maxValue = IntDataType._WIDTH_TO_MAX_VALUE[this._width];\n    }\n    static matchType(type) {\n        return IntDataType._MATCHER.test(type);\n    }\n    static _decodeWidthFromType(type) {\n        const matches = IntDataType._MATCHER.exec(type);\n        const width = matches !== null && matches.length === 2 && matches[1] !== undefined\n            ? parseInt(matches[1], constants_1.constants.DEC_BASE)\n            : IntDataType._DEFAULT_WIDTH;\n        return width;\n    }\n    encodeValue(value) {\n        const encodedValue = EncoderMath.safeEncodeNumericValue(value, this._minValue, this._maxValue);\n        return encodedValue;\n    }\n    decodeValue(calldata) {\n        const valueBuf = calldata.popWord();\n        const value = EncoderMath.safeDecodeNumericValue(valueBuf, this._minValue, this._maxValue);\n        if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_INT8) {\n            return value.toNumber();\n        }\n        return value;\n    }\n    getDefaultValue() {\n        const defaultValue = IntDataType._DEFAULT_VALUE;\n        if (this._width === constants_1.constants.NUMBER_OF_BYTES_IN_INT8) {\n            return defaultValue.toNumber();\n        }\n        return defaultValue;\n    }\n    getSignatureType() {\n        return `${ethereum_types_1.SolidityTypes.Int}${this._width}`;\n    }\n}\nexports.IntDataType = IntDataType;\nIntDataType._MATCHER = RegExp('^int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256){0,1}$');\nIntDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\nIntDataType._MAX_WIDTH = 256;\nIntDataType._DEFAULT_WIDTH = IntDataType._MAX_WIDTH;\nIntDataType._DEFAULT_VALUE = new configured_bignumber_1.BigNumber(0);\nIntDataType._WIDTH_TO_MIN_VALUE = Object.assign({}, ...[...new Array(32)].map((_x, i) => {\n    const width = (i + 1) * 8;\n    return { [width]: new configured_bignumber_1.BigNumber(2).exponentiatedBy(width - 1).times(-1) };\n}));\nIntDataType._WIDTH_TO_MAX_VALUE = Object.assign({}, ...[...new Array(32)].map((_x, i) => {\n    const width = (i + 1) * 8;\n    return { [width]: new configured_bignumber_1.BigNumber(2).exponentiatedBy(width - 1).minus(1) };\n}));\n//# sourceMappingURL=int.js.map"]},"metadata":{},"sourceType":"script"}