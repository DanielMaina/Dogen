{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Web3Wrapper = void 0;\n\nconst assert_1 = require(\"@0x/assert\");\n\nconst json_schemas_1 = require(\"@0x/json-schemas\");\n\nconst utils_1 = require(\"@0x/utils\");\n\nconst ethereum_types_1 = require(\"ethereum-types\");\n\nconst _ = require(\"lodash\");\n\nconst marshaller_1 = require(\"./marshaller\");\n\nconst types_1 = require(\"./types\");\n\nconst utils_2 = require(\"./utils\");\n\nconst BASE_TEN = 10; // These are unique identifiers contained in the response of the\n// web3_clientVersion call.\n\nconst uniqueVersionIds = {\n  geth: 'Geth',\n  ganache: 'EthereumJS TestRPC'\n};\n/**\n * An alternative to the Web3.js library that provides a consistent, clean, promise-based interface.\n */\n\nclass Web3Wrapper {\n  /**\n   * Instantiates a new Web3Wrapper.\n   * @param   provider    The Web3 provider instance you would like the Web3Wrapper to use for interacting with\n   *                      the backing Ethereum node.\n   * @param   callAndTxnDefaults  Override Call and Txn Data defaults sent with RPC requests to the backing Ethereum node.\n   * @return  An instance of the Web3Wrapper class.\n   */\n  constructor(supportedProvider) {\n    let callAndTxnDefaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * Flag to check if this instance is of type Web3Wrapper\n     */\n    this.isZeroExWeb3Wrapper = true;\n    this.abiDecoder = new utils_1.AbiDecoder([]);\n    this._supportedProvider = supportedProvider;\n    this._provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._callAndTxnDefaults = callAndTxnDefaults;\n    this._jsonRpcRequestId = 1;\n  }\n  /**\n   * Check if an address is a valid Ethereum address\n   * @param address Address to check\n   * @returns Whether the address is a valid Ethereum address\n   */\n\n\n  static isAddress(address) {\n    return utils_1.addressUtils.isAddress(address);\n  }\n  /**\n   * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n   * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n   * to 1 unit.\n   * @param   amount      The amount in baseUnits that you would like converted to units.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in units.\n   */\n\n\n  static toUnitAmount(amount, decimals) {\n    assert_1.assert.isValidBaseUnitAmount('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    const aUnit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    const unit = amount.div(aUnit);\n    return unit;\n  }\n  /**\n   * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n   * is the amount expressed in the smallest denomination.\n   * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n   * @param   amount      The amount of units that you would like converted to baseUnits.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in baseUnits.\n   */\n\n\n  static toBaseUnitAmount(amount, decimals) {\n    assert_1.assert.isNumber('decimals', decimals);\n    const unit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    const baseUnitAmount = unit.times(amount);\n    const hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n\n    if (hasDecimals) {\n      throw new Error(`Invalid unit amount: ${amount.toString(BASE_TEN)} - Too many decimal places`);\n    }\n\n    return baseUnitAmount;\n  }\n  /**\n   * Convert an Ether amount from ETH to Wei\n   * @param ethAmount Amount of Ether to convert to wei\n   * @returns Amount in wei\n   */\n\n\n  static toWei(ethAmount) {\n    assert_1.assert.isBigNumber('ethAmount', ethAmount);\n    const ETH_DECIMALS = 18;\n    const balanceWei = Web3Wrapper.toBaseUnitAmount(ethAmount, ETH_DECIMALS);\n    return balanceWei;\n  }\n\n  static _assertBlockParam(blockParam) {\n    if (_.isNumber(blockParam)) {\n      return;\n    } else if (_.isString(blockParam)) {\n      assert_1.assert.doesBelongToStringEnum('blockParam', blockParam, ethereum_types_1.BlockParamLiteral);\n    }\n  }\n\n  static _assertBlockParamOrString(blockParam) {\n    try {\n      Web3Wrapper._assertBlockParam(blockParam);\n    } catch (err) {\n      try {\n        assert_1.assert.isHexString('blockParam', blockParam);\n        return;\n      } catch (err) {\n        throw new Error(`Expected blockParam to be of type \"string | BlockParam\", encountered ${blockParam}`);\n      }\n    }\n  }\n\n  static _normalizeTxReceiptStatus(status) {\n    // Transaction status might have four values\n    // undefined - Testrpc and other old clients\n    // null - New clients on old transactions\n    // number - Parity\n    // hex - Geth\n    if (_.isString(status)) {\n      return utils_2.utils.convertHexToNumber(status);\n    } else if (status === undefined) {\n      return null;\n    } else {\n      return status;\n    }\n  }\n  /**\n   * Get the contract defaults set to the Web3Wrapper instance\n   * @return  CallAndTxnData defaults (e.g gas, gasPrice, nonce, etc...)\n   */\n\n\n  getContractDefaults() {\n    return this._callAndTxnDefaults;\n  }\n  /**\n   * Retrieve the Web3 provider\n   * @return  Web3 provider instance\n   */\n\n\n  getProvider() {\n    return this._supportedProvider;\n  }\n  /**\n   * Update the used Web3 provider\n   * @param provider The new Web3 provider to be set\n   */\n\n\n  setProvider(supportedProvider) {\n    const provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._provider = provider;\n  }\n  /**\n   * Check whether an address is available through the backing provider. This can be\n   * useful if you want to know whether a user can sign messages or transactions from\n   * a given Ethereum address.\n   * @param senderAddress Address to check availability for\n   * @returns Whether the address is available through the provider.\n   */\n\n\n  isSenderAddressAvailableAsync(senderAddress) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isETHAddressHex('senderAddress', senderAddress);\n      const addresses = yield this.getAvailableAddressesAsync();\n      const normalizedAddress = senderAddress.toLowerCase();\n      return _.includes(addresses, normalizedAddress);\n    });\n  }\n  /**\n   * Fetch the backing Ethereum node's version string (e.g `MetaMask/v4.2.0`)\n   * @returns Ethereum node's version string\n   */\n\n\n  getNodeVersionAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const nodeVersion = yield this.sendRawPayloadAsync({\n        method: 'web3_clientVersion'\n      });\n      return nodeVersion;\n    });\n  }\n  /**\n   * Fetches the networkId of the backing Ethereum node\n   * @returns The network id\n   */\n\n\n  getNetworkIdAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const networkIdStr = yield this.sendRawPayloadAsync({\n        method: 'net_version'\n      });\n\n      const networkId = _.parseInt(networkIdStr);\n\n      return networkId;\n    });\n  }\n  /**\n   * Fetches the chainId of the backing Ethereum node\n   * @returns The chain id\n   */\n\n\n  getChainIdAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainIdStr = yield this.sendRawPayloadAsync({\n        method: 'eth_chainId'\n      });\n\n      const chainId = _.parseInt(chainIdStr);\n\n      return chainId;\n    });\n  }\n  /**\n   * Fetch the current gas price.\n   * For post-London hardfork chains, this will be baseFeePerGas + maxPriorityFeePerGas\n   */\n\n\n  getGasPriceAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const gasPriceStr = yield this.sendRawPayloadAsync({\n        method: 'eth_gasPrice'\n      });\n      return new utils_1.BigNumber(gasPriceStr);\n    });\n  }\n  /**\n   * Fetch the base fee per gas for the pending block.\n   */\n\n\n  getBaseFeePerGasAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const rawBlock = yield this.sendRawPayloadAsync({\n        method: 'eth_getBlockByNumber',\n        params: ['pending', false]\n      });\n      const {\n        baseFeePerGas\n      } = rawBlock;\n      return new utils_1.BigNumber(baseFeePerGas || 0);\n    });\n  }\n  /**\n   * Fetch the current max piority fee per gas. This is the suggested miner tip\n   * to get mined in the current block.\n   */\n\n\n  getMaxPriorityFeePerGasAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const feeStr = yield this.sendRawPayloadAsync({\n        method: 'eth_maxPriorityFeePerGas'\n      });\n      return new utils_1.BigNumber(feeStr);\n    });\n  }\n  /**\n   * Retrieves the transaction receipt for a given transaction hash if found\n   * @param txHash Transaction hash\n   * @returns The transaction receipt, including it's status (0: failed, 1: succeeded). Returns undefined if transaction not found.\n   */\n\n\n  getTransactionReceiptIfExistsAsync(txHash) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isHexString('txHash', txHash);\n      const transactionReceiptRpc = yield this.sendRawPayloadAsync({\n        method: 'eth_getTransactionReceipt',\n        params: [txHash]\n      }); // HACK Parity can return a pending transaction receipt. We check for a non null\n      // block number before continuing with returning a fully realised receipt.\n      // ref: https://github.com/paritytech/parity-ethereum/issues/1180\n\n      if (transactionReceiptRpc !== null && transactionReceiptRpc.blockNumber !== null) {\n        transactionReceiptRpc.status = Web3Wrapper._normalizeTxReceiptStatus(transactionReceiptRpc.status);\n        const transactionReceipt = marshaller_1.marshaller.unmarshalTransactionReceipt(transactionReceiptRpc);\n        return transactionReceipt;\n      } else {\n        return undefined;\n      }\n    });\n  }\n  /**\n   * Retrieves the transaction data for a given transaction\n   * @param txHash Transaction hash\n   * @returns The raw transaction data\n   */\n\n\n  getTransactionByHashAsync(txHash) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isHexString('txHash', txHash);\n      const transactionRpc = yield this.sendRawPayloadAsync({\n        method: 'eth_getTransactionByHash',\n        params: [txHash]\n      });\n      const transaction = marshaller_1.marshaller.unmarshalTransaction(transactionRpc);\n      return transaction;\n    });\n  }\n  /**\n   * Retrieves an accounts Ether balance in wei\n   * @param owner Account whose balance you wish to check\n   * @param defaultBlock The block depth at which to fetch the balance (default=latest)\n   * @returns Balance in wei\n   */\n\n\n  getBalanceInWeiAsync(owner, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isETHAddressHex('owner', owner);\n\n      if (defaultBlock !== undefined) {\n        Web3Wrapper._assertBlockParam(defaultBlock);\n      }\n\n      const marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n      const encodedOwner = marshaller_1.marshaller.marshalAddress(owner);\n      const balanceInWei = yield this.sendRawPayloadAsync({\n        method: 'eth_getBalance',\n        params: [encodedOwner, marshalledDefaultBlock]\n      }); // Rewrap in a new BigNumber\n\n      return new utils_1.BigNumber(balanceInWei);\n    });\n  }\n  /**\n   * Check if a contract exists at a given address\n   * @param address Address to which to check\n   * @returns Whether or not contract code was found at the supplied address\n   */\n\n\n  doesContractExistAtAddressAsync(address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isETHAddressHex('address', address);\n      const code = yield this.getContractCodeAsync(address); // Regex matches 0x0, 0x00, 0x in order to accommodate poorly implemented clients\n\n      const isCodeEmpty = /^0x0{0,40}$/i.test(code);\n      return !isCodeEmpty;\n    });\n  }\n  /**\n   * Gets the contract code by address\n   * @param  address Address of the contract\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @return Code of the contract\n   */\n\n\n  getContractCodeAsync(address, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isETHAddressHex('address', address);\n\n      if (defaultBlock !== undefined) {\n        Web3Wrapper._assertBlockParam(defaultBlock);\n      }\n\n      const marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n      const encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n      const code = yield this.sendRawPayloadAsync({\n        method: 'eth_getCode',\n        params: [encodedAddress, marshalledDefaultBlock]\n      });\n      return code;\n    });\n  }\n  /**\n   * Gets the debug trace of a transaction\n   * @param  txHash Hash of the transactuon to get a trace for\n   * @param  traceParams Config object allowing you to specify if you need memory/storage/stack traces.\n   * @return Transaction trace\n   */\n\n\n  getTransactionTraceAsync(txHash, traceParams) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isHexString('txHash', txHash);\n      const trace = yield this.sendRawPayloadAsync({\n        method: 'debug_traceTransaction',\n        params: [txHash, traceParams]\n      });\n      return trace;\n    });\n  }\n  /**\n   * Sign a message with a specific address's private key (`eth_sign`)\n   * @param address Address of signer\n   * @param message Message to sign\n   * @returns Signature string (might be VRS or RSV depending on the Signer)\n   */\n\n\n  signMessageAsync(address, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isETHAddressHex('address', address);\n      assert_1.assert.isString('message', message); // TODO: Should this be stricter? Hex string?\n\n      const signData = yield this.sendRawPayloadAsync({\n        method: 'eth_sign',\n        params: [address, message]\n      });\n      return signData;\n    });\n  }\n  /**\n   * Sign an EIP712 typed data message with a specific address's private key (`eth_signTypedData`)\n   * @param address Address of signer\n   * @param typedData Typed data message to sign\n   * @returns Signature string (as RSV)\n   */\n\n\n  signTypedDataAsync(address, typedData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isETHAddressHex('address', address);\n      assert_1.assert.doesConformToSchema('typedData', typedData, json_schemas_1.schemas.eip712TypedDataSchema); // Try decreasing versions of `eth_signTypedData` until it works.\n\n      const methodsToTry = ['eth_signTypedData_v4', 'eth_signTypedData_v3', 'eth_signTypedData'];\n      let lastErr;\n\n      for (const method of methodsToTry) {\n        try {\n          return yield this.sendRawPayloadAsync({\n            method,\n            // `eth_signTypedData` expects an object, whereas the others expect\n            // a JSON string.\n            params: [address, method === 'eth_signTypedData' ? typedData : JSON.stringify(typedData)]\n          });\n        } catch (err) {\n          lastErr = err; // If there are no more methods to try or the error says something other\n          // than the method not existing, throw.\n\n          if (!/(not handled|does not exist|not supported)/.test(err.message)) {\n            throw err;\n          }\n        }\n      }\n\n      throw lastErr;\n    });\n  }\n  /**\n   * Fetches the latest block number\n   * @returns Block number\n   */\n\n\n  getBlockNumberAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const blockNumberHex = yield this.sendRawPayloadAsync({\n        method: 'eth_blockNumber',\n        params: []\n      });\n      const blockNumber = utils_2.utils.convertHexToNumberOrNull(blockNumberHex);\n      return blockNumber;\n    });\n  }\n  /**\n   * Fetches the nonce for an account (transaction count for EOAs).\n   * @param address Address of account.\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @returns Account nonce.\n   */\n\n\n  getAccountNonceAsync(address, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isETHAddressHex('address', address);\n\n      if (defaultBlock !== undefined) {\n        Web3Wrapper._assertBlockParam(defaultBlock);\n      }\n\n      const marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n      const encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n      const nonceHex = yield this.sendRawPayloadAsync({\n        method: 'eth_getTransactionCount',\n        params: [encodedAddress, marshalledDefaultBlock]\n      });\n      assert_1.assert.isHexString('nonce', nonceHex); // tslint:disable-next-line:custom-no-magic-numbers\n\n      return parseInt(nonceHex.substr(2), 16);\n    });\n  }\n  /**\n   * Fetch a specific Ethereum block without transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block without transaction data, or undefined if block was not found\n   * (e.g the node isn't fully synced, there was a block re-org and the requested block was uncles, etc...)\n   */\n\n\n  getBlockIfExistsAsync(blockParam) {\n    return __awaiter(this, void 0, void 0, function* () {\n      Web3Wrapper._assertBlockParamOrString(blockParam);\n\n      const encodedBlockParam = marshaller_1.marshaller.marshalBlockParam(blockParam);\n      const method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n      const shouldIncludeTransactionData = false;\n      const blockWithoutTransactionDataWithHexValuesOrNull = yield this.sendRawPayloadAsync({\n        method,\n        params: [encodedBlockParam, shouldIncludeTransactionData]\n      });\n      let blockWithoutTransactionDataIfExists;\n\n      if (blockWithoutTransactionDataWithHexValuesOrNull !== null) {\n        blockWithoutTransactionDataIfExists = marshaller_1.marshaller.unmarshalIntoBlockWithoutTransactionData(blockWithoutTransactionDataWithHexValuesOrNull);\n      }\n\n      return blockWithoutTransactionDataIfExists;\n    });\n  }\n  /**\n   * Fetch a specific Ethereum block with transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block with transaction data\n   */\n\n\n  getBlockWithTransactionDataAsync(blockParam) {\n    return __awaiter(this, void 0, void 0, function* () {\n      Web3Wrapper._assertBlockParamOrString(blockParam);\n\n      let encodedBlockParam = blockParam;\n\n      if (_.isNumber(blockParam)) {\n        encodedBlockParam = utils_2.utils.numberToHex(blockParam);\n      }\n\n      const method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n      const shouldIncludeTransactionData = true;\n      const blockWithTransactionDataWithHexValues = yield this.sendRawPayloadAsync({\n        method,\n        params: [encodedBlockParam, shouldIncludeTransactionData]\n      });\n      const blockWithoutTransactionData = marshaller_1.marshaller.unmarshalIntoBlockWithTransactionData(blockWithTransactionDataWithHexValues);\n      return blockWithoutTransactionData;\n    });\n  }\n  /**\n   * Fetch a block's timestamp\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The block's timestamp\n   */\n\n\n  getBlockTimestampAsync(blockParam) {\n    return __awaiter(this, void 0, void 0, function* () {\n      Web3Wrapper._assertBlockParamOrString(blockParam);\n\n      const blockIfExists = yield this.getBlockIfExistsAsync(blockParam);\n\n      if (blockIfExists === undefined) {\n        throw new Error(`Failed to fetch block with blockParam: ${JSON.stringify(blockParam)}`);\n      }\n\n      return blockIfExists.timestamp;\n    });\n  }\n  /**\n   * Retrieve the user addresses available through the backing provider\n   * @returns Available user addresses\n   */\n\n\n  getAvailableAddressesAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const addresses = yield this.sendRawPayloadAsync({\n        method: 'eth_accounts',\n        params: []\n      });\n\n      const normalizedAddresses = _.map(addresses, address => address.toLowerCase());\n\n      return normalizedAddresses;\n    });\n  }\n  /**\n   * Take a snapshot of the blockchain state on a TestRPC/Ganache local node\n   * @returns The snapshot id. This can be used to revert to this snapshot\n   */\n\n\n  takeSnapshotAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const snapshotId = Number(yield this.sendRawPayloadAsync({\n        method: 'evm_snapshot',\n        params: []\n      }));\n      return snapshotId;\n    });\n  }\n  /**\n   * Revert the blockchain state to a previous snapshot state on TestRPC/Ganache local node\n   * @param snapshotId snapshot id to revert to\n   * @returns Whether the revert was successful\n   */\n\n\n  revertSnapshotAsync(snapshotId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isNumber('snapshotId', snapshotId);\n      const didRevert = yield this.sendRawPayloadAsync({\n        method: 'evm_revert',\n        params: [snapshotId]\n      });\n      return didRevert;\n    });\n  }\n  /**\n   * Mine a block on a TestRPC/Ganache local node\n   */\n\n\n  mineBlockAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.sendRawPayloadAsync({\n        method: 'evm_mine',\n        params: []\n      });\n    });\n  }\n  /**\n   * Increase the next blocks timestamp on TestRPC/Ganache or Geth local node.\n   * Will throw if provider is neither TestRPC/Ganache or Geth.\n   * @param timeDelta Amount of time to add in seconds\n   */\n\n\n  increaseTimeAsync(timeDelta) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isNumber('timeDelta', timeDelta); // Detect Geth vs. Ganache and use appropriate endpoint.\n\n      const version = yield this.getNodeVersionAsync();\n\n      if (_.includes(version, uniqueVersionIds.geth)) {\n        return this.sendRawPayloadAsync({\n          method: 'debug_increaseTime',\n          params: [timeDelta]\n        });\n      } else if (_.includes(version, uniqueVersionIds.ganache)) {\n        return this.sendRawPayloadAsync({\n          method: 'evm_increaseTime',\n          params: [timeDelta]\n        });\n      } else {\n        throw new Error(`Unknown client version: ${version}`);\n      }\n    });\n  }\n  /**\n   * Retrieve smart contract logs for a given filter\n   * @param filter Parameters by which to filter which logs to retrieve\n   * @returns The corresponding log entries\n   */\n\n\n  getLogsAsync(filter) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (filter.blockHash !== undefined && (filter.fromBlock !== undefined || filter.toBlock !== undefined)) {\n        throw new Error(`Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'`);\n      }\n\n      let fromBlock = filter.fromBlock;\n\n      if (_.isNumber(fromBlock)) {\n        fromBlock = utils_2.utils.numberToHex(fromBlock);\n      }\n\n      let toBlock = filter.toBlock;\n\n      if (_.isNumber(toBlock)) {\n        toBlock = utils_2.utils.numberToHex(toBlock);\n      }\n\n      const serializedFilter = Object.assign(Object.assign({}, filter), {\n        fromBlock,\n        toBlock\n      });\n      const payload = {\n        method: 'eth_getLogs',\n        params: [serializedFilter]\n      };\n      const rawLogs = yield this.sendRawPayloadAsync(payload);\n\n      const formattedLogs = _.map(rawLogs, marshaller_1.marshaller.unmarshalLog.bind(marshaller_1.marshaller));\n\n      return formattedLogs;\n    });\n  }\n  /**\n   * Calculate the estimated gas cost for a given transaction\n   * @param txData Transaction data\n   * @returns Estimated gas cost\n   */\n\n\n  estimateGasAsync(txData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema);\n      const txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n      const gasHex = yield this.sendRawPayloadAsync({\n        method: 'eth_estimateGas',\n        params: [txDataHex]\n      });\n      const gas = utils_2.utils.convertHexToNumber(gasHex);\n      return gas;\n    });\n  }\n  /**\n   * Generate an access list for an ethereum call and also compute the gas used.\n   * @param callData Call data\n   * @param defaultBlock Block height at which to make the call. Defaults to 'latest'.\n   * @returns The access list and gas used.\n   */\n\n\n  createAccessListAsync(callData, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n      const rawResult = yield this.sendRawPayloadAsync({\n        method: 'eth_createAccessList',\n        params: [marshaller_1.marshaller.marshalCallData(callData), marshaller_1.marshaller.marshalBlockParam(defaultBlock)]\n      });\n\n      if (rawResult.error) {\n        throw new Error(rawResult.error);\n      }\n\n      return {\n        accessList: rawResult.accessList.reduce((o, v) => {\n          o[v.address] = o[v.address] || [];\n          o[v.address].push(...(v.storageKeys || []));\n          return o;\n        }, // tslint:disable-next-line: no-object-literal-type-assertion\n        {}),\n        // tslint:disable-next-line: custom-no-magic-numbers\n        gasUsed: parseInt(rawResult.gasUsed.slice(2), 16)\n      };\n    });\n  }\n  /**\n   * Call a smart contract method at a given block height\n   * @param callData Call data\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @returns The raw call result\n   */\n\n\n  callAsync(callData, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema);\n\n      if (defaultBlock !== undefined) {\n        Web3Wrapper._assertBlockParam(defaultBlock);\n      }\n\n      const marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n      const callDataHex = marshaller_1.marshaller.marshalCallData(callData);\n      const overrides = marshaller_1.marshaller.marshalCallOverrides(callData.overrides || {});\n      const rawCallResult = yield this.sendRawPayloadAsync({\n        method: 'eth_call',\n        params: [callDataHex, marshalledDefaultBlock, ...(Object.keys(overrides).length === 0 ? [] : [overrides])]\n      });\n      return rawCallResult;\n    });\n  }\n  /**\n   * Send a transaction\n   * @param txData Transaction data\n   * @returns Transaction hash\n   */\n\n\n  sendTransactionAsync(txData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema);\n      const txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n      const txHash = yield this.sendRawPayloadAsync({\n        method: 'eth_sendTransaction',\n        params: [txDataHex]\n      });\n      return txHash;\n    });\n  }\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Note that just because a transaction was mined does not mean it was\n   * successful. You need to check the status code of the transaction receipt\n   * to find out if it was successful, or use the helper method\n   * awaitTransactionSuccessAsync.\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n\n\n  awaitTransactionMinedAsync(txHash) {\n    let pollingIntervalMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    let timeoutMs = arguments.length > 2 ? arguments[2] : undefined;\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isHexString('txHash', txHash);\n      assert_1.assert.isNumber('pollingIntervalMs', pollingIntervalMs);\n\n      if (timeoutMs !== undefined) {\n        assert_1.assert.isNumber('timeoutMs', timeoutMs);\n      } // Immediately check if the transaction has already been mined.\n\n\n      let transactionReceipt = yield this.getTransactionReceiptIfExistsAsync(txHash);\n\n      if (transactionReceipt !== undefined) {\n        const logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n\n        const transactionReceiptWithDecodedLogArgs = Object.assign(Object.assign({}, transactionReceipt), {\n          logs: logsWithDecodedArgs\n        });\n        return transactionReceiptWithDecodedLogArgs;\n      } // Otherwise, check again every pollingIntervalMs.\n\n\n      let wasTimeoutExceeded = false;\n\n      if (timeoutMs) {\n        setTimeout(() => wasTimeoutExceeded = true, timeoutMs);\n      }\n\n      const txReceiptPromise = new Promise((resolve, reject) => {\n        const intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(() => __awaiter(this, void 0, void 0, function* () {\n          if (wasTimeoutExceeded) {\n            utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n            return reject(types_1.Web3WrapperErrors.TransactionMiningTimeout);\n          }\n\n          transactionReceipt = yield this.getTransactionReceiptIfExistsAsync(txHash);\n\n          if (transactionReceipt !== undefined) {\n            utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n\n            const logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n\n            const transactionReceiptWithDecodedLogArgs = Object.assign(Object.assign({}, transactionReceipt), {\n              logs: logsWithDecodedArgs\n            });\n            resolve(transactionReceiptWithDecodedLogArgs);\n          }\n        }), pollingIntervalMs, err => {\n          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n          reject(err);\n        });\n      });\n      const txReceipt = yield txReceiptPromise;\n      return txReceipt;\n    });\n  }\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Unlike awaitTransactionMinedAsync, it will throw if the receipt has a\n   * status that is not equal to 1. A status of 0 or null indicates that the\n   * transaction was mined, but failed. See:\n   * https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n\n\n  awaitTransactionSuccessAsync(txHash) {\n    let pollingIntervalMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    let timeoutMs = arguments.length > 2 ? arguments[2] : undefined;\n    return __awaiter(this, void 0, void 0, function* () {\n      const receipt = yield this.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs);\n\n      if (receipt.status !== 1) {\n        throw new Error(`Transaction failed: ${txHash}`);\n      }\n\n      return receipt;\n    });\n  }\n  /**\n   * Calls the 'debug_setHead' JSON RPC method, which sets the current head of\n   * the local chain by block number. Note, this is a destructive action and\n   * may severely damage your chain. Use with extreme caution. As of now, this\n   * is only supported by Geth. It sill throw if the 'debug_setHead' method is\n   * not supported.\n   * @param  blockNumber The block number to reset to.\n   */\n\n\n  setHeadAsync(blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert_1.assert.isNumber('blockNumber', blockNumber);\n      yield this.sendRawPayloadAsync({\n        method: 'debug_setHead',\n        params: [utils_2.utils.numberToHex(blockNumber)]\n      });\n    });\n  }\n  /**\n   * Sends a raw Ethereum JSON RPC payload and returns the response's `result` key\n   * @param payload A partial JSON RPC payload. No need to include version, id, params (if none needed)\n   * @return The contents nested under the result key of the response body\n   */\n\n\n  sendRawPayloadAsync(payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payload.method) {\n        throw new Error(`Must supply method in JSONRPCRequestPayload, tried: [${payload}]`);\n      } // tslint:disable:no-object-literal-type-assertion\n\n\n      const payloadWithDefaults = Object.assign({\n        id: this._jsonRpcRequestId++,\n        params: [],\n        jsonrpc: '2.0'\n      }, payload); // tslint:enable:no-object-literal-type-assertion\n\n      const sendAsync = utils_1.promisify(this._provider.sendAsync.bind(this._provider));\n      const response = yield sendAsync(payloadWithDefaults); // will throw if it fails\n\n      if (!response) {\n        throw new Error(`No response`);\n      }\n\n      const errorMessage = response.error ? response.error.message || response.error : undefined;\n\n      if (errorMessage) {\n        throw new Error(errorMessage);\n      }\n\n      if (response.result === undefined) {\n        throw new Error(`JSON RPC response has no result`);\n      }\n\n      return response.result;\n    });\n  }\n  /**\n   * Returns either NodeType.Geth or NodeType.Ganache depending on the type of\n   * the backing Ethereum node. Throws for any other type of node.\n   */\n\n\n  getNodeTypeAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const version = yield this.getNodeVersionAsync();\n\n      if (_.includes(version, uniqueVersionIds.geth)) {\n        return types_1.NodeType.Geth;\n      } else if (_.includes(version, uniqueVersionIds.ganache)) {\n        return types_1.NodeType.Ganache;\n      } else {\n        throw new Error(`Unknown client version: ${version}`);\n      }\n    });\n  }\n\n} // tslint:disable-line:max-file-line-count\n\n\nexports.Web3Wrapper = Web3Wrapper;","map":{"version":3,"sources":["../../src/web3_wrapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Web3Wrapper = void 0;\nconst assert_1 = require(\"@0x/assert\");\nconst json_schemas_1 = require(\"@0x/json-schemas\");\nconst utils_1 = require(\"@0x/utils\");\nconst ethereum_types_1 = require(\"ethereum-types\");\nconst _ = require(\"lodash\");\nconst marshaller_1 = require(\"./marshaller\");\nconst types_1 = require(\"./types\");\nconst utils_2 = require(\"./utils\");\nconst BASE_TEN = 10;\n// These are unique identifiers contained in the response of the\n// web3_clientVersion call.\nconst uniqueVersionIds = {\n    geth: 'Geth',\n    ganache: 'EthereumJS TestRPC',\n};\n/**\n * An alternative to the Web3.js library that provides a consistent, clean, promise-based interface.\n */\nclass Web3Wrapper {\n    /**\n     * Instantiates a new Web3Wrapper.\n     * @param   provider    The Web3 provider instance you would like the Web3Wrapper to use for interacting with\n     *                      the backing Ethereum node.\n     * @param   callAndTxnDefaults  Override Call and Txn Data defaults sent with RPC requests to the backing Ethereum node.\n     * @return  An instance of the Web3Wrapper class.\n     */\n    constructor(supportedProvider, callAndTxnDefaults = {}) {\n        /**\n         * Flag to check if this instance is of type Web3Wrapper\n         */\n        this.isZeroExWeb3Wrapper = true;\n        this.abiDecoder = new utils_1.AbiDecoder([]);\n        this._supportedProvider = supportedProvider;\n        this._provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n        this._callAndTxnDefaults = callAndTxnDefaults;\n        this._jsonRpcRequestId = 1;\n    }\n    /**\n     * Check if an address is a valid Ethereum address\n     * @param address Address to check\n     * @returns Whether the address is a valid Ethereum address\n     */\n    static isAddress(address) {\n        return utils_1.addressUtils.isAddress(address);\n    }\n    /**\n     * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n     * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n     * to 1 unit.\n     * @param   amount      The amount in baseUnits that you would like converted to units.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in units.\n     */\n    static toUnitAmount(amount, decimals) {\n        assert_1.assert.isValidBaseUnitAmount('amount', amount);\n        assert_1.assert.isNumber('decimals', decimals);\n        const aUnit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n        const unit = amount.div(aUnit);\n        return unit;\n    }\n    /**\n     * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n     * is the amount expressed in the smallest denomination.\n     * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n     * @param   amount      The amount of units that you would like converted to baseUnits.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in baseUnits.\n     */\n    static toBaseUnitAmount(amount, decimals) {\n        assert_1.assert.isNumber('decimals', decimals);\n        const unit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n        const baseUnitAmount = unit.times(amount);\n        const hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n        if (hasDecimals) {\n            throw new Error(`Invalid unit amount: ${amount.toString(BASE_TEN)} - Too many decimal places`);\n        }\n        return baseUnitAmount;\n    }\n    /**\n     * Convert an Ether amount from ETH to Wei\n     * @param ethAmount Amount of Ether to convert to wei\n     * @returns Amount in wei\n     */\n    static toWei(ethAmount) {\n        assert_1.assert.isBigNumber('ethAmount', ethAmount);\n        const ETH_DECIMALS = 18;\n        const balanceWei = Web3Wrapper.toBaseUnitAmount(ethAmount, ETH_DECIMALS);\n        return balanceWei;\n    }\n    static _assertBlockParam(blockParam) {\n        if (_.isNumber(blockParam)) {\n            return;\n        }\n        else if (_.isString(blockParam)) {\n            assert_1.assert.doesBelongToStringEnum('blockParam', blockParam, ethereum_types_1.BlockParamLiteral);\n        }\n    }\n    static _assertBlockParamOrString(blockParam) {\n        try {\n            Web3Wrapper._assertBlockParam(blockParam);\n        }\n        catch (err) {\n            try {\n                assert_1.assert.isHexString('blockParam', blockParam);\n                return;\n            }\n            catch (err) {\n                throw new Error(`Expected blockParam to be of type \"string | BlockParam\", encountered ${blockParam}`);\n            }\n        }\n    }\n    static _normalizeTxReceiptStatus(status) {\n        // Transaction status might have four values\n        // undefined - Testrpc and other old clients\n        // null - New clients on old transactions\n        // number - Parity\n        // hex - Geth\n        if (_.isString(status)) {\n            return utils_2.utils.convertHexToNumber(status);\n        }\n        else if (status === undefined) {\n            return null;\n        }\n        else {\n            return status;\n        }\n    }\n    /**\n     * Get the contract defaults set to the Web3Wrapper instance\n     * @return  CallAndTxnData defaults (e.g gas, gasPrice, nonce, etc...)\n     */\n    getContractDefaults() {\n        return this._callAndTxnDefaults;\n    }\n    /**\n     * Retrieve the Web3 provider\n     * @return  Web3 provider instance\n     */\n    getProvider() {\n        return this._supportedProvider;\n    }\n    /**\n     * Update the used Web3 provider\n     * @param provider The new Web3 provider to be set\n     */\n    setProvider(supportedProvider) {\n        const provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n        this._provider = provider;\n    }\n    /**\n     * Check whether an address is available through the backing provider. This can be\n     * useful if you want to know whether a user can sign messages or transactions from\n     * a given Ethereum address.\n     * @param senderAddress Address to check availability for\n     * @returns Whether the address is available through the provider.\n     */\n    isSenderAddressAvailableAsync(senderAddress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isETHAddressHex('senderAddress', senderAddress);\n            const addresses = yield this.getAvailableAddressesAsync();\n            const normalizedAddress = senderAddress.toLowerCase();\n            return _.includes(addresses, normalizedAddress);\n        });\n    }\n    /**\n     * Fetch the backing Ethereum node's version string (e.g `MetaMask/v4.2.0`)\n     * @returns Ethereum node's version string\n     */\n    getNodeVersionAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const nodeVersion = yield this.sendRawPayloadAsync({ method: 'web3_clientVersion' });\n            return nodeVersion;\n        });\n    }\n    /**\n     * Fetches the networkId of the backing Ethereum node\n     * @returns The network id\n     */\n    getNetworkIdAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networkIdStr = yield this.sendRawPayloadAsync({ method: 'net_version' });\n            const networkId = _.parseInt(networkIdStr);\n            return networkId;\n        });\n    }\n    /**\n     * Fetches the chainId of the backing Ethereum node\n     * @returns The chain id\n     */\n    getChainIdAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const chainIdStr = yield this.sendRawPayloadAsync({ method: 'eth_chainId' });\n            const chainId = _.parseInt(chainIdStr);\n            return chainId;\n        });\n    }\n    /**\n     * Fetch the current gas price.\n     * For post-London hardfork chains, this will be baseFeePerGas + maxPriorityFeePerGas\n     */\n    getGasPriceAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const gasPriceStr = yield this.sendRawPayloadAsync({ method: 'eth_gasPrice' });\n            return new utils_1.BigNumber(gasPriceStr);\n        });\n    }\n    /**\n     * Fetch the base fee per gas for the pending block.\n     */\n    getBaseFeePerGasAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const rawBlock = yield this.sendRawPayloadAsync({\n                method: 'eth_getBlockByNumber',\n                params: ['pending', false],\n            });\n            const { baseFeePerGas } = rawBlock;\n            return new utils_1.BigNumber(baseFeePerGas || 0);\n        });\n    }\n    /**\n     * Fetch the current max piority fee per gas. This is the suggested miner tip\n     * to get mined in the current block.\n     */\n    getMaxPriorityFeePerGasAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const feeStr = yield this.sendRawPayloadAsync({ method: 'eth_maxPriorityFeePerGas' });\n            return new utils_1.BigNumber(feeStr);\n        });\n    }\n    /**\n     * Retrieves the transaction receipt for a given transaction hash if found\n     * @param txHash Transaction hash\n     * @returns The transaction receipt, including it's status (0: failed, 1: succeeded). Returns undefined if transaction not found.\n     */\n    getTransactionReceiptIfExistsAsync(txHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isHexString('txHash', txHash);\n            const transactionReceiptRpc = yield this.sendRawPayloadAsync({\n                method: 'eth_getTransactionReceipt',\n                params: [txHash],\n            });\n            // HACK Parity can return a pending transaction receipt. We check for a non null\n            // block number before continuing with returning a fully realised receipt.\n            // ref: https://github.com/paritytech/parity-ethereum/issues/1180\n            if (transactionReceiptRpc !== null && transactionReceiptRpc.blockNumber !== null) {\n                transactionReceiptRpc.status = Web3Wrapper._normalizeTxReceiptStatus(transactionReceiptRpc.status);\n                const transactionReceipt = marshaller_1.marshaller.unmarshalTransactionReceipt(transactionReceiptRpc);\n                return transactionReceipt;\n            }\n            else {\n                return undefined;\n            }\n        });\n    }\n    /**\n     * Retrieves the transaction data for a given transaction\n     * @param txHash Transaction hash\n     * @returns The raw transaction data\n     */\n    getTransactionByHashAsync(txHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isHexString('txHash', txHash);\n            const transactionRpc = yield this.sendRawPayloadAsync({\n                method: 'eth_getTransactionByHash',\n                params: [txHash],\n            });\n            const transaction = marshaller_1.marshaller.unmarshalTransaction(transactionRpc);\n            return transaction;\n        });\n    }\n    /**\n     * Retrieves an accounts Ether balance in wei\n     * @param owner Account whose balance you wish to check\n     * @param defaultBlock The block depth at which to fetch the balance (default=latest)\n     * @returns Balance in wei\n     */\n    getBalanceInWeiAsync(owner, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isETHAddressHex('owner', owner);\n            if (defaultBlock !== undefined) {\n                Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n            const marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            const encodedOwner = marshaller_1.marshaller.marshalAddress(owner);\n            const balanceInWei = yield this.sendRawPayloadAsync({\n                method: 'eth_getBalance',\n                params: [encodedOwner, marshalledDefaultBlock],\n            });\n            // Rewrap in a new BigNumber\n            return new utils_1.BigNumber(balanceInWei);\n        });\n    }\n    /**\n     * Check if a contract exists at a given address\n     * @param address Address to which to check\n     * @returns Whether or not contract code was found at the supplied address\n     */\n    doesContractExistAtAddressAsync(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isETHAddressHex('address', address);\n            const code = yield this.getContractCodeAsync(address);\n            // Regex matches 0x0, 0x00, 0x in order to accommodate poorly implemented clients\n            const isCodeEmpty = /^0x0{0,40}$/i.test(code);\n            return !isCodeEmpty;\n        });\n    }\n    /**\n     * Gets the contract code by address\n     * @param  address Address of the contract\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @return Code of the contract\n     */\n    getContractCodeAsync(address, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isETHAddressHex('address', address);\n            if (defaultBlock !== undefined) {\n                Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n            const marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            const encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n            const code = yield this.sendRawPayloadAsync({\n                method: 'eth_getCode',\n                params: [encodedAddress, marshalledDefaultBlock],\n            });\n            return code;\n        });\n    }\n    /**\n     * Gets the debug trace of a transaction\n     * @param  txHash Hash of the transactuon to get a trace for\n     * @param  traceParams Config object allowing you to specify if you need memory/storage/stack traces.\n     * @return Transaction trace\n     */\n    getTransactionTraceAsync(txHash, traceParams) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isHexString('txHash', txHash);\n            const trace = yield this.sendRawPayloadAsync({\n                method: 'debug_traceTransaction',\n                params: [txHash, traceParams],\n            });\n            return trace;\n        });\n    }\n    /**\n     * Sign a message with a specific address's private key (`eth_sign`)\n     * @param address Address of signer\n     * @param message Message to sign\n     * @returns Signature string (might be VRS or RSV depending on the Signer)\n     */\n    signMessageAsync(address, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.isString('message', message); // TODO: Should this be stricter? Hex string?\n            const signData = yield this.sendRawPayloadAsync({\n                method: 'eth_sign',\n                params: [address, message],\n            });\n            return signData;\n        });\n    }\n    /**\n     * Sign an EIP712 typed data message with a specific address's private key (`eth_signTypedData`)\n     * @param address Address of signer\n     * @param typedData Typed data message to sign\n     * @returns Signature string (as RSV)\n     */\n    signTypedDataAsync(address, typedData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.doesConformToSchema('typedData', typedData, json_schemas_1.schemas.eip712TypedDataSchema);\n            // Try decreasing versions of `eth_signTypedData` until it works.\n            const methodsToTry = ['eth_signTypedData_v4', 'eth_signTypedData_v3', 'eth_signTypedData'];\n            let lastErr;\n            for (const method of methodsToTry) {\n                try {\n                    return yield this.sendRawPayloadAsync({\n                        method,\n                        // `eth_signTypedData` expects an object, whereas the others expect\n                        // a JSON string.\n                        params: [address, method === 'eth_signTypedData' ? typedData : JSON.stringify(typedData)],\n                    });\n                }\n                catch (err) {\n                    lastErr = err;\n                    // If there are no more methods to try or the error says something other\n                    // than the method not existing, throw.\n                    if (!/(not handled|does not exist|not supported)/.test(err.message)) {\n                        throw err;\n                    }\n                }\n            }\n            throw lastErr;\n        });\n    }\n    /**\n     * Fetches the latest block number\n     * @returns Block number\n     */\n    getBlockNumberAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const blockNumberHex = yield this.sendRawPayloadAsync({\n                method: 'eth_blockNumber',\n                params: [],\n            });\n            const blockNumber = utils_2.utils.convertHexToNumberOrNull(blockNumberHex);\n            return blockNumber;\n        });\n    }\n    /**\n     * Fetches the nonce for an account (transaction count for EOAs).\n     * @param address Address of account.\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @returns Account nonce.\n     */\n    getAccountNonceAsync(address, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isETHAddressHex('address', address);\n            if (defaultBlock !== undefined) {\n                Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n            const marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            const encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n            const nonceHex = yield this.sendRawPayloadAsync({\n                method: 'eth_getTransactionCount',\n                params: [encodedAddress, marshalledDefaultBlock],\n            });\n            assert_1.assert.isHexString('nonce', nonceHex);\n            // tslint:disable-next-line:custom-no-magic-numbers\n            return parseInt(nonceHex.substr(2), 16);\n        });\n    }\n    /**\n     * Fetch a specific Ethereum block without transaction data\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The requested block without transaction data, or undefined if block was not found\n     * (e.g the node isn't fully synced, there was a block re-org and the requested block was uncles, etc...)\n     */\n    getBlockIfExistsAsync(blockParam) {\n        return __awaiter(this, void 0, void 0, function* () {\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n            const encodedBlockParam = marshaller_1.marshaller.marshalBlockParam(blockParam);\n            const method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            const shouldIncludeTransactionData = false;\n            const blockWithoutTransactionDataWithHexValuesOrNull = yield this.sendRawPayloadAsync({\n                method,\n                params: [encodedBlockParam, shouldIncludeTransactionData],\n            });\n            let blockWithoutTransactionDataIfExists;\n            if (blockWithoutTransactionDataWithHexValuesOrNull !== null) {\n                blockWithoutTransactionDataIfExists = marshaller_1.marshaller.unmarshalIntoBlockWithoutTransactionData(blockWithoutTransactionDataWithHexValuesOrNull);\n            }\n            return blockWithoutTransactionDataIfExists;\n        });\n    }\n    /**\n     * Fetch a specific Ethereum block with transaction data\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The requested block with transaction data\n     */\n    getBlockWithTransactionDataAsync(blockParam) {\n        return __awaiter(this, void 0, void 0, function* () {\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n            let encodedBlockParam = blockParam;\n            if (_.isNumber(blockParam)) {\n                encodedBlockParam = utils_2.utils.numberToHex(blockParam);\n            }\n            const method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            const shouldIncludeTransactionData = true;\n            const blockWithTransactionDataWithHexValues = yield this.sendRawPayloadAsync({\n                method,\n                params: [encodedBlockParam, shouldIncludeTransactionData],\n            });\n            const blockWithoutTransactionData = marshaller_1.marshaller.unmarshalIntoBlockWithTransactionData(blockWithTransactionDataWithHexValues);\n            return blockWithoutTransactionData;\n        });\n    }\n    /**\n     * Fetch a block's timestamp\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The block's timestamp\n     */\n    getBlockTimestampAsync(blockParam) {\n        return __awaiter(this, void 0, void 0, function* () {\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n            const blockIfExists = yield this.getBlockIfExistsAsync(blockParam);\n            if (blockIfExists === undefined) {\n                throw new Error(`Failed to fetch block with blockParam: ${JSON.stringify(blockParam)}`);\n            }\n            return blockIfExists.timestamp;\n        });\n    }\n    /**\n     * Retrieve the user addresses available through the backing provider\n     * @returns Available user addresses\n     */\n    getAvailableAddressesAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const addresses = yield this.sendRawPayloadAsync({\n                method: 'eth_accounts',\n                params: [],\n            });\n            const normalizedAddresses = _.map(addresses, address => address.toLowerCase());\n            return normalizedAddresses;\n        });\n    }\n    /**\n     * Take a snapshot of the blockchain state on a TestRPC/Ganache local node\n     * @returns The snapshot id. This can be used to revert to this snapshot\n     */\n    takeSnapshotAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const snapshotId = Number(yield this.sendRawPayloadAsync({ method: 'evm_snapshot', params: [] }));\n            return snapshotId;\n        });\n    }\n    /**\n     * Revert the blockchain state to a previous snapshot state on TestRPC/Ganache local node\n     * @param snapshotId snapshot id to revert to\n     * @returns Whether the revert was successful\n     */\n    revertSnapshotAsync(snapshotId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isNumber('snapshotId', snapshotId);\n            const didRevert = yield this.sendRawPayloadAsync({ method: 'evm_revert', params: [snapshotId] });\n            return didRevert;\n        });\n    }\n    /**\n     * Mine a block on a TestRPC/Ganache local node\n     */\n    mineBlockAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.sendRawPayloadAsync({ method: 'evm_mine', params: [] });\n        });\n    }\n    /**\n     * Increase the next blocks timestamp on TestRPC/Ganache or Geth local node.\n     * Will throw if provider is neither TestRPC/Ganache or Geth.\n     * @param timeDelta Amount of time to add in seconds\n     */\n    increaseTimeAsync(timeDelta) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isNumber('timeDelta', timeDelta);\n            // Detect Geth vs. Ganache and use appropriate endpoint.\n            const version = yield this.getNodeVersionAsync();\n            if (_.includes(version, uniqueVersionIds.geth)) {\n                return this.sendRawPayloadAsync({ method: 'debug_increaseTime', params: [timeDelta] });\n            }\n            else if (_.includes(version, uniqueVersionIds.ganache)) {\n                return this.sendRawPayloadAsync({ method: 'evm_increaseTime', params: [timeDelta] });\n            }\n            else {\n                throw new Error(`Unknown client version: ${version}`);\n            }\n        });\n    }\n    /**\n     * Retrieve smart contract logs for a given filter\n     * @param filter Parameters by which to filter which logs to retrieve\n     * @returns The corresponding log entries\n     */\n    getLogsAsync(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (filter.blockHash !== undefined && (filter.fromBlock !== undefined || filter.toBlock !== undefined)) {\n                throw new Error(`Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'`);\n            }\n            let fromBlock = filter.fromBlock;\n            if (_.isNumber(fromBlock)) {\n                fromBlock = utils_2.utils.numberToHex(fromBlock);\n            }\n            let toBlock = filter.toBlock;\n            if (_.isNumber(toBlock)) {\n                toBlock = utils_2.utils.numberToHex(toBlock);\n            }\n            const serializedFilter = Object.assign(Object.assign({}, filter), { fromBlock,\n                toBlock });\n            const payload = {\n                method: 'eth_getLogs',\n                params: [serializedFilter],\n            };\n            const rawLogs = yield this.sendRawPayloadAsync(payload);\n            const formattedLogs = _.map(rawLogs, marshaller_1.marshaller.unmarshalLog.bind(marshaller_1.marshaller));\n            return formattedLogs;\n        });\n    }\n    /**\n     * Calculate the estimated gas cost for a given transaction\n     * @param txData Transaction data\n     * @returns Estimated gas cost\n     */\n    estimateGasAsync(txData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema);\n            const txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            const gasHex = yield this.sendRawPayloadAsync({ method: 'eth_estimateGas', params: [txDataHex] });\n            const gas = utils_2.utils.convertHexToNumber(gasHex);\n            return gas;\n        });\n    }\n    /**\n     * Generate an access list for an ethereum call and also compute the gas used.\n     * @param callData Call data\n     * @param defaultBlock Block height at which to make the call. Defaults to 'latest'.\n     * @returns The access list and gas used.\n     */\n    createAccessListAsync(callData, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema, [\n                json_schemas_1.schemas.addressSchema,\n                json_schemas_1.schemas.numberSchema,\n                json_schemas_1.schemas.jsNumber,\n            ]);\n            const rawResult = yield this.sendRawPayloadAsync({\n                method: 'eth_createAccessList',\n                params: [marshaller_1.marshaller.marshalCallData(callData), marshaller_1.marshaller.marshalBlockParam(defaultBlock)],\n            });\n            if (rawResult.error) {\n                throw new Error(rawResult.error);\n            }\n            return {\n                accessList: rawResult.accessList.reduce((o, v) => {\n                    o[v.address] = o[v.address] || [];\n                    o[v.address].push(...(v.storageKeys || []));\n                    return o;\n                }, \n                // tslint:disable-next-line: no-object-literal-type-assertion\n                {}),\n                // tslint:disable-next-line: custom-no-magic-numbers\n                gasUsed: parseInt(rawResult.gasUsed.slice(2), 16),\n            };\n        });\n    }\n    /**\n     * Call a smart contract method at a given block height\n     * @param callData Call data\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @returns The raw call result\n     */\n    callAsync(callData, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema);\n            if (defaultBlock !== undefined) {\n                Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n            const marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            const callDataHex = marshaller_1.marshaller.marshalCallData(callData);\n            const overrides = marshaller_1.marshaller.marshalCallOverrides(callData.overrides || {});\n            const rawCallResult = yield this.sendRawPayloadAsync({\n                method: 'eth_call',\n                params: [callDataHex, marshalledDefaultBlock, ...(Object.keys(overrides).length === 0 ? [] : [overrides])],\n            });\n            return rawCallResult;\n        });\n    }\n    /**\n     * Send a transaction\n     * @param txData Transaction data\n     * @returns Transaction hash\n     */\n    sendTransactionAsync(txData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema);\n            const txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            const txHash = yield this.sendRawPayloadAsync({ method: 'eth_sendTransaction', params: [txDataHex] });\n            return txHash;\n        });\n    }\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * Note that just because a transaction was mined does not mean it was\n     * successful. You need to check the status code of the transaction receipt\n     * to find out if it was successful, or use the helper method\n     * awaitTransactionSuccessAsync.\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n    awaitTransactionMinedAsync(txHash, pollingIntervalMs = 1000, timeoutMs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isHexString('txHash', txHash);\n            assert_1.assert.isNumber('pollingIntervalMs', pollingIntervalMs);\n            if (timeoutMs !== undefined) {\n                assert_1.assert.isNumber('timeoutMs', timeoutMs);\n            }\n            // Immediately check if the transaction has already been mined.\n            let transactionReceipt = yield this.getTransactionReceiptIfExistsAsync(txHash);\n            if (transactionReceipt !== undefined) {\n                const logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                const transactionReceiptWithDecodedLogArgs = Object.assign(Object.assign({}, transactionReceipt), { logs: logsWithDecodedArgs });\n                return transactionReceiptWithDecodedLogArgs;\n            }\n            // Otherwise, check again every pollingIntervalMs.\n            let wasTimeoutExceeded = false;\n            if (timeoutMs) {\n                setTimeout(() => (wasTimeoutExceeded = true), timeoutMs);\n            }\n            const txReceiptPromise = new Promise((resolve, reject) => {\n                const intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(() => __awaiter(this, void 0, void 0, function* () {\n                    if (wasTimeoutExceeded) {\n                        utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                        return reject(types_1.Web3WrapperErrors.TransactionMiningTimeout);\n                    }\n                    transactionReceipt = yield this.getTransactionReceiptIfExistsAsync(txHash);\n                    if (transactionReceipt !== undefined) {\n                        utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                        const logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                        const transactionReceiptWithDecodedLogArgs = Object.assign(Object.assign({}, transactionReceipt), { logs: logsWithDecodedArgs });\n                        resolve(transactionReceiptWithDecodedLogArgs);\n                    }\n                }), pollingIntervalMs, (err) => {\n                    utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                    reject(err);\n                });\n            });\n            const txReceipt = yield txReceiptPromise;\n            return txReceipt;\n        });\n    }\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * Unlike awaitTransactionMinedAsync, it will throw if the receipt has a\n     * status that is not equal to 1. A status of 0 or null indicates that the\n     * transaction was mined, but failed. See:\n     * https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n    awaitTransactionSuccessAsync(txHash, pollingIntervalMs = 1000, timeoutMs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs);\n            if (receipt.status !== 1) {\n                throw new Error(`Transaction failed: ${txHash}`);\n            }\n            return receipt;\n        });\n    }\n    /**\n     * Calls the 'debug_setHead' JSON RPC method, which sets the current head of\n     * the local chain by block number. Note, this is a destructive action and\n     * may severely damage your chain. Use with extreme caution. As of now, this\n     * is only supported by Geth. It sill throw if the 'debug_setHead' method is\n     * not supported.\n     * @param  blockNumber The block number to reset to.\n     */\n    setHeadAsync(blockNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert_1.assert.isNumber('blockNumber', blockNumber);\n            yield this.sendRawPayloadAsync({ method: 'debug_setHead', params: [utils_2.utils.numberToHex(blockNumber)] });\n        });\n    }\n    /**\n     * Sends a raw Ethereum JSON RPC payload and returns the response's `result` key\n     * @param payload A partial JSON RPC payload. No need to include version, id, params (if none needed)\n     * @return The contents nested under the result key of the response body\n     */\n    sendRawPayloadAsync(payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payload.method) {\n                throw new Error(`Must supply method in JSONRPCRequestPayload, tried: [${payload}]`);\n            }\n            // tslint:disable:no-object-literal-type-assertion\n            const payloadWithDefaults = Object.assign({ id: this._jsonRpcRequestId++, params: [], jsonrpc: '2.0' }, payload);\n            // tslint:enable:no-object-literal-type-assertion\n            const sendAsync = utils_1.promisify(this._provider.sendAsync.bind(this._provider));\n            const response = yield sendAsync(payloadWithDefaults); // will throw if it fails\n            if (!response) {\n                throw new Error(`No response`);\n            }\n            const errorMessage = response.error ? response.error.message || response.error : undefined;\n            if (errorMessage) {\n                throw new Error(errorMessage);\n            }\n            if (response.result === undefined) {\n                throw new Error(`JSON RPC response has no result`);\n            }\n            return response.result;\n        });\n    }\n    /**\n     * Returns either NodeType.Geth or NodeType.Ganache depending on the type of\n     * the backing Ethereum node. Throws for any other type of node.\n     */\n    getNodeTypeAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const version = yield this.getNodeVersionAsync();\n            if (_.includes(version, uniqueVersionIds.geth)) {\n                return types_1.NodeType.Geth;\n            }\n            else if (_.includes(version, uniqueVersionIds.ganache)) {\n                return types_1.NodeType.Ganache;\n            }\n            else {\n                throw new Error(`Unknown client version: ${version}`);\n            }\n        });\n    }\n} // tslint:disable-line:max-file-line-count\nexports.Web3Wrapper = Web3Wrapper;\n//# sourceMappingURL=web3_wrapper.js.map"]},"metadata":{},"sourceType":"script"}