{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$();\n\nimport { parseBytes32String } from '@ethersproject/strings';\nimport { ETHER, Token, currencyEquals } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useSelectedTokenList } from 'state/lists/hooks';\nimport { NEVER_RELOAD, useMultipleContractSingleData, useSingleCallResult } from 'state/multicall/hooks';\nimport { useUserAddedTokens } from 'state/user/hooks';\nimport { isAddress } from 'utils';\nimport { useActiveWeb3React } from 'hooks';\nimport { useBytes32TokenContract, useTokenContract } from 'hooks/useContract';\nimport ERC20_INTERFACE, { ERC20_BYTES32_INTERFACE } from 'constants/abis/erc20';\nexport function useAllTokens() {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n  const allTokens = useSelectedTokenList();\n  return useMemo(() => {\n    if (!chainId) return {};\n    return userAddedTokens // reduce into all ALL_TOKENS filtered by the current chain\n    .reduce((tokenMap, token) => {\n      tokenMap[token.address] = token;\n      return tokenMap;\n    }, // must make a copy because reduce modifies the map, and we do not\n    // want to make a copy in every iteration\n    { ...allTokens[chainId]\n    });\n  }, [chainId, userAddedTokens, allTokens]);\n} // Check if currency is included in custom list from user storage\n\n_s(useAllTokens, \"j7VLVC0kwHLk93LfVYEfD5N0DOQ=\", false, function () {\n  return [useActiveWeb3React, useUserAddedTokens, useSelectedTokenList];\n});\n\nexport function useIsUserAddedToken(currency) {\n  _s2();\n\n  const userAddedTokens = useUserAddedTokens();\n  return !!userAddedTokens.find(token => currencyEquals(currency, token));\n}\n\n_s2(useIsUserAddedToken, \"/J12HuilTfT8HPlUWn/aslQP0JY=\", false, function () {\n  return [useUserAddedTokens];\n});\n\nexport function useIsUserAddedTokens(currencies) {\n  _s3();\n\n  const userAddedTokens = useUserAddedTokens();\n  return currencies.map(currency => !!userAddedTokens.find(token => currencyEquals(currency, token)));\n} // parse a name or symbol from a token response\n\n_s3(useIsUserAddedTokens, \"/J12HuilTfT8HPlUWn/aslQP0JY=\", false, function () {\n  return [useUserAddedTokens];\n});\n\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\n\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str : bytes32 && BYTES32_REGEX.test(bytes32) ? parseBytes32String(bytes32) : defaultValue;\n} // undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\n\n\nexport function useToken(tokenAddress) {\n  _s4();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens();\n  const address = isAddress(tokenAddress);\n  const tokenContract = useTokenContract(address ? address : undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false);\n  const token = address ? tokens[address] : undefined;\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'name', undefined, NEVER_RELOAD);\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n\n    if (decimals.result) {\n      var _symbol$result, _symbolBytes32$result, _tokenName$result, _tokenNameBytes32$res;\n\n      return new Token(chainId, address, decimals.result[0], parseStringOrBytes32((_symbol$result = symbol.result) === null || _symbol$result === void 0 ? void 0 : _symbol$result[0], (_symbolBytes32$result = symbolBytes32.result) === null || _symbolBytes32$result === void 0 ? void 0 : _symbolBytes32$result[0], 'UNKNOWN'), parseStringOrBytes32((_tokenName$result = tokenName.result) === null || _tokenName$result === void 0 ? void 0 : _tokenName$result[0], (_tokenNameBytes32$res = tokenNameBytes32.result) === null || _tokenNameBytes32$res === void 0 ? void 0 : _tokenNameBytes32$res[0], 'Unknown Token'));\n    }\n\n    return undefined;\n  }, [address, chainId, decimals.loading, decimals.result, symbol.loading, symbol.result, symbolBytes32.result, token, tokenName.loading, tokenName.result, tokenNameBytes32.result]);\n} // Use tokens should be used to simplify getting token data in the future.\n// Currently our token lists are dependent on json data.\n// 1. We need to fix the lists so the store the raw data and not the tokens\n// 2. Once the list is retrieved we should call the use token hooks to obtain the missing tokens\n// 3. We then should convert the raw lists to their wrapped forms which store the tokens\n// 4. Then we should store the wrapped list in the state.\n// 5. Before this all can occur we need to update our lists to operate on addresses instead of Symbols (There already is a PR waiting missing the new farms)\n\n_s4(useToken, \"eKyRyOw1MkhB0rg/op393nwat5k=\", false, function () {\n  return [useActiveWeb3React, useAllTokens, useTokenContract, useBytes32TokenContract, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult];\n});\n\nexport function useTokens(tokenAddresses) {\n  _s5();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens();\n  const tokenSet = [...new Set(tokenAddresses)];\n  const validatedUnknownTokenAddresses = tokenSet.filter(x => isAddress(x)).filter(x => !tokens[x]);\n  const tokenNames = useMultipleContractSingleData(validatedUnknownTokenAddresses, ERC20_INTERFACE, 'name', undefined, NEVER_RELOAD);\n  const tokenNamesBytes32 = useMultipleContractSingleData(validatedUnknownTokenAddresses, ERC20_BYTES32_INTERFACE, 'name', undefined, NEVER_RELOAD);\n  const symbols = useMultipleContractSingleData(validatedUnknownTokenAddresses, ERC20_INTERFACE, 'symbol', undefined, NEVER_RELOAD);\n  const symbolsBytes32 = useMultipleContractSingleData(validatedUnknownTokenAddresses, ERC20_BYTES32_INTERFACE, 'symbol', undefined, NEVER_RELOAD);\n  const tokenDecimals = useMultipleContractSingleData(validatedUnknownTokenAddresses, ERC20_INTERFACE, 'decimals', undefined, NEVER_RELOAD);\n  const anyLoading = useMemo(() => tokenNames.some(callState => callState.loading) || tokenNamesBytes32.some(callState => callState.loading) || symbols.some(callState => callState.loading) || symbolsBytes32.some(callState => callState.loading) || tokenDecimals.some(callState => callState.loading), [tokenNames, tokenNamesBytes32, symbols, symbolsBytes32, tokenDecimals]);\n  return useMemo(() => {\n    const existingTokens = [...new Set(tokenAddresses)].filter(x => isAddress(x)).map(x => tokens[x]).filter(x => !!x);\n    return validatedUnknownTokenAddresses.reduce((memo, tokenAddress, index) => {\n      if (anyLoading || !chainId) {\n        return [];\n      }\n\n      const decimals = tokenDecimals[index];\n      const symbol = symbols[index];\n      const symbolBytes32 = symbolsBytes32[index];\n      const tokenName = tokenNames[index];\n      const tokenNameBytes32 = tokenNamesBytes32[index];\n\n      if (decimals.result) {\n        var _symbol$result2, _symbolBytes32$result2, _tokenName$result2, _tokenNameBytes32$res2;\n\n        memo.push(new Token(chainId, tokenAddress, decimals.result[0], parseStringOrBytes32((_symbol$result2 = symbol.result) === null || _symbol$result2 === void 0 ? void 0 : _symbol$result2[0], (_symbolBytes32$result2 = symbolBytes32.result) === null || _symbolBytes32$result2 === void 0 ? void 0 : _symbolBytes32$result2[0], 'UNKNOWN'), parseStringOrBytes32((_tokenName$result2 = tokenName.result) === null || _tokenName$result2 === void 0 ? void 0 : _tokenName$result2[0], (_tokenNameBytes32$res2 = tokenNameBytes32.result) === null || _tokenNameBytes32$res2 === void 0 ? void 0 : _tokenNameBytes32$res2[0], 'Unknown Token')));\n      }\n\n      return memo;\n    }, existingTokens);\n  }, [tokenAddresses, validatedUnknownTokenAddresses, tokens, anyLoading, chainId, tokenDecimals, symbols, symbolsBytes32, tokenNames, tokenNamesBytes32]);\n}\n\n_s5(useTokens, \"pOWLbQ5wggcVKkcjPvHS7OyIEEw=\", false, function () {\n  return [useActiveWeb3React, useAllTokens, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData];\n});\n\nexport function useCurrency(currencyId) {\n  _s6();\n\n  const isETH = (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === 'ETH';\n  const token = useToken(isETH ? undefined : currencyId);\n  return isETH ? ETHER : token;\n}\n\n_s6(useCurrency, \"YdEbLWY6/B/ql2/5vHiby7UXKcg=\", false, function () {\n  return [useToken];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/hooks/Tokens.ts"],"names":["parseBytes32String","ETHER","Token","currencyEquals","useMemo","useSelectedTokenList","NEVER_RELOAD","useMultipleContractSingleData","useSingleCallResult","useUserAddedTokens","isAddress","useActiveWeb3React","useBytes32TokenContract","useTokenContract","ERC20_INTERFACE","ERC20_BYTES32_INTERFACE","useAllTokens","chainId","userAddedTokens","allTokens","reduce","tokenMap","token","address","useIsUserAddedToken","currency","find","useIsUserAddedTokens","currencies","map","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","useToken","tokenAddress","tokens","tokenContract","undefined","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","loading","result","useTokens","tokenAddresses","tokenSet","Set","validatedUnknownTokenAddresses","filter","x","tokenNames","tokenNamesBytes32","symbols","symbolsBytes32","tokenDecimals","anyLoading","some","callState","existingTokens","memo","index","push","useCurrency","currencyId","isETH","toUpperCase"],"mappings":"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","sourcesContent":["import { parseBytes32String } from '@ethersproject/strings';\nimport { Currency, ETHER, Token, currencyEquals } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useSelectedTokenList } from 'state/lists/hooks';\nimport {\n  NEVER_RELOAD,\n  useMultipleContractSingleData,\n  useSingleCallResult,\n} from 'state/multicall/hooks';\nimport { useUserAddedTokens } from 'state/user/hooks';\nimport { isAddress } from 'utils';\n\nimport { useActiveWeb3React } from 'hooks';\nimport { useBytes32TokenContract, useTokenContract } from 'hooks/useContract';\nimport ERC20_INTERFACE, { ERC20_BYTES32_INTERFACE } from 'constants/abis/erc20';\n\nexport function useAllTokens(): { [address: string]: Token } {\n  const { chainId } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n  const allTokens = useSelectedTokenList();\n\n  return useMemo(() => {\n    if (!chainId) return {};\n    return (\n      userAddedTokens\n        // reduce into all ALL_TOKENS filtered by the current chain\n        .reduce<{ [address: string]: Token }>(\n          (tokenMap, token) => {\n            tokenMap[token.address] = token;\n            return tokenMap;\n          },\n          // must make a copy because reduce modifies the map, and we do not\n          // want to make a copy in every iteration\n          { ...allTokens[chainId] },\n        )\n    );\n  }, [chainId, userAddedTokens, allTokens]);\n}\n\n// Check if currency is included in custom list from user storage\nexport function useIsUserAddedToken(currency: Currency): boolean {\n  const userAddedTokens = useUserAddedTokens();\n  return !!userAddedTokens.find((token) => currencyEquals(currency, token));\n}\n\nexport function useIsUserAddedTokens(currencies: Currency[]): boolean[] {\n  const userAddedTokens = useUserAddedTokens();\n  return currencies.map(\n    (currency) =>\n      !!userAddedTokens.find((token) => currencyEquals(currency, token)),\n  );\n}\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\nfunction parseStringOrBytes32(\n  str: string | undefined,\n  bytes32: string | undefined,\n  defaultValue: string,\n): string {\n  return str && str.length > 0\n    ? str\n    : bytes32 && BYTES32_REGEX.test(bytes32)\n    ? parseBytes32String(bytes32)\n    : defaultValue;\n}\n\n// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress?: string): Token | undefined | null {\n  const { chainId } = useActiveWeb3React();\n  const tokens = useAllTokens();\n\n  const address = isAddress(tokenAddress);\n\n  const tokenContract = useTokenContract(address ? address : undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(\n    address ? address : undefined,\n    false,\n  );\n  const token: Token | undefined = address ? tokens[address] : undefined;\n\n  const tokenName = useSingleCallResult(\n    token ? undefined : tokenContract,\n    'name',\n    undefined,\n    NEVER_RELOAD,\n  );\n  const tokenNameBytes32 = useSingleCallResult(\n    token ? undefined : tokenContractBytes32,\n    'name',\n    undefined,\n    NEVER_RELOAD,\n  );\n  const symbol = useSingleCallResult(\n    token ? undefined : tokenContract,\n    'symbol',\n    undefined,\n    NEVER_RELOAD,\n  );\n  const symbolBytes32 = useSingleCallResult(\n    token ? undefined : tokenContractBytes32,\n    'symbol',\n    undefined,\n    NEVER_RELOAD,\n  );\n  const decimals = useSingleCallResult(\n    token ? undefined : tokenContract,\n    'decimals',\n    undefined,\n    NEVER_RELOAD,\n  );\n\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n    if (decimals.result) {\n      return new Token(\n        chainId,\n        address,\n        decimals.result[0],\n        parseStringOrBytes32(\n          symbol.result?.[0],\n          symbolBytes32.result?.[0],\n          'UNKNOWN',\n        ),\n        parseStringOrBytes32(\n          tokenName.result?.[0],\n          tokenNameBytes32.result?.[0],\n          'Unknown Token',\n        ),\n      );\n    }\n    return undefined;\n  }, [\n    address,\n    chainId,\n    decimals.loading,\n    decimals.result,\n    symbol.loading,\n    symbol.result,\n    symbolBytes32.result,\n    token,\n    tokenName.loading,\n    tokenName.result,\n    tokenNameBytes32.result,\n  ]);\n}\n\n// Use tokens should be used to simplify getting token data in the future.\n// Currently our token lists are dependent on json data.\n// 1. We need to fix the lists so the store the raw data and not the tokens\n// 2. Once the list is retrieved we should call the use token hooks to obtain the missing tokens\n// 3. We then should convert the raw lists to their wrapped forms which store the tokens\n// 4. Then we should store the wrapped list in the state.\n// 5. Before this all can occur we need to update our lists to operate on addresses instead of Symbols (There already is a PR waiting missing the new farms)\nexport function useTokens(\n  tokenAddresses: string[],\n): Token[] | undefined | null {\n  const { chainId } = useActiveWeb3React();\n  const tokens = useAllTokens();\n\n  const tokenSet = [...new Set(tokenAddresses)];\n  const validatedUnknownTokenAddresses = tokenSet\n    .filter((x) => isAddress(x))\n    .filter((x) => !tokens[x]);\n\n  const tokenNames = useMultipleContractSingleData(\n    validatedUnknownTokenAddresses,\n    ERC20_INTERFACE,\n    'name',\n    undefined,\n    NEVER_RELOAD,\n  );\n\n  const tokenNamesBytes32 = useMultipleContractSingleData(\n    validatedUnknownTokenAddresses,\n    ERC20_BYTES32_INTERFACE,\n    'name',\n    undefined,\n    NEVER_RELOAD,\n  );\n\n  const symbols = useMultipleContractSingleData(\n    validatedUnknownTokenAddresses,\n    ERC20_INTERFACE,\n    'symbol',\n    undefined,\n    NEVER_RELOAD,\n  );\n\n  const symbolsBytes32 = useMultipleContractSingleData(\n    validatedUnknownTokenAddresses,\n    ERC20_BYTES32_INTERFACE,\n    'symbol',\n    undefined,\n    NEVER_RELOAD,\n  );\n\n  const tokenDecimals = useMultipleContractSingleData(\n    validatedUnknownTokenAddresses,\n    ERC20_INTERFACE,\n    'decimals',\n    undefined,\n    NEVER_RELOAD,\n  );\n\n  const anyLoading: boolean = useMemo(\n    () =>\n      tokenNames.some((callState) => callState.loading) ||\n      tokenNamesBytes32.some((callState) => callState.loading) ||\n      symbols.some((callState) => callState.loading) ||\n      symbolsBytes32.some((callState) => callState.loading) ||\n      tokenDecimals.some((callState) => callState.loading),\n    [tokenNames, tokenNamesBytes32, symbols, symbolsBytes32, tokenDecimals],\n  );\n\n  return useMemo(() => {\n    const existingTokens = [...new Set(tokenAddresses)]\n      .filter((x) => isAddress(x))\n      .map((x) => tokens[x])\n      .filter((x) => !!x);\n    return validatedUnknownTokenAddresses.reduce<Token[]>(\n      (memo, tokenAddress, index) => {\n        if (anyLoading || !chainId) {\n          return [];\n        }\n\n        const decimals = tokenDecimals[index];\n        const symbol = symbols[index];\n        const symbolBytes32 = symbolsBytes32[index];\n        const tokenName = tokenNames[index];\n        const tokenNameBytes32 = tokenNamesBytes32[index];\n\n        if (decimals.result) {\n          memo.push(\n            new Token(\n              chainId,\n              tokenAddress,\n              decimals.result[0],\n              parseStringOrBytes32(\n                symbol.result?.[0],\n                symbolBytes32.result?.[0],\n                'UNKNOWN',\n              ),\n              parseStringOrBytes32(\n                tokenName.result?.[0],\n                tokenNameBytes32.result?.[0],\n                'Unknown Token',\n              ),\n            ),\n          );\n        }\n        return memo;\n      },\n      existingTokens,\n    );\n  }, [\n    tokenAddresses,\n    validatedUnknownTokenAddresses,\n    tokens,\n    anyLoading,\n    chainId,\n    tokenDecimals,\n    symbols,\n    symbolsBytes32,\n    tokenNames,\n    tokenNamesBytes32,\n  ]);\n}\n\nexport function useCurrency(\n  currencyId: string | undefined,\n): Currency | null | undefined {\n  const isETH = currencyId?.toUpperCase() === 'ETH';\n  const token = useToken(isETH ? undefined : currencyId);\n  return isETH ? ETHER : token;\n}\n"]},"metadata":{},"sourceType":"module"}