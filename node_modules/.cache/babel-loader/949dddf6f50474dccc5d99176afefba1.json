{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { TokenAmount, Pair } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { abi as IUniswapV2PairABI } from '@uniswap/v2-core/build/IUniswapV2Pair.json';\nimport { Interface } from '@ethersproject/abi';\nimport { useActiveWeb3React } from 'hooks';\nimport { useMultipleContractSingleData } from 'state/multicall/hooks';\nimport { wrappedCurrency } from 'utils/wrappedCurrency';\nconst PAIR_INTERFACE = new Interface(IUniswapV2PairABI);\nexport let PairState;\n\n(function (PairState) {\n  PairState[PairState[\"LOADING\"] = 0] = \"LOADING\";\n  PairState[PairState[\"NOT_EXISTS\"] = 1] = \"NOT_EXISTS\";\n  PairState[PairState[\"EXISTS\"] = 2] = \"EXISTS\";\n  PairState[PairState[\"INVALID\"] = 3] = \"INVALID\";\n})(PairState || (PairState = {}));\n\nexport function usePairs(currencies) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useMemo(() => currencies.map(_ref => {\n    let [currencyA, currencyB] = _ref;\n    return [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)];\n  }), [chainId, currencies]);\n  const pairAddresses = useMemo(() => tokens.map(_ref2 => {\n    let [tokenA, tokenB] = _ref2;\n    return tokenA && tokenB && !tokenA.equals(tokenB) ? Pair.getAddress(tokenA, tokenB) : undefined;\n  }), [tokens]);\n  const results = useMultipleContractSingleData(pairAddresses, PAIR_INTERFACE, 'getReserves');\n  return useMemo(() => {\n    return results.map((result, i) => {\n      const {\n        result: reserves,\n        loading\n      } = result;\n      const tokenA = tokens[i][0];\n      const tokenB = tokens[i][1];\n      if (loading) return [PairState.LOADING, null];\n      if (!tokenA || !tokenB || tokenA.equals(tokenB)) return [PairState.INVALID, null];\n      if (!reserves) return [PairState.NOT_EXISTS, null];\n      const {\n        reserve0,\n        reserve1\n      } = reserves;\n      const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n      return [PairState.EXISTS, new Pair(new TokenAmount(token0, reserve0.toString()), new TokenAmount(token1, reserve1.toString()))];\n    });\n  }, [results, tokens]);\n}\n\n_s(usePairs, \"E9gbPqRdveknnYKMKRnUQnOW2SE=\", false, function () {\n  return [useActiveWeb3React, useMultipleContractSingleData];\n});\n\nexport function usePair(tokenA, tokenB) {\n  _s2();\n\n  return usePairs([[tokenA, tokenB]])[0];\n}\n\n_s2(usePair, \"AJtW1Ot38FORoSrNpUliDLrh4e4=\", false, function () {\n  return [usePairs];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/data/Reserves.ts"],"names":["TokenAmount","Pair","useMemo","abi","IUniswapV2PairABI","Interface","useActiveWeb3React","useMultipleContractSingleData","wrappedCurrency","PAIR_INTERFACE","PairState","usePairs","currencies","chainId","tokens","map","currencyA","currencyB","pairAddresses","tokenA","tokenB","equals","getAddress","undefined","results","result","i","reserves","loading","LOADING","INVALID","NOT_EXISTS","reserve0","reserve1","token0","token1","sortsBefore","EXISTS","toString","usePair"],"mappings":"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","sourcesContent":["import { TokenAmount, Pair, Currency } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { abi as IUniswapV2PairABI } from '@uniswap/v2-core/build/IUniswapV2Pair.json';\nimport { Interface } from '@ethersproject/abi';\nimport { useActiveWeb3React } from 'hooks';\n\nimport { useMultipleContractSingleData } from 'state/multicall/hooks';\nimport { wrappedCurrency } from 'utils/wrappedCurrency';\n\nconst PAIR_INTERFACE = new Interface(IUniswapV2PairABI);\n\nexport enum PairState {\n  LOADING,\n  NOT_EXISTS,\n  EXISTS,\n  INVALID,\n}\n\nexport function usePairs(\n  currencies: [Currency | undefined, Currency | undefined][],\n): [PairState, Pair | null][] {\n  const { chainId } = useActiveWeb3React();\n\n  const tokens = useMemo(\n    () =>\n      currencies.map(([currencyA, currencyB]) => [\n        wrappedCurrency(currencyA, chainId),\n        wrappedCurrency(currencyB, chainId),\n      ]),\n    [chainId, currencies],\n  );\n\n  const pairAddresses = useMemo(\n    () =>\n      tokens.map(([tokenA, tokenB]) => {\n        return tokenA && tokenB && !tokenA.equals(tokenB)\n          ? Pair.getAddress(tokenA, tokenB)\n          : undefined;\n      }),\n    [tokens],\n  );\n\n  const results = useMultipleContractSingleData(\n    pairAddresses,\n    PAIR_INTERFACE,\n    'getReserves',\n  );\n\n  return useMemo(() => {\n    return results.map((result, i) => {\n      const { result: reserves, loading } = result;\n      const tokenA = tokens[i][0];\n      const tokenB = tokens[i][1];\n\n      if (loading) return [PairState.LOADING, null];\n      if (!tokenA || !tokenB || tokenA.equals(tokenB))\n        return [PairState.INVALID, null];\n      if (!reserves) return [PairState.NOT_EXISTS, null];\n      const { reserve0, reserve1 } = reserves;\n      const [token0, token1] = tokenA.sortsBefore(tokenB)\n        ? [tokenA, tokenB]\n        : [tokenB, tokenA];\n      return [\n        PairState.EXISTS,\n        new Pair(\n          new TokenAmount(token0, reserve0.toString()),\n          new TokenAmount(token1, reserve1.toString()),\n        ),\n      ];\n    });\n  }, [results, tokens]);\n}\n\nexport function usePair(\n  tokenA?: Currency,\n  tokenB?: Currency,\n): [PairState, Pair | null] {\n  return usePairs([[tokenA, tokenB]])[0];\n}\n"]},"metadata":{},"sourceType":"module"}