{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { ChainId } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { useSelectedTokenList } from 'state/lists/hooks';\nimport { getTokenFromAddress } from 'utils';\nimport { useTokens } from 'hooks/Tokens';\nimport { GlobalValue } from 'constants/index';\nexport class WrappedStakingInfo {\n  constructor(stakingInfo, tokenAddressMap, farmTokens, chainId) {\n    this.stakingInfo = void 0;\n    this.chainId = void 0;\n    this.stakingRewardAddress = void 0;\n    this.pair = void 0;\n    this.rate = void 0;\n    this.tokens = void 0;\n    this.ended = void 0;\n    this.lp = void 0;\n    this.name = void 0;\n    this.baseToken = void 0;\n    this.rewardToken = void 0;\n    this.stakingInfo = stakingInfo; //TODO: Support Multichain\n\n    this.chainId = chainId;\n    this.stakingRewardAddress = stakingInfo.stakingRewardAddress;\n    this.rate = stakingInfo.rate;\n    this.ended = stakingInfo.ended;\n    this.pair = stakingInfo.pair;\n    this.lp = stakingInfo.lp;\n    this.name = stakingInfo.name;\n    this.baseToken = getTokenFromAddress(stakingInfo.baseToken, chainId, tokenAddressMap, farmTokens);\n    this.tokens = [getTokenFromAddress(stakingInfo.tokens[0], chainId, tokenAddressMap, farmTokens), getTokenFromAddress(stakingInfo.tokens[1], chainId, tokenAddressMap, farmTokens)];\n    this.rewardToken = stakingInfo.rewardToken ? getTokenFromAddress(stakingInfo.rewardToken, chainId, tokenAddressMap, farmTokens) : GlobalValue.tokens.COMMON.OLD_DQUICK;\n  }\n\n}\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST = {\n  [ChainId.TESTNET]: {},\n  [ChainId.MAINNET]: {}\n};\nconst farmCache = typeof WeakMap !== 'undefined' ? new WeakMap() : null;\nexport function listToFarmMap(list, tokenAddressMap, farmTokens) {\n  const result = farmCache === null || farmCache === void 0 ? void 0 : farmCache.get(list);\n  if (result) return result;\n  const map = list.active.concat(list.closed).reduce((stakingInfoMap, stakingInfo) => {\n    const wrappedStakingInfo = new WrappedStakingInfo(stakingInfo, tokenAddressMap, farmTokens, ChainId.MAINNET);\n    if (stakingInfoMap[wrappedStakingInfo.chainId][wrappedStakingInfo.stakingRewardAddress] !== undefined) throw Error('Duplicate farms.');\n    return { ...stakingInfoMap,\n      [wrappedStakingInfo.chainId]: { ...stakingInfoMap[wrappedStakingInfo.chainId],\n        [wrappedStakingInfo.stakingRewardAddress]: wrappedStakingInfo\n      }\n    };\n  }, { ...EMPTY_LIST\n  });\n  farmCache === null || farmCache === void 0 ? void 0 : farmCache.set(list, map);\n  return map;\n}\nexport function useFarmList(url) {\n  _s();\n\n  var _farms$url;\n\n  const farms = useSelector(state => state.farms.byUrl);\n  const tokenMap = useSelectedTokenList();\n  const current = url ? (_farms$url = farms[url]) === null || _farms$url === void 0 ? void 0 : _farms$url.current : null;\n  const farmTokenAddresses = current && tokenMap ? current.active.concat(current.closed).map(item => [item.baseToken, item.tokens[0], item.tokens[1], item.rewardToken]).flat().filter(item => !!item).filter(address => !tokenMap[ChainId.MAINNET][address]).filter(address => !Object.values(GlobalValue.tokens.COMMON).find(token => token.address.toLowerCase() === address.toLowerCase())).filter((addr, ind, self) => self.findIndex(address => address.toLowerCase() === addr.toLowerCase()) === ind) : [];\n  console.log('bbb', farmTokenAddresses);\n  const farmTokens = useTokens(farmTokenAddresses);\n  return useMemo(() => {\n    if (!current || !tokenMap || (farmTokens === null || farmTokens === void 0 ? void 0 : farmTokens.length) !== farmTokenAddresses.length) return EMPTY_LIST;\n\n    try {\n      return listToFarmMap(current, tokenMap, farmTokens !== null && farmTokens !== void 0 ? farmTokens : []);\n    } catch (error) {\n      console.error('Could not show token list due to error', error);\n      return EMPTY_LIST;\n    }\n  }, [current, farmTokens, farmTokenAddresses.length, tokenMap]);\n}\n\n_s(useFarmList, \"GNqxNfBEbQn+Hx4n/WsIHXRajgI=\", false, function () {\n  return [useSelector, useSelectedTokenList, useTokens];\n});\n\nexport function useDefaultFarmList() {\n  _s2();\n\n  return useFarmList(process.env.REACT_APP_STAKING_LIST_DEFAULT_URL);\n} // returns all downloaded current lists\n\n_s2(useDefaultFarmList, \"woiIxloRd206NdtgG8ett9iPhpo=\", false, function () {\n  return [useFarmList];\n});\n\nexport function useAllFarms() {\n  _s3();\n\n  const farms = useSelector(state => state.farms.byUrl);\n  return useMemo(() => Object.keys(farms).map(url => farms[url].current).filter(l => Boolean(l)), [farms]);\n}\n\n_s3(useAllFarms, \"5JGsESKTryUVPCLw6irGlEEdraU=\", false, function () {\n  return [useSelector];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/state/farms/hooks.ts"],"names":["ChainId","useMemo","useSelector","useSelectedTokenList","getTokenFromAddress","useTokens","GlobalValue","WrappedStakingInfo","constructor","stakingInfo","tokenAddressMap","farmTokens","chainId","stakingRewardAddress","pair","rate","tokens","ended","lp","name","baseToken","rewardToken","COMMON","OLD_DQUICK","EMPTY_LIST","TESTNET","MAINNET","farmCache","WeakMap","listToFarmMap","list","result","get","map","active","concat","closed","reduce","stakingInfoMap","wrappedStakingInfo","undefined","Error","set","useFarmList","url","farms","state","byUrl","tokenMap","current","farmTokenAddresses","item","flat","filter","address","Object","values","find","token","toLowerCase","addr","ind","self","findIndex","console","log","length","error","useDefaultFarmList","process","env","REACT_APP_STAKING_LIST_DEFAULT_URL","useAllFarms","keys","l","Boolean"],"mappings":";;;;AAAA,SAASA,OAAT,QAAwB,cAAxB;AACA,SAASC,OAAT,QAAwB,OAAxB;AACA,SAASC,WAAT,QAA4B,aAA5B;AAIA,SAA0BC,oBAA1B,QAAsD,mBAAtD;AACA,SAASC,mBAAT,QAAoC,OAApC;AACA,SAASC,SAAT,QAA0B,cAA1B;AACA,SAASC,WAAT,QAA4B,iBAA5B;AAEA,OAAO,MAAMC,kBAAN,CAAiD;AAatDC,EAAAA,WAAW,CACTC,WADS,EAETC,eAFS,EAGTC,UAHS,EAITC,OAJS,EAKT;AAAA,SAjBcH,WAiBd;AAAA,SAhBcG,OAgBd;AAAA,SAfcC,oBAed;AAAA,SAdcC,IAcd;AAAA,SAbcC,IAad;AAAA,SAZcC,MAYd;AAAA,SAXcC,KAWd;AAAA,SAVcC,EAUd;AAAA,SATcC,IASd;AAAA,SARcC,SAQd;AAAA,SAPcC,WAOd;AACA,SAAKZ,WAAL,GAAmBA,WAAnB,CADA,CAEA;;AACA,SAAKG,OAAL,GAAeA,OAAf;AACA,SAAKC,oBAAL,GAA4BJ,WAAW,CAACI,oBAAxC;AACA,SAAKE,IAAL,GAAYN,WAAW,CAACM,IAAxB;AACA,SAAKE,KAAL,GAAaR,WAAW,CAACQ,KAAzB;AACA,SAAKH,IAAL,GAAYL,WAAW,CAACK,IAAxB;AACA,SAAKI,EAAL,GAAUT,WAAW,CAACS,EAAtB;AACA,SAAKC,IAAL,GAAYV,WAAW,CAACU,IAAxB;AAEA,SAAKC,SAAL,GAAiBhB,mBAAmB,CAClCK,WAAW,CAACW,SADsB,EAElCR,OAFkC,EAGlCF,eAHkC,EAIlCC,UAJkC,CAApC;AAMA,SAAKK,MAAL,GAAc,CACZZ,mBAAmB,CACjBK,WAAW,CAACO,MAAZ,CAAmB,CAAnB,CADiB,EAEjBJ,OAFiB,EAGjBF,eAHiB,EAIjBC,UAJiB,CADP,EAOZP,mBAAmB,CACjBK,WAAW,CAACO,MAAZ,CAAmB,CAAnB,CADiB,EAEjBJ,OAFiB,EAGjBF,eAHiB,EAIjBC,UAJiB,CAPP,CAAd;AAcA,SAAKU,WAAL,GAAmBZ,WAAW,CAACY,WAAZ,GACfjB,mBAAmB,CACjBK,WAAW,CAACY,WADK,EAEjBT,OAFiB,EAGjBF,eAHiB,EAIjBC,UAJiB,CADJ,GAOfL,WAAW,CAACU,MAAZ,CAAmBM,MAAnB,CAA0BC,UAP9B;AAQD;;AAzDqD;;AAoExD;AACA;AACA;AACA,MAAMC,UAAiC,GAAG;AACxC,GAACxB,OAAO,CAACyB,OAAT,GAAmB,EADqB;AAExC,GAACzB,OAAO,CAAC0B,OAAT,GAAmB;AAFqB,CAA1C;AAKA,MAAMC,SAA8D,GAClE,OAAOC,OAAP,KAAmB,WAAnB,GACI,IAAIA,OAAJ,EADJ,GAEI,IAHN;AAKA,OAAO,SAASC,aAAT,CACLC,IADK,EAELpB,eAFK,EAGLC,UAHK,EAIkB;AACvB,QAAMoB,MAAM,GAAGJ,SAAH,aAAGA,SAAH,uBAAGA,SAAS,CAAEK,GAAX,CAAeF,IAAf,CAAf;AACA,MAAIC,MAAJ,EAAY,OAAOA,MAAP;AAEZ,QAAME,GAAG,GAAGH,IAAI,CAACI,MAAL,CAAYC,MAAZ,CAAmBL,IAAI,CAACM,MAAxB,EAAgCC,MAAhC,CACV,CAACC,cAAD,EAAiB7B,WAAjB,KAAiC;AAC/B,UAAM8B,kBAAkB,GAAG,IAAIhC,kBAAJ,CACzBE,WADyB,EAEzBC,eAFyB,EAGzBC,UAHyB,EAIzBX,OAAO,CAAC0B,OAJiB,CAA3B;AAMA,QACEY,cAAc,CAACC,kBAAkB,CAAC3B,OAApB,CAAd,CACE2B,kBAAkB,CAAC1B,oBADrB,MAEM2B,SAHR,EAKE,MAAMC,KAAK,CAAC,kBAAD,CAAX;AACF,WAAO,EACL,GAAGH,cADE;AAEL,OAACC,kBAAkB,CAAC3B,OAApB,GAA8B,EAC5B,GAAG0B,cAAc,CAACC,kBAAkB,CAAC3B,OAApB,CADW;AAE5B,SAAC2B,kBAAkB,CAAC1B,oBAApB,GAA2C0B;AAFf;AAFzB,KAAP;AAOD,GArBS,EAsBV,EAAE,GAAGf;AAAL,GAtBU,CAAZ;AAwBAG,EAAAA,SAAS,SAAT,IAAAA,SAAS,WAAT,YAAAA,SAAS,CAAEe,GAAX,CAAeZ,IAAf,EAAqBG,GAArB;AACA,SAAOA,GAAP;AACD;AAED,OAAO,SAASU,WAAT,CAAqBC,GAArB,EAAqE;AAAA;;AAAA;;AAC1E,QAAMC,KAAK,GAAG3C,WAAW,CACtB4C,KAAD,IAAWA,KAAK,CAACD,KAAN,CAAYE,KADA,CAAzB;AAIA,QAAMC,QAAQ,GAAG7C,oBAAoB,EAArC;AACA,QAAM8C,OAAO,GAAGL,GAAG,iBAAGC,KAAK,CAACD,GAAD,CAAR,+CAAG,WAAYK,OAAf,GAAyB,IAA5C;AACA,QAAMC,kBAAkB,GACtBD,OAAO,IAAID,QAAX,GACIC,OAAO,CAACf,MAAR,CACGC,MADH,CACUc,OAAO,CAACb,MADlB,EAEGH,GAFH,CAEQkB,IAAD,IAAU,CACbA,IAAI,CAAC/B,SADQ,EAEb+B,IAAI,CAACnC,MAAL,CAAY,CAAZ,CAFa,EAGbmC,IAAI,CAACnC,MAAL,CAAY,CAAZ,CAHa,EAIbmC,IAAI,CAAC9B,WAJQ,CAFjB,EAQG+B,IARH,GASGC,MATH,CASWF,IAAD,IAAU,CAAC,CAACA,IATtB,EAUGE,MAVH,CAUWC,OAAD,IAAa,CAACN,QAAQ,CAAChD,OAAO,CAAC0B,OAAT,CAAR,CAA0B4B,OAA1B,CAVxB,EAWGD,MAXH,CAYKC,OAAD,IACE,CAACC,MAAM,CAACC,MAAP,CAAclD,WAAW,CAACU,MAAZ,CAAmBM,MAAjC,EAAyCmC,IAAzC,CACEC,KAAD,IACEA,KAAK,CAACJ,OAAN,CAAcK,WAAd,OAAgCL,OAAO,CAACK,WAAR,EAFnC,CAbP,EAkBGN,MAlBH,CAmBI,CAACO,IAAD,EAAOC,GAAP,EAAYC,IAAZ,KACEA,IAAI,CAACC,SAAL,CACGT,OAAD,IAAaA,OAAO,CAACK,WAAR,OAA0BC,IAAI,CAACD,WAAL,EADzC,MAEME,GAtBZ,CADJ,GAyBI,EA1BN;AA4BAG,EAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmBf,kBAAnB;AAEA,QAAMvC,UAAU,GAAGN,SAAS,CAAC6C,kBAAD,CAA5B;AACA,SAAOjD,OAAO,CAAC,MAAM;AACnB,QACE,CAACgD,OAAD,IACA,CAACD,QADD,IAEA,CAAArC,UAAU,SAAV,IAAAA,UAAU,WAAV,YAAAA,UAAU,CAAEuD,MAAZ,MAAuBhB,kBAAkB,CAACgB,MAH5C,EAKE,OAAO1C,UAAP;;AACF,QAAI;AACF,aAAOK,aAAa,CAACoB,OAAD,EAAUD,QAAV,EAAoBrC,UAApB,aAAoBA,UAApB,cAAoBA,UAApB,GAAkC,EAAlC,CAApB;AACD,KAFD,CAEE,OAAOwD,KAAP,EAAc;AACdH,MAAAA,OAAO,CAACG,KAAR,CAAc,wCAAd,EAAwDA,KAAxD;AACA,aAAO3C,UAAP;AACD;AACF,GAba,EAaX,CAACyB,OAAD,EAAUtC,UAAV,EAAsBuC,kBAAkB,CAACgB,MAAzC,EAAiDlB,QAAjD,CAbW,CAAd;AAcD;;GApDeL,W;UACAzC,W,EAIGC,oB,EAgCEE,S;;;AAiBrB,OAAO,SAAS+D,kBAAT,GAAqD;AAAA;;AAC1D,SAAOzB,WAAW,CAAC0B,OAAO,CAACC,GAAR,CAAYC,kCAAb,CAAlB;AACD,C,CAED;;IAJgBH,kB;UACPzB,W;;;AAIT,OAAO,SAAS6B,WAAT,GAAuC;AAAA;;AAC5C,QAAM3B,KAAK,GAAG3C,WAAW,CACtB4C,KAAD,IAAWA,KAAK,CAACD,KAAN,CAAYE,KADA,CAAzB;AAIA,SAAO9C,OAAO,CACZ,MACEsD,MAAM,CAACkB,IAAP,CAAY5B,KAAZ,EACGZ,GADH,CACQW,GAAD,IAASC,KAAK,CAACD,GAAD,CAAL,CAAWK,OAD3B,EAEGI,MAFH,CAEWqB,CAAD,IAA0BC,OAAO,CAACD,CAAD,CAF3C,CAFU,EAKZ,CAAC7B,KAAD,CALY,CAAd;AAOD;;IAZe2B,W;UACAtE,W","sourcesContent":["import { ChainId } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { AppState } from 'state';\nimport { FarmListInfo, StakingRaw, StakingBasic } from 'types';\nimport { Token } from '@uniswap/sdk';\nimport { TokenAddressMap, useSelectedTokenList } from 'state/lists/hooks';\nimport { getTokenFromAddress } from 'utils';\nimport { useTokens } from 'hooks/Tokens';\nimport { GlobalValue } from 'constants/index';\n\nexport class WrappedStakingInfo implements StakingBasic {\n  public readonly stakingInfo: StakingRaw;\n  public readonly chainId: ChainId;\n  public readonly stakingRewardAddress: string;\n  public readonly pair: string;\n  public readonly rate: number;\n  public readonly tokens: [Token, Token];\n  public readonly ended: boolean;\n  public readonly lp: string;\n  public readonly name: string;\n  public readonly baseToken: Token;\n  public readonly rewardToken: Token;\n\n  constructor(\n    stakingInfo: StakingRaw,\n    tokenAddressMap: TokenAddressMap,\n    farmTokens: Token[],\n    chainId: ChainId,\n  ) {\n    this.stakingInfo = stakingInfo;\n    //TODO: Support Multichain\n    this.chainId = chainId;\n    this.stakingRewardAddress = stakingInfo.stakingRewardAddress;\n    this.rate = stakingInfo.rate;\n    this.ended = stakingInfo.ended;\n    this.pair = stakingInfo.pair;\n    this.lp = stakingInfo.lp;\n    this.name = stakingInfo.name;\n\n    this.baseToken = getTokenFromAddress(\n      stakingInfo.baseToken,\n      chainId,\n      tokenAddressMap,\n      farmTokens,\n    );\n    this.tokens = [\n      getTokenFromAddress(\n        stakingInfo.tokens[0],\n        chainId,\n        tokenAddressMap,\n        farmTokens,\n      ),\n      getTokenFromAddress(\n        stakingInfo.tokens[1],\n        chainId,\n        tokenAddressMap,\n        farmTokens,\n      ),\n    ];\n    this.rewardToken = stakingInfo.rewardToken\n      ? getTokenFromAddress(\n          stakingInfo.rewardToken,\n          chainId,\n          tokenAddressMap,\n          farmTokens,\n        )\n      : GlobalValue.tokens.COMMON.OLD_DQUICK;\n  }\n}\n\nexport type StakingInfoAddressMap = Readonly<\n  {\n    [chainId in ChainId]: Readonly<{\n      [stakingInfoAddress: string]: WrappedStakingInfo;\n    }>;\n  }\n>;\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST: StakingInfoAddressMap = {\n  [ChainId.TESTNET]: {},\n  [ChainId.MAINNET]: {},\n};\n\nconst farmCache: WeakMap<FarmListInfo, StakingInfoAddressMap> | null =\n  typeof WeakMap !== 'undefined'\n    ? new WeakMap<FarmListInfo, StakingInfoAddressMap>()\n    : null;\n\nexport function listToFarmMap(\n  list: FarmListInfo,\n  tokenAddressMap: TokenAddressMap,\n  farmTokens: Token[],\n): StakingInfoAddressMap {\n  const result = farmCache?.get(list);\n  if (result) return result;\n\n  const map = list.active.concat(list.closed).reduce<StakingInfoAddressMap>(\n    (stakingInfoMap, stakingInfo) => {\n      const wrappedStakingInfo = new WrappedStakingInfo(\n        stakingInfo,\n        tokenAddressMap,\n        farmTokens,\n        ChainId.MAINNET,\n      );\n      if (\n        stakingInfoMap[wrappedStakingInfo.chainId][\n          wrappedStakingInfo.stakingRewardAddress\n        ] !== undefined\n      )\n        throw Error('Duplicate farms.');\n      return {\n        ...stakingInfoMap,\n        [wrappedStakingInfo.chainId]: {\n          ...stakingInfoMap[wrappedStakingInfo.chainId],\n          [wrappedStakingInfo.stakingRewardAddress]: wrappedStakingInfo,\n        },\n      };\n    },\n    { ...EMPTY_LIST },\n  );\n  farmCache?.set(list, map);\n  return map;\n}\n\nexport function useFarmList(url: string | undefined): StakingInfoAddressMap {\n  const farms = useSelector<AppState, AppState['farms']['byUrl']>(\n    (state) => state.farms.byUrl,\n  );\n\n  const tokenMap = useSelectedTokenList();\n  const current = url ? farms[url]?.current : null;\n  const farmTokenAddresses =\n    current && tokenMap\n      ? current.active\n          .concat(current.closed)\n          .map((item) => [\n            item.baseToken,\n            item.tokens[0],\n            item.tokens[1],\n            item.rewardToken,\n          ])\n          .flat()\n          .filter((item) => !!item)\n          .filter((address) => !tokenMap[ChainId.MAINNET][address])\n          .filter(\n            (address) =>\n              !Object.values(GlobalValue.tokens.COMMON).find(\n                (token) =>\n                  token.address.toLowerCase() === address.toLowerCase(),\n              ),\n          )\n          .filter(\n            (addr, ind, self) =>\n              self.findIndex(\n                (address) => address.toLowerCase() === addr.toLowerCase(),\n              ) === ind,\n          )\n      : [];\n\n  console.log('bbb', farmTokenAddresses);\n\n  const farmTokens = useTokens(farmTokenAddresses);\n  return useMemo(() => {\n    if (\n      !current ||\n      !tokenMap ||\n      farmTokens?.length !== farmTokenAddresses.length\n    )\n      return EMPTY_LIST;\n    try {\n      return listToFarmMap(current, tokenMap, farmTokens ?? []);\n    } catch (error) {\n      console.error('Could not show token list due to error', error);\n      return EMPTY_LIST;\n    }\n  }, [current, farmTokens, farmTokenAddresses.length, tokenMap]);\n}\n\nexport function useDefaultFarmList(): StakingInfoAddressMap {\n  return useFarmList(process.env.REACT_APP_STAKING_LIST_DEFAULT_URL);\n}\n\n// returns all downloaded current lists\nexport function useAllFarms(): FarmListInfo[] {\n  const farms = useSelector<AppState, AppState['farms']['byUrl']>(\n    (state) => state.farms.byUrl,\n  );\n\n  return useMemo(\n    () =>\n      Object.keys(farms)\n        .map((url) => farms[url].current)\n        .filter((l): l is FarmListInfo => Boolean(l)),\n    [farms],\n  );\n}\n"]},"metadata":{},"sourceType":"module"}