{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from 'hooks';\nimport { useMulticallContract } from 'hooks/useContract';\nimport useDebounce from 'hooks/useDebounce';\nimport { chunkArray } from 'utils/chunkArray';\nimport { retry } from 'utils/retry';\nimport { useBlockNumber } from 'state/application/hooks';\nimport { errorFetchingMulticallResults, fetchingMulticallResults, parseCallKey, updateMulticallResults } from './actions'; // chunk calls so we do not exceed the gas limit\n\nconst CALL_CHUNK_SIZE = 500;\nconst DEFAULT_GAS_REQUIRED = 1000000;\n/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\n\nasync function fetchChunk(multicall, chunk, blockNumber) {\n  console.debug('Fetching chunk', chunk, blockNumber);\n\n  try {\n    const {\n      returnData\n    } = await multicall.callStatic.tryBlockAndAggregate(false, chunk.map(obj => {\n      var _obj$gasRequired;\n\n      return {\n        target: obj.address,\n        callData: obj.callData,\n        gasLimit: (_obj$gasRequired = obj.gasRequired) !== null && _obj$gasRequired !== void 0 ? _obj$gasRequired : 1000000\n      };\n    }), {\n      blockTag: blockNumber\n    });\n\n    if (process.env.NODE_ENV === 'development') {\n      returnData.forEach((_ref, i) => {\n        var _chunk$i$gasRequired;\n\n        let {\n          gasUsed,\n          returnData,\n          success\n        } = _ref;\n\n        if (!success && returnData.length === 2 && gasUsed.gte(Math.floor(((_chunk$i$gasRequired = chunk[i].gasRequired) !== null && _chunk$i$gasRequired !== void 0 ? _chunk$i$gasRequired : DEFAULT_GAS_REQUIRED) * 0.95))) {\n          var _chunk$i$gasRequired2;\n\n          console.warn(`A call failed due to requiring ${gasUsed.toString()} vs. allowed ${(_chunk$i$gasRequired2 = chunk[i].gasRequired) !== null && _chunk$i$gasRequired2 !== void 0 ? _chunk$i$gasRequired2 : DEFAULT_GAS_REQUIRED}`, chunk[i]);\n        }\n      });\n    }\n\n    return returnData;\n  } catch (error) {\n    console.error('Failed to fetch chunk', error);\n    throw error;\n  }\n}\n/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\n\n\nexport function activeListeningKeys(allListeners, chainId) {\n  if (!allListeners || !chainId) return {};\n  const listeners = allListeners[chainId];\n  if (!listeners) return {};\n  return Object.keys(listeners).reduce((memo, callKey) => {\n    const keyListeners = listeners[callKey];\n    memo[callKey] = Object.keys(keyListeners).filter(key => {\n      const blocksPerFetch = parseInt(key);\n      if (blocksPerFetch <= 0) return false;\n      return keyListeners[blocksPerFetch] > 0;\n    }).reduce((previousMin, current) => {\n      return Math.min(previousMin, parseInt(current));\n    }, Infinity);\n    return memo;\n  }, {});\n}\n/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\n\nexport function outdatedListeningKeys(callResults, listeningKeys, chainId, latestBlockNumber) {\n  if (!chainId || !latestBlockNumber) return [];\n  const results = callResults[chainId]; // no results at all, load everything\n\n  if (!results) return Object.keys(listeningKeys);\n  return Object.keys(listeningKeys).filter(callKey => {\n    const blocksPerFetch = listeningKeys[callKey];\n    const data = callResults[chainId][callKey]; // no data, must fetch\n\n    if (!data) return true;\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1); // already fetching it for a recent enough block, don't refetch it\n\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false; // if data is older than minDataBlockNumber, fetch it\n\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber;\n  });\n}\nexport default function Updater() {\n  _s();\n\n  const dispatch = useDispatch();\n  const state = useSelector(state => state.multicall); // wait for listeners to settle before triggering updates\n\n  const debouncedListeners = useDebounce(state.callListeners, 100);\n  const latestBlockNumber = useBlockNumber();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const multicallContract = useMulticallContract();\n  const cancellations = useRef();\n  const listeningKeys = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, chainId);\n  }, [debouncedListeners, chainId]);\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber);\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber]);\n  const serializedOutdatedCallKeys = useMemo(() => JSON.stringify(unserializedOutdatedCallKeys.sort()), [unserializedOutdatedCallKeys]);\n  useEffect(() => {\n    var _cancellations$curren;\n\n    if (!latestBlockNumber || !chainId || !multicallContract) return;\n    const outdatedCallKeys = JSON.parse(serializedOutdatedCallKeys);\n    if (outdatedCallKeys.length === 0) return;\n    const calls = outdatedCallKeys.map(key => parseCallKey(key));\n    const chunkedCalls = chunkArray(calls);\n\n    if (((_cancellations$curren = cancellations.current) === null || _cancellations$curren === void 0 ? void 0 : _cancellations$curren.blockNumber) !== latestBlockNumber) {\n      var _cancellations$curren2, _cancellations$curren3;\n\n      (_cancellations$curren2 = cancellations.current) === null || _cancellations$curren2 === void 0 ? void 0 : (_cancellations$curren3 = _cancellations$curren2.cancellations) === null || _cancellations$curren3 === void 0 ? void 0 : _cancellations$curren3.forEach(c => c());\n    }\n\n    dispatch(fetchingMulticallResults({\n      calls,\n      chainId,\n      fetchingBlockNumber: latestBlockNumber\n    }));\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk, index) => {\n        const {\n          cancel,\n          promise\n        } = retry(() => fetchChunk(multicallContract, chunk, latestBlockNumber), {\n          n: Infinity,\n          minWait: 1000,\n          maxWait: 2500\n        });\n        promise.then(returnData => {\n          // accumulates the length of all previous indices\n          const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce((memo, curr) => memo + curr.length, 0);\n          const lastCallKeyIndex = firstCallKeyIndex + returnData.length;\n          const slice = outdatedCallKeys.slice(firstCallKeyIndex, lastCallKeyIndex); // split the returned slice into errors and success\n\n          const {\n            erroredCalls,\n            results\n          } = slice.reduce((memo, callKey, i) => {\n            if (returnData[i].success) {\n              var _returnData$i$returnD;\n\n              memo.results[callKey] = (_returnData$i$returnD = returnData[i].returnData) !== null && _returnData$i$returnD !== void 0 ? _returnData$i$returnD : null;\n            } else {\n              memo.erroredCalls.push(parseCallKey(callKey));\n            }\n\n            return memo;\n          }, {\n            erroredCalls: [],\n            results: {}\n          }); // dispatch any new results\n\n          if (Object.keys(results).length > 0) dispatch(updateMulticallResults({\n            chainId,\n            results,\n            blockNumber: latestBlockNumber\n          })); // dispatch any errored calls\n\n          if (erroredCalls.length > 0) {\n            console.debug('Calls errored in fetch', erroredCalls);\n            dispatch(errorFetchingMulticallResults({\n              calls: erroredCalls,\n              chainId,\n              fetchingBlockNumber: latestBlockNumber\n            }));\n          }\n        }).catch(error => {\n          if (error.isCancelledError) {\n            console.debug('Cancelled fetch for blockNumber', latestBlockNumber, chunk, chainId);\n            return;\n          }\n\n          console.error('Failed to fetch multicall chunk', chunk, chainId, error);\n          dispatch(errorFetchingMulticallResults({\n            calls: chunk,\n            chainId,\n            fetchingBlockNumber: latestBlockNumber\n          }));\n        });\n        return cancel;\n      })\n    };\n  }, [chainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber]);\n  return null;\n}\n\n_s(Updater, \"xpRD+AhDwmTdNwtyGSlpafZt7S0=\", false, function () {\n  return [useDispatch, useSelector, useDebounce, useBlockNumber, useActiveWeb3React, useMulticallContract];\n});\n\n_c = Updater;\n\nvar _c;\n\n$RefreshReg$(_c, \"Updater\");","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/state/multicall/updater.tsx"],"names":["useEffect","useMemo","useRef","useDispatch","useSelector","useActiveWeb3React","useMulticallContract","useDebounce","chunkArray","retry","useBlockNumber","errorFetchingMulticallResults","fetchingMulticallResults","parseCallKey","updateMulticallResults","CALL_CHUNK_SIZE","DEFAULT_GAS_REQUIRED","fetchChunk","multicall","chunk","blockNumber","console","debug","returnData","callStatic","tryBlockAndAggregate","map","obj","target","address","callData","gasLimit","gasRequired","blockTag","process","env","NODE_ENV","forEach","i","gasUsed","success","length","gte","Math","floor","warn","toString","error","activeListeningKeys","allListeners","chainId","listeners","Object","keys","reduce","memo","callKey","keyListeners","filter","key","blocksPerFetch","parseInt","previousMin","current","min","Infinity","outdatedListeningKeys","callResults","listeningKeys","latestBlockNumber","results","data","minDataBlockNumber","fetchingBlockNumber","Updater","dispatch","state","debouncedListeners","callListeners","multicallContract","cancellations","unserializedOutdatedCallKeys","serializedOutdatedCallKeys","JSON","stringify","sort","outdatedCallKeys","parse","calls","chunkedCalls","c","index","cancel","promise","n","minWait","maxWait","then","firstCallKeyIndex","slice","curr","lastCallKeyIndex","erroredCalls","push","catch","isCancelledError"],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from 'hooks';\nimport { useMulticallContract } from 'hooks/useContract';\nimport useDebounce from 'hooks/useDebounce';\nimport { chunkArray } from 'utils/chunkArray';\nimport { retry } from 'utils/retry';\nimport { useBlockNumber } from 'state/application/hooks';\nimport { AppDispatch, AppState } from 'state';\nimport {\n  Call,\n  errorFetchingMulticallResults,\n  fetchingMulticallResults,\n  parseCallKey,\n  updateMulticallResults,\n} from './actions';\n\n// chunk calls so we do not exceed the gas limit\nconst CALL_CHUNK_SIZE = 500;\nconst DEFAULT_GAS_REQUIRED = 1_000_000;\n\n/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\nasync function fetchChunk(\n  multicall: Contract,\n  chunk: Call[],\n  blockNumber: number,\n): Promise<{ success: boolean; returnData: string }[]> {\n  console.debug('Fetching chunk', chunk, blockNumber);\n  try {\n    const { returnData } = await multicall.callStatic.tryBlockAndAggregate(\n      false,\n      chunk.map((obj) => ({\n        target: obj.address,\n        callData: obj.callData,\n        gasLimit: obj.gasRequired ?? 1_000_000,\n      })),\n      { blockTag: blockNumber },\n    );\n\n    if (process.env.NODE_ENV === 'development') {\n      returnData.forEach(({ gasUsed, returnData, success }: any, i: number) => {\n        if (\n          !success &&\n          returnData.length === 2 &&\n          gasUsed.gte(\n            Math.floor((chunk[i].gasRequired ?? DEFAULT_GAS_REQUIRED) * 0.95),\n          )\n        ) {\n          console.warn(\n            `A call failed due to requiring ${gasUsed.toString()} vs. allowed ${chunk[\n              i\n            ].gasRequired ?? DEFAULT_GAS_REQUIRED}`,\n            chunk[i],\n          );\n        }\n      });\n    }\n\n    return returnData;\n  } catch (error) {\n    console.error('Failed to fetch chunk', error);\n    throw error;\n  }\n}\n\n/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\nexport function activeListeningKeys(\n  allListeners: AppState['multicall']['callListeners'],\n  chainId?: number,\n): { [callKey: string]: number } {\n  if (!allListeners || !chainId) return {};\n  const listeners = allListeners[chainId];\n  if (!listeners) return {};\n\n  return Object.keys(listeners).reduce<{ [callKey: string]: number }>(\n    (memo, callKey) => {\n      const keyListeners = listeners[callKey];\n\n      memo[callKey] = Object.keys(keyListeners)\n        .filter((key) => {\n          const blocksPerFetch = parseInt(key);\n          if (blocksPerFetch <= 0) return false;\n          return keyListeners[blocksPerFetch] > 0;\n        })\n        .reduce((previousMin, current) => {\n          return Math.min(previousMin, parseInt(current));\n        }, Infinity);\n      return memo;\n    },\n    {},\n  );\n}\n\n/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\nexport function outdatedListeningKeys(\n  callResults: AppState['multicall']['callResults'],\n  listeningKeys: { [callKey: string]: number },\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined,\n): string[] {\n  if (!chainId || !latestBlockNumber) return [];\n  const results = callResults[chainId];\n  // no results at all, load everything\n  if (!results) return Object.keys(listeningKeys);\n\n  return Object.keys(listeningKeys).filter((callKey) => {\n    const blocksPerFetch = listeningKeys[callKey];\n\n    const data = callResults[chainId][callKey];\n    // no data, must fetch\n    if (!data) return true;\n\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1);\n\n    // already fetching it for a recent enough block, don't refetch it\n    if (\n      data.fetchingBlockNumber &&\n      data.fetchingBlockNumber >= minDataBlockNumber\n    )\n      return false;\n\n    // if data is older than minDataBlockNumber, fetch it\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber;\n  });\n}\n\nexport default function Updater(): null {\n  const dispatch = useDispatch<AppDispatch>();\n  const state = useSelector<AppState, AppState['multicall']>(\n    (state) => state.multicall,\n  );\n  // wait for listeners to settle before triggering updates\n  const debouncedListeners = useDebounce(state.callListeners, 100);\n  const latestBlockNumber = useBlockNumber();\n  const { chainId } = useActiveWeb3React();\n  const multicallContract = useMulticallContract();\n  const cancellations = useRef<{\n    blockNumber: number;\n    cancellations: (() => void)[];\n  }>();\n\n  const listeningKeys: { [callKey: string]: number } = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, chainId);\n  }, [debouncedListeners, chainId]);\n\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(\n      state.callResults,\n      listeningKeys,\n      chainId,\n      latestBlockNumber,\n    );\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber]);\n\n  const serializedOutdatedCallKeys = useMemo(\n    () => JSON.stringify(unserializedOutdatedCallKeys.sort()),\n    [unserializedOutdatedCallKeys],\n  );\n\n  useEffect(() => {\n    if (!latestBlockNumber || !chainId || !multicallContract) return;\n\n    const outdatedCallKeys: string[] = JSON.parse(serializedOutdatedCallKeys);\n    if (outdatedCallKeys.length === 0) return;\n    const calls = outdatedCallKeys.map((key) => parseCallKey(key));\n\n    const chunkedCalls: Call[][] = chunkArray(calls);\n\n    if (cancellations.current?.blockNumber !== latestBlockNumber) {\n      cancellations.current?.cancellations?.forEach((c) => c());\n    }\n\n    dispatch(\n      fetchingMulticallResults({\n        calls,\n        chainId,\n        fetchingBlockNumber: latestBlockNumber,\n      }),\n    );\n\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk, index) => {\n        const { cancel, promise } = retry(\n          () => fetchChunk(multicallContract, chunk, latestBlockNumber),\n          {\n            n: Infinity,\n            minWait: 1000,\n            maxWait: 2500,\n          },\n        );\n        promise\n          .then((returnData) => {\n            // accumulates the length of all previous indices\n            const firstCallKeyIndex = chunkedCalls\n              .slice(0, index)\n              .reduce<number>((memo, curr) => memo + curr.length, 0);\n            const lastCallKeyIndex = firstCallKeyIndex + returnData.length;\n\n            const slice = outdatedCallKeys.slice(\n              firstCallKeyIndex,\n              lastCallKeyIndex,\n            );\n\n            // split the returned slice into errors and success\n            const { erroredCalls, results } = slice.reduce<{\n              erroredCalls: Call[];\n              results: { [callKey: string]: string | null };\n            }>(\n              (memo, callKey, i) => {\n                if (returnData[i].success) {\n                  memo.results[callKey] = returnData[i].returnData ?? null;\n                } else {\n                  memo.erroredCalls.push(parseCallKey(callKey));\n                }\n                return memo;\n              },\n              { erroredCalls: [], results: {} },\n            );\n\n            // dispatch any new results\n            if (Object.keys(results).length > 0)\n              dispatch(\n                updateMulticallResults({\n                  chainId,\n                  results,\n                  blockNumber: latestBlockNumber,\n                }),\n              );\n\n            // dispatch any errored calls\n            if (erroredCalls.length > 0) {\n              console.debug('Calls errored in fetch', erroredCalls);\n              dispatch(\n                errorFetchingMulticallResults({\n                  calls: erroredCalls,\n                  chainId,\n                  fetchingBlockNumber: latestBlockNumber,\n                }),\n              );\n            }\n          })\n          .catch((error: any) => {\n            if (error.isCancelledError) {\n              console.debug(\n                'Cancelled fetch for blockNumber',\n                latestBlockNumber,\n                chunk,\n                chainId,\n              );\n              return;\n            }\n            console.error(\n              'Failed to fetch multicall chunk',\n              chunk,\n              chainId,\n              error,\n            );\n            dispatch(\n              errorFetchingMulticallResults({\n                calls: chunk,\n                chainId,\n                fetchingBlockNumber: latestBlockNumber,\n              }),\n            );\n          });\n        return cancel;\n      }),\n    };\n  }, [\n    chainId,\n    multicallContract,\n    dispatch,\n    serializedOutdatedCallKeys,\n    latestBlockNumber,\n  ]);\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}