{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$(),\n    _s11 = $RefreshSig$(),\n    _s12 = $RefreshSig$(),\n    _s13 = $RefreshSig$();\n\nimport { Pair, Token } from '@uniswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useCallback, useMemo } from 'react';\nimport { shallowEqual, useDispatch, useSelector } from 'react-redux';\nimport { GlobalData } from 'constants/index';\nimport { useActiveWeb3React } from 'hooks';\nimport { useAllTokens } from 'hooks/Tokens';\nimport { addSerializedPair, addSerializedToken, removeSerializedToken, updateUserDarkMode, updateUserDeadline, updateUserExpertMode, updateUserSlippageTolerance, toggleURLWarning } from './actions';\n\nfunction serializeToken(token) {\n  return {\n    chainId: token.chainId,\n    address: token.address,\n    decimals: token.decimals,\n    symbol: token.symbol,\n    name: token.name\n  };\n}\n\nfunction deserializeToken(serializedToken) {\n  return new Token(serializedToken.chainId, serializedToken.address, serializedToken.decimals, serializedToken.symbol, serializedToken.name);\n}\n\nexport function useIsDarkMode() {\n  _s();\n\n  const {\n    userDarkMode,\n    matchesDarkMode\n  } = useSelector(_ref => {\n    let {\n      user: {\n        matchesDarkMode,\n        userDarkMode\n      }\n    } = _ref;\n    return {\n      userDarkMode,\n      matchesDarkMode\n    };\n  }, shallowEqual);\n  return userDarkMode === null ? matchesDarkMode : userDarkMode;\n}\n\n_s(useIsDarkMode, \"fn6etfcHXfMs02JV/usc15XJU0k=\", false, function () {\n  return [useSelector];\n});\n\nexport function useDarkModeManager() {\n  _s2();\n\n  const dispatch = useDispatch();\n  const darkMode = useIsDarkMode();\n  const toggleSetDarkMode = useCallback(() => {\n    dispatch(updateUserDarkMode({\n      userDarkMode: !darkMode\n    }));\n  }, [darkMode, dispatch]);\n  return [darkMode, toggleSetDarkMode];\n}\n\n_s2(useDarkModeManager, \"C48Gp1zKEL4YakCYKMkkFweY0qg=\", false, function () {\n  return [useDispatch, useIsDarkMode];\n});\n\nexport function useIsExpertMode() {\n  _s3();\n\n  return useSelector(state => state.user.userExpertMode);\n}\n\n_s3(useIsExpertMode, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useExpertModeManager() {\n  _s4();\n\n  const dispatch = useDispatch();\n  const expertMode = useIsExpertMode();\n  const toggleSetExpertMode = useCallback(() => {\n    dispatch(updateUserExpertMode({\n      userExpertMode: !expertMode\n    }));\n  }, [expertMode, dispatch]);\n  return [expertMode, toggleSetExpertMode];\n}\n\n_s4(useExpertModeManager, \"ULLfsmjCcahFerd6rXziokiA+RI=\", false, function () {\n  return [useDispatch, useIsExpertMode];\n});\n\nexport function useUserSlippageTolerance() {\n  _s5();\n\n  const dispatch = useDispatch();\n  const userSlippageTolerance = useSelector(state => {\n    return state.user.userSlippageTolerance;\n  });\n  const setUserSlippageTolerance = useCallback(userSlippageTolerance => {\n    dispatch(updateUserSlippageTolerance({\n      userSlippageTolerance\n    }));\n  }, [dispatch]);\n  return [userSlippageTolerance, setUserSlippageTolerance];\n}\n\n_s5(useUserSlippageTolerance, \"lO9PfBe6MbiNxNv0Q3TS/IyxyIE=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport function useUserTransactionTTL() {\n  _s6();\n\n  const dispatch = useDispatch();\n  const userDeadline = useSelector(state => {\n    return state.user.userDeadline;\n  });\n  const setUserDeadline = useCallback(userDeadline => {\n    dispatch(updateUserDeadline({\n      userDeadline\n    }));\n  }, [dispatch]);\n  return [userDeadline, setUserDeadline];\n}\n\n_s6(useUserTransactionTTL, \"nR4EOlfoy/fKrJpN3ITukwrTqzM=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport function useAddUserToken() {\n  _s7();\n\n  const dispatch = useDispatch();\n  return useCallback(token => {\n    dispatch(addSerializedToken({\n      serializedToken: serializeToken(token)\n    }));\n  }, [dispatch]);\n}\n\n_s7(useAddUserToken, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport function useRemoveUserAddedToken() {\n  _s8();\n\n  const dispatch = useDispatch();\n  return useCallback((chainId, address) => {\n    dispatch(removeSerializedToken({\n      chainId,\n      address\n    }));\n  }, [dispatch]);\n}\n\n_s8(useRemoveUserAddedToken, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport function useUserAddedTokens() {\n  _s9();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const serializedTokensMap = useSelector(_ref2 => {\n    let {\n      user: {\n        tokens\n      }\n    } = _ref2;\n    return tokens;\n  });\n  return useMemo(() => {\n    var _serializedTokensMap;\n\n    if (!chainId) return [];\n    return Object.values((_serializedTokensMap = serializedTokensMap[chainId]) !== null && _serializedTokensMap !== void 0 ? _serializedTokensMap : {}).map(deserializeToken);\n  }, [serializedTokensMap, chainId]);\n}\n\n_s9(useUserAddedTokens, \"PdCPfDsyvt0iyDvIy6GqqMS0G5U=\", false, function () {\n  return [useActiveWeb3React, useSelector];\n});\n\nfunction serializePair(pair) {\n  return {\n    token0: serializeToken(pair.token0),\n    token1: serializeToken(pair.token1)\n  };\n}\n\nexport function usePairAdder() {\n  _s10();\n\n  const dispatch = useDispatch();\n  return useCallback(pair => {\n    dispatch(addSerializedPair({\n      serializedPair: serializePair(pair)\n    }));\n  }, [dispatch]);\n}\n\n_s10(usePairAdder, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport function useURLWarningVisible() {\n  _s11();\n\n  return useSelector(state => state.user.URLWarningVisible);\n}\n\n_s11(useURLWarningVisible, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useURLWarningToggle() {\n  _s12();\n\n  const dispatch = useDispatch();\n  return useCallback(() => dispatch(toggleURLWarning()), [dispatch]);\n}\n/**\n * Given two tokens return the liquidity token that represents its liquidity shares\n * @param tokenA one of the two tokens\n * @param tokenB the other token\n */\n\n_s12(useURLWarningToggle, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport function toV2LiquidityToken(_ref3) {\n  let [tokenA, tokenB] = _ref3;\n  return new Token(tokenA.chainId, Pair.getAddress(tokenA, tokenB), 18, 'QUICK-V2', 'Quickswap V2');\n}\n/**\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\n */\n\nexport function useTrackedTokenPairs() {\n  _s13();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens(); // pinned pairs\n\n  const pinnedPairs = useMemo(() => {\n    var _GlobalData$pairs$PIN;\n\n    return chainId ? (_GlobalData$pairs$PIN = GlobalData.pairs.PINNED_PAIRS[chainId]) !== null && _GlobalData$pairs$PIN !== void 0 ? _GlobalData$pairs$PIN : [] : [];\n  }, [chainId]); // pairs for every token against every base\n\n  const generatedPairs = useMemo(() => chainId ? flatMap(Object.keys(tokens), tokenAddress => {\n    var _GlobalData$bases$BAS;\n\n    const token = tokens[tokenAddress]; // for each token on the current chain,\n\n    return (// loop though all bases on the current chain\n      ((_GlobalData$bases$BAS = GlobalData.bases.BASES_TO_TRACK_LIQUIDITY_FOR[chainId]) !== null && _GlobalData$bases$BAS !== void 0 ? _GlobalData$bases$BAS : [] // to construct pairs of the given token with each base\n      ).map(base => {\n        if (base.address === token.address) {\n          return null;\n        } else {\n          return [base, token];\n        }\n      }).filter(p => p !== null)\n    );\n  }) : [], [tokens, chainId]); // pairs saved by users\n\n  const savedSerializedPairs = useSelector(_ref4 => {\n    let {\n      user: {\n        pairs\n      }\n    } = _ref4;\n    return pairs;\n  });\n  const userPairs = useMemo(() => {\n    if (!chainId || !savedSerializedPairs) return [];\n    const forChain = savedSerializedPairs[chainId];\n    if (!forChain) return [];\n    return Object.keys(forChain).map(pairId => {\n      return [deserializeToken(forChain[pairId].token0), deserializeToken(forChain[pairId].token1)];\n    });\n  }, [savedSerializedPairs, chainId]);\n  const combinedList = useMemo(() => userPairs.concat(generatedPairs).concat(pinnedPairs), [generatedPairs, pinnedPairs, userPairs]);\n  return useMemo(() => {\n    // dedupes pairs of tokens in the combined list\n    const keyed = combinedList.reduce((memo, _ref5) => {\n      let [tokenA, tokenB] = _ref5;\n      const sorted = tokenA.sortsBefore(tokenB);\n      const key = sorted ? `${tokenA.address}:${tokenB.address}` : `${tokenB.address}:${tokenA.address}`;\n      if (memo[key]) return memo;\n      memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA];\n      return memo;\n    }, {});\n    return Object.keys(keyed).map(key => keyed[key]);\n  }, [combinedList]);\n}\n\n_s13(useTrackedTokenPairs, \"4WvQKsnbAvHqSWC76PIctKFHZzA=\", false, function () {\n  return [useActiveWeb3React, useAllTokens, useSelector];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/state/user/hooks.tsx"],"names":["Pair","Token","flatMap","useCallback","useMemo","shallowEqual","useDispatch","useSelector","GlobalData","useActiveWeb3React","useAllTokens","addSerializedPair","addSerializedToken","removeSerializedToken","updateUserDarkMode","updateUserDeadline","updateUserExpertMode","updateUserSlippageTolerance","toggleURLWarning","serializeToken","token","chainId","address","decimals","symbol","name","deserializeToken","serializedToken","useIsDarkMode","userDarkMode","matchesDarkMode","user","useDarkModeManager","dispatch","darkMode","toggleSetDarkMode","useIsExpertMode","state","userExpertMode","useExpertModeManager","expertMode","toggleSetExpertMode","useUserSlippageTolerance","userSlippageTolerance","setUserSlippageTolerance","useUserTransactionTTL","userDeadline","setUserDeadline","useAddUserToken","useRemoveUserAddedToken","useUserAddedTokens","serializedTokensMap","tokens","Object","values","map","serializePair","pair","token0","token1","usePairAdder","serializedPair","useURLWarningVisible","URLWarningVisible","useURLWarningToggle","toV2LiquidityToken","tokenA","tokenB","getAddress","useTrackedTokenPairs","pinnedPairs","pairs","PINNED_PAIRS","generatedPairs","keys","tokenAddress","bases","BASES_TO_TRACK_LIQUIDITY_FOR","base","filter","p","savedSerializedPairs","userPairs","forChain","pairId","combinedList","concat","keyed","reduce","memo","sorted","sortsBefore","key"],"mappings":"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","sourcesContent":["import { ChainId, Pair, Token } from '@uniswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useCallback, useMemo } from 'react';\nimport { shallowEqual, useDispatch, useSelector } from 'react-redux';\nimport { GlobalData } from 'constants/index';\n\nimport { useActiveWeb3React } from 'hooks';\nimport { useAllTokens } from 'hooks/Tokens';\nimport { AppDispatch, AppState } from 'state';\nimport {\n  addSerializedPair,\n  addSerializedToken,\n  removeSerializedToken,\n  SerializedPair,\n  SerializedToken,\n  updateUserDarkMode,\n  updateUserDeadline,\n  updateUserExpertMode,\n  updateUserSlippageTolerance,\n  toggleURLWarning,\n} from './actions';\n\nfunction serializeToken(token: Token): SerializedToken {\n  return {\n    chainId: token.chainId,\n    address: token.address,\n    decimals: token.decimals,\n    symbol: token.symbol,\n    name: token.name,\n  };\n}\n\nfunction deserializeToken(serializedToken: SerializedToken): Token {\n  return new Token(\n    serializedToken.chainId,\n    serializedToken.address,\n    serializedToken.decimals,\n    serializedToken.symbol,\n    serializedToken.name,\n  );\n}\n\nexport function useIsDarkMode(): boolean {\n  const { userDarkMode, matchesDarkMode } = useSelector<\n    AppState,\n    { userDarkMode: boolean | null; matchesDarkMode: boolean }\n  >(\n    ({ user: { matchesDarkMode, userDarkMode } }) => ({\n      userDarkMode,\n      matchesDarkMode,\n    }),\n    shallowEqual,\n  );\n\n  return userDarkMode === null ? matchesDarkMode : userDarkMode;\n}\n\nexport function useDarkModeManager(): [boolean, () => void] {\n  const dispatch = useDispatch<AppDispatch>();\n  const darkMode = useIsDarkMode();\n\n  const toggleSetDarkMode = useCallback(() => {\n    dispatch(updateUserDarkMode({ userDarkMode: !darkMode }));\n  }, [darkMode, dispatch]);\n\n  return [darkMode, toggleSetDarkMode];\n}\n\nexport function useIsExpertMode(): boolean {\n  return useSelector<AppState, AppState['user']['userExpertMode']>(\n    (state) => state.user.userExpertMode,\n  );\n}\n\nexport function useExpertModeManager(): [boolean, () => void] {\n  const dispatch = useDispatch<AppDispatch>();\n  const expertMode = useIsExpertMode();\n\n  const toggleSetExpertMode = useCallback(() => {\n    dispatch(updateUserExpertMode({ userExpertMode: !expertMode }));\n  }, [expertMode, dispatch]);\n\n  return [expertMode, toggleSetExpertMode];\n}\n\nexport function useUserSlippageTolerance(): [\n  number,\n  (slippage: number) => void,\n] {\n  const dispatch = useDispatch<AppDispatch>();\n  const userSlippageTolerance = useSelector<\n    AppState,\n    AppState['user']['userSlippageTolerance']\n  >((state) => {\n    return state.user.userSlippageTolerance;\n  });\n\n  const setUserSlippageTolerance = useCallback(\n    (userSlippageTolerance: number) => {\n      dispatch(updateUserSlippageTolerance({ userSlippageTolerance }));\n    },\n    [dispatch],\n  );\n\n  return [userSlippageTolerance, setUserSlippageTolerance];\n}\n\nexport function useUserTransactionTTL(): [number, (slippage: number) => void] {\n  const dispatch = useDispatch<AppDispatch>();\n  const userDeadline = useSelector<AppState, AppState['user']['userDeadline']>(\n    (state) => {\n      return state.user.userDeadline;\n    },\n  );\n\n  const setUserDeadline = useCallback(\n    (userDeadline: number) => {\n      dispatch(updateUserDeadline({ userDeadline }));\n    },\n    [dispatch],\n  );\n\n  return [userDeadline, setUserDeadline];\n}\n\nexport function useAddUserToken(): (token: Token) => void {\n  const dispatch = useDispatch<AppDispatch>();\n  return useCallback(\n    (token: Token) => {\n      dispatch(addSerializedToken({ serializedToken: serializeToken(token) }));\n    },\n    [dispatch],\n  );\n}\n\nexport function useRemoveUserAddedToken(): (\n  chainId: number,\n  address: string,\n) => void {\n  const dispatch = useDispatch<AppDispatch>();\n  return useCallback(\n    (chainId: number, address: string) => {\n      dispatch(removeSerializedToken({ chainId, address }));\n    },\n    [dispatch],\n  );\n}\n\nexport function useUserAddedTokens(): Token[] {\n  const { chainId } = useActiveWeb3React();\n  const serializedTokensMap = useSelector<AppState, AppState['user']['tokens']>(\n    ({ user: { tokens } }) => tokens,\n  );\n\n  return useMemo(() => {\n    if (!chainId) return [];\n    return Object.values(serializedTokensMap[chainId as ChainId] ?? {}).map(\n      deserializeToken,\n    );\n  }, [serializedTokensMap, chainId]);\n}\n\nfunction serializePair(pair: Pair): SerializedPair {\n  return {\n    token0: serializeToken(pair.token0),\n    token1: serializeToken(pair.token1),\n  };\n}\n\nexport function usePairAdder(): (pair: Pair) => void {\n  const dispatch = useDispatch<AppDispatch>();\n\n  return useCallback(\n    (pair: Pair) => {\n      dispatch(addSerializedPair({ serializedPair: serializePair(pair) }));\n    },\n    [dispatch],\n  );\n}\n\nexport function useURLWarningVisible(): boolean {\n  return useSelector((state: AppState) => state.user.URLWarningVisible);\n}\n\nexport function useURLWarningToggle(): () => void {\n  const dispatch = useDispatch();\n  return useCallback(() => dispatch(toggleURLWarning()), [dispatch]);\n}\n\n/**\n * Given two tokens return the liquidity token that represents its liquidity shares\n * @param tokenA one of the two tokens\n * @param tokenB the other token\n */\nexport function toV2LiquidityToken([tokenA, tokenB]: [Token, Token]): Token {\n  return new Token(\n    tokenA.chainId,\n    Pair.getAddress(tokenA, tokenB),\n    18,\n    'QUICK-V2',\n    'Quickswap V2',\n  );\n}\n\n/**\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\n */\nexport function useTrackedTokenPairs(): [Token, Token][] {\n  const { chainId } = useActiveWeb3React();\n  const tokens = useAllTokens();\n\n  // pinned pairs\n  const pinnedPairs = useMemo(\n    () => (chainId ? GlobalData.pairs.PINNED_PAIRS[chainId] ?? [] : []),\n    [chainId],\n  ) as [Token, Token][];\n\n  // pairs for every token against every base\n  const generatedPairs: [Token, Token][] = useMemo(\n    () =>\n      chainId\n        ? flatMap(Object.keys(tokens), (tokenAddress) => {\n            const token = tokens[tokenAddress];\n            // for each token on the current chain,\n            return (\n              // loop though all bases on the current chain\n              (GlobalData.bases.BASES_TO_TRACK_LIQUIDITY_FOR[chainId] ?? [])\n                // to construct pairs of the given token with each base\n                .map((base) => {\n                  if (base.address === token.address) {\n                    return null;\n                  } else {\n                    return [base, token];\n                  }\n                })\n                .filter((p): p is [Token, Token] => p !== null)\n            );\n          })\n        : [],\n    [tokens, chainId],\n  );\n\n  // pairs saved by users\n  const savedSerializedPairs = useSelector<AppState, AppState['user']['pairs']>(\n    ({ user: { pairs } }) => pairs,\n  );\n\n  const userPairs: [Token, Token][] = useMemo(() => {\n    if (!chainId || !savedSerializedPairs) return [];\n    const forChain = savedSerializedPairs[chainId];\n    if (!forChain) return [];\n\n    return Object.keys(forChain).map((pairId) => {\n      return [\n        deserializeToken(forChain[pairId].token0),\n        deserializeToken(forChain[pairId].token1),\n      ];\n    });\n  }, [savedSerializedPairs, chainId]);\n\n  const combinedList = useMemo(\n    () => userPairs.concat(generatedPairs).concat(pinnedPairs),\n    [generatedPairs, pinnedPairs, userPairs],\n  );\n\n  return useMemo(() => {\n    // dedupes pairs of tokens in the combined list\n    const keyed = combinedList.reduce<{ [key: string]: [Token, Token] }>(\n      (memo, [tokenA, tokenB]) => {\n        const sorted = tokenA.sortsBefore(tokenB);\n        const key = sorted\n          ? `${tokenA.address}:${tokenB.address}`\n          : `${tokenB.address}:${tokenA.address}`;\n        if (memo[key]) return memo;\n        memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA];\n        return memo;\n      },\n      {},\n    );\n\n    return Object.keys(keyed).map((key) => keyed[key]);\n  }, [combinedList]);\n}\n"]},"metadata":{},"sourceType":"module"}