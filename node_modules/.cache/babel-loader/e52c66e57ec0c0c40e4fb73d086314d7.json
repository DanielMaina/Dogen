{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArkaneWalletSubProvider = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar arkane_connect_1 = require(\"@arkane-network/arkane-connect\");\n\nvar base_wallet_subprovider_1 = require(\"@0x/subproviders/lib/src/subproviders/base_wallet_subprovider\");\n\nvar ArkaneWalletSubProvider =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ArkaneWalletSubProvider, _super);\n\n  function ArkaneWalletSubProvider(options) {\n    var _this = _super.call(this) || this;\n\n    _this.wallets = [];\n    _this.authenticated = false;\n    var connectConstructorOptions = {\n      environment: options.environment || 'production',\n      bearerTokenProvider: options.bearerTokenProvider\n    };\n\n    if (options.signMethod) {\n      Object.assign(connectConstructorOptions, {\n        signUsing: options.signMethod == 'POPUP' ? arkane_connect_1.SignMethod.POPUP : arkane_connect_1.SignMethod.REDIRECT\n      });\n    }\n\n    if (options.windowMode) {\n      Object.assign(connectConstructorOptions, {\n        windowMode: options.windowMode == 'POPUP' ? arkane_connect_1.WindowMode.POPUP : arkane_connect_1.WindowMode.REDIRECT\n      });\n    }\n\n    _this.arkaneConnect = new arkane_connect_1.ArkaneConnect(options.clientId, connectConstructorOptions);\n    _this.options = options;\n    return _this;\n  }\n\n  ArkaneWalletSubProvider.prototype.startGetAccountFlow = function (authenticationOptions) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var that;\n\n      var _this = this;\n\n      return tslib_1.__generator(this, function (_a) {\n        if (authenticationOptions) {\n          this.options.authenticationOptions = authenticationOptions;\n        }\n\n        that = this;\n        return [2\n        /*return*/\n        , this.arkaneConnect.flows.getAccount(this.options.secretType || arkane_connect_1.SecretType.ETHEREUM, this.options.authenticationOptions).then(function (account) {\n          return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4\n                  /*yield*/\n                  , new Promise(function (resolve, reject) {\n                    if (!account.isAuthenticated) {\n                      reject('not-authenticated');\n                    } else if (account.wallets && account.wallets.length <= 0) {\n                      reject('no-wallet-linked');\n                    } else {\n                      that.authenticated = true;\n                      that.wallets = account.wallets;\n                      that.lastWalletsFetch = Date.now();\n                      resolve(account);\n                    }\n                  })];\n\n                case 1:\n                  return [2\n                  /*return*/\n                  , _a.sent()];\n              }\n            });\n          });\n        })];\n      });\n    });\n  };\n\n  ArkaneWalletSubProvider.prototype.refreshWallets = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var newWallets, account;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.arkaneConnect.api.getWallets({\n              secretType: this.options.secretType || arkane_connect_1.SecretType.ETHEREUM,\n              includeBalance: false\n            })];\n\n          case 1:\n            newWallets = _a.sent();\n            if (!(!newWallets || newWallets.length < 1)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.arkaneConnect.flows.getAccount(this.options.secretType || arkane_connect_1.SecretType.ETHEREUM, this.options.authenticationOptions)];\n\n          case 2:\n            account = _a.sent();\n            newWallets = account.wallets;\n            _a.label = 3;\n\n          case 3:\n            this.wallets = newWallets;\n            return [2\n            /*return*/\n            , newWallets];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve the accounts associated with the eth-lightwallet instance.\n   * This method is implicitly called when issuing a `eth_accounts` JSON RPC request\n   * via your providerEngine instance.\n   *\n   * @return An array of accounts\n   */\n\n\n  ArkaneWalletSubProvider.prototype.getAccountsAsync = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var that, promise;\n\n      var _this = this;\n\n      return tslib_1.__generator(this, function (_a) {\n        that = this;\n\n        if (!this.authenticated) {\n          promise = this.startGetAccountFlow();\n        } else if (this.shouldRefreshWallets()) {\n          this.lastWalletsFetch = Date.now();\n          promise = this.refreshWallets();\n        } else {\n          promise = Promise.resolve();\n        }\n\n        return [2\n        /*return*/\n        , promise.then(function () {\n          return _this.wallets.map(function (wallet) {\n            return wallet.address;\n          });\n        })];\n      });\n    });\n  };\n\n  ArkaneWalletSubProvider.prototype.shouldRefreshWallets = function () {\n    return !this.lastWalletsFetch || Date.now() - this.lastWalletsFetch > 5000;\n  };\n\n  ArkaneWalletSubProvider.prototype.checkAuthenticated = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.arkaneConnect.checkAuthenticated().then(function (authResult) {\n          _this.authenticated = authResult.isAuthenticated;\n          return authResult;\n        })];\n      });\n    });\n  };\n  /**\n   * Signs a transaction with the account specificed by the `from` field in txParams.\n   * If you've added this Subprovider to your app's provider, you can simply send\n   * an `eth_sendTransaction` JSON RPC request, and this method will be called auto-magically.\n   * If you are not using this via a ProviderEngine instance, you can call it directly.\n   * @param txParams Parameters of the transaction to sign\n   * @return Signed transaction hex string\n   */\n\n\n  ArkaneWalletSubProvider.prototype.signTransactionAsync = function (txParams) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var signer;\n      return tslib_1.__generator(this, function (_a) {\n        signer = this.arkaneConnect.createSigner();\n        return [2\n        /*return*/\n        , signer.signTransaction(this.constructEthereumTransationSignatureRequest(txParams)).then(function (result) {\n          if (result.status === 'SUCCESS') {\n            return result.result.signedTransaction;\n          } else {\n            throw new Error(result.errors && result.errors.join(\", \"));\n          }\n        })];\n      });\n    });\n  };\n\n  ArkaneWalletSubProvider.prototype.constructEthereumTransationSignatureRequest = function (txParams) {\n    var type = arkane_connect_1.SignatureRequestType.ETHEREUM_TRANSACTION;\n\n    if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.ETHEREUM) {\n      type = arkane_connect_1.SignatureRequestType.ETHEREUM_TRANSACTION;\n    } else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.MATIC) {\n      type = arkane_connect_1.SignatureRequestType.MATIC_TRANSACTION;\n    } else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.BSC) {\n      type = arkane_connect_1.SignatureRequestType.BSC_TRANSACTION;\n    } else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.AVAC) {\n      type = arkane_connect_1.SignatureRequestType.AVAC_TRANSACTION;\n    }\n\n    var retVal = {\n      gasPrice: txParams.gasPrice ? BigInt(txParams.gasPrice).toString(10) : txParams.gasPrice,\n      gas: txParams.gas ? BigInt(txParams.gas).toString(10) : txParams.gas,\n      to: txParams.to,\n      nonce: txParams.nonce ? BigInt(txParams.nonce).toString(10) : txParams.nonce,\n      data: txParams.data || '0x',\n      value: txParams.value ? BigInt(txParams.value).toString(10) : \"0\",\n      submit: false,\n      type: type,\n      walletId: this.getWalletIdFrom(txParams.from)\n    };\n    return retVal;\n  };\n  /**\n   * Sign a personal Ethereum signed message. The signing account will be the account\n   * associated with the provided address.\n   * If you've added this Subprovider to your app's provider, you can simply send an `eth_sign`\n   * or `personal_sign` JSON RPC request, and this method will be called auto-magically.\n   * If you are not using this via a ProviderEngine instance, you can call it directly.\n   * @param data Hex string message to sign\n   * @param address Address of the account to sign with\n   * @return Signature hex string (order: rsv)\n   */\n\n\n  ArkaneWalletSubProvider.prototype.signPersonalMessageAsync = function (data, address) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var signer, type;\n      return tslib_1.__generator(this, function (_a) {\n        signer = this.arkaneConnect.createSigner();\n        type = arkane_connect_1.SignatureRequestType.ETHEREUM_RAW;\n\n        if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.ETHEREUM) {\n          type = arkane_connect_1.SignatureRequestType.ETHEREUM_RAW;\n        } else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.MATIC) {\n          type = arkane_connect_1.SignatureRequestType.MATIC_RAW;\n        } else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.BSC) {\n          type = arkane_connect_1.SignatureRequestType.BSC_RAW;\n        } else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.AVAC) {\n          type = arkane_connect_1.SignatureRequestType.AVAC_RAW;\n        }\n\n        return [2\n        /*return*/\n        , signer.signTransaction({\n          type: type,\n          walletId: this.getWalletIdFrom(address),\n          data: data\n        }).then(function (result) {\n          if (result.status === 'SUCCESS') {\n            return result.result.signature;\n          } else {\n            throw new Error(result.errors && result.errors.join(\", \"));\n          }\n        })];\n      });\n    });\n  };\n  /**\n   * Sign an EIP712 Typed Data message. The signing address will associated with the provided address.\n   * If you've added this Subprovider to your app's provider, you can simply send an `eth_signTypedData`\n   * JSON RPC request, and this method will be called auto-magically.\n   * If you are not using this via a ProviderEngine instance, you can call it directly.\n   * @param address Address of the account to sign with\n   * @param data the typed data object\n   * @return Signature hex string (order: rsv)\n   */\n\n\n  ArkaneWalletSubProvider.prototype.signTypedDataAsync = function (address, typedData) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var signer, request;\n      return tslib_1.__generator(this, function (_a) {\n        signer = this.arkaneConnect.createSigner();\n\n        if (typeof typedData === 'string') {\n          typedData = JSON.parse(typedData);\n        }\n\n        request = {\n          data: typedData,\n          walletId: this.getWalletIdFrom(address),\n          secretType: this.options.secretType || arkane_connect_1.SecretType.ETHEREUM\n        };\n        return [2\n        /*return*/\n        , signer.signEip712(request).then(function (result) {\n          if (result.status === 'SUCCESS') {\n            return result.result.signature;\n          } else {\n            throw new Error(result.errors && result.errors.join(\", \"));\n          }\n        })];\n      });\n    });\n  };\n\n  ArkaneWalletSubProvider.prototype.getWalletIdFrom = function (address) {\n    var foundWallet = this.wallets.find(function (wallet) {\n      return wallet.address.toLowerCase() === address.toLowerCase();\n    });\n    return foundWallet && foundWallet.id || '';\n  };\n\n  return ArkaneWalletSubProvider;\n}(base_wallet_subprovider_1.BaseWalletSubprovider);\n\nexports.ArkaneWalletSubProvider = ArkaneWalletSubProvider;","map":{"version":3,"sources":["../../src/ArkaneWalletSubProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArkaneWalletSubProvider = void 0;\nvar tslib_1 = require(\"tslib\");\nvar arkane_connect_1 = require(\"@arkane-network/arkane-connect\");\nvar base_wallet_subprovider_1 = require(\"@0x/subproviders/lib/src/subproviders/base_wallet_subprovider\");\nvar ArkaneWalletSubProvider = /** @class */ (function (_super) {\n    tslib_1.__extends(ArkaneWalletSubProvider, _super);\n    function ArkaneWalletSubProvider(options) {\n        var _this = _super.call(this) || this;\n        _this.wallets = [];\n        _this.authenticated = false;\n        var connectConstructorOptions = {\n            environment: options.environment || 'production',\n            bearerTokenProvider: options.bearerTokenProvider,\n        };\n        if (options.signMethod) {\n            Object.assign(connectConstructorOptions, { signUsing: options.signMethod == 'POPUP' ? arkane_connect_1.SignMethod.POPUP : arkane_connect_1.SignMethod.REDIRECT });\n        }\n        if (options.windowMode) {\n            Object.assign(connectConstructorOptions, { windowMode: options.windowMode == 'POPUP' ? arkane_connect_1.WindowMode.POPUP : arkane_connect_1.WindowMode.REDIRECT });\n        }\n        _this.arkaneConnect = new arkane_connect_1.ArkaneConnect(options.clientId, connectConstructorOptions);\n        _this.options = options;\n        return _this;\n    }\n    ArkaneWalletSubProvider.prototype.startGetAccountFlow = function (authenticationOptions) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var that;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                if (authenticationOptions) {\n                    this.options.authenticationOptions = authenticationOptions;\n                }\n                that = this;\n                return [2 /*return*/, this.arkaneConnect.flows.getAccount(this.options.secretType || arkane_connect_1.SecretType.ETHEREUM, this.options.authenticationOptions)\n                        .then(function (account) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                        return tslib_1.__generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                        if (!account.isAuthenticated) {\n                                            reject('not-authenticated');\n                                        }\n                                        else if (account.wallets && account.wallets.length <= 0) {\n                                            reject('no-wallet-linked');\n                                        }\n                                        else {\n                                            that.authenticated = true;\n                                            that.wallets = account.wallets;\n                                            that.lastWalletsFetch = Date.now();\n                                            resolve(account);\n                                        }\n                                    })];\n                                case 1: return [2 /*return*/, _a.sent()];\n                            }\n                        });\n                    }); })];\n            });\n        });\n    };\n    ArkaneWalletSubProvider.prototype.refreshWallets = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var newWallets, account;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.arkaneConnect.api.getWallets({ secretType: this.options.secretType || arkane_connect_1.SecretType.ETHEREUM, includeBalance: false })];\n                    case 1:\n                        newWallets = _a.sent();\n                        if (!(!newWallets || newWallets.length < 1)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.arkaneConnect.flows.getAccount(this.options.secretType || arkane_connect_1.SecretType.ETHEREUM, this.options.authenticationOptions)];\n                    case 2:\n                        account = _a.sent();\n                        newWallets = account.wallets;\n                        _a.label = 3;\n                    case 3:\n                        this.wallets = newWallets;\n                        return [2 /*return*/, newWallets];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieve the accounts associated with the eth-lightwallet instance.\n     * This method is implicitly called when issuing a `eth_accounts` JSON RPC request\n     * via your providerEngine instance.\n     *\n     * @return An array of accounts\n     */\n    ArkaneWalletSubProvider.prototype.getAccountsAsync = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var that, promise;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                that = this;\n                if (!this.authenticated) {\n                    promise = this.startGetAccountFlow();\n                }\n                else if (this.shouldRefreshWallets()) {\n                    this.lastWalletsFetch = Date.now();\n                    promise = this.refreshWallets();\n                }\n                else {\n                    promise = Promise.resolve();\n                }\n                return [2 /*return*/, promise.then(function () {\n                        return _this.wallets.map(function (wallet) { return wallet.address; });\n                    })];\n            });\n        });\n    };\n    ArkaneWalletSubProvider.prototype.shouldRefreshWallets = function () {\n        return !this.lastWalletsFetch\n            || (Date.now() - this.lastWalletsFetch) > 5000;\n    };\n    ArkaneWalletSubProvider.prototype.checkAuthenticated = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                return [2 /*return*/, this.arkaneConnect.checkAuthenticated().then(function (authResult) {\n                        _this.authenticated = authResult.isAuthenticated;\n                        return authResult;\n                    })];\n            });\n        });\n    };\n    /**\n     * Signs a transaction with the account specificed by the `from` field in txParams.\n     * If you've added this Subprovider to your app's provider, you can simply send\n     * an `eth_sendTransaction` JSON RPC request, and this method will be called auto-magically.\n     * If you are not using this via a ProviderEngine instance, you can call it directly.\n     * @param txParams Parameters of the transaction to sign\n     * @return Signed transaction hex string\n     */\n    ArkaneWalletSubProvider.prototype.signTransactionAsync = function (txParams) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var signer;\n            return tslib_1.__generator(this, function (_a) {\n                signer = this.arkaneConnect.createSigner();\n                return [2 /*return*/, signer.signTransaction(this.constructEthereumTransationSignatureRequest(txParams))\n                        .then(function (result) {\n                        if (result.status === 'SUCCESS') {\n                            return result.result.signedTransaction;\n                        }\n                        else {\n                            throw new Error((result.errors && result.errors.join(\", \")));\n                        }\n                    })];\n            });\n        });\n    };\n    ArkaneWalletSubProvider.prototype.constructEthereumTransationSignatureRequest = function (txParams) {\n        var type = arkane_connect_1.SignatureRequestType.ETHEREUM_TRANSACTION;\n        if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.ETHEREUM) {\n            type = arkane_connect_1.SignatureRequestType.ETHEREUM_TRANSACTION;\n        }\n        else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.MATIC) {\n            type = arkane_connect_1.SignatureRequestType.MATIC_TRANSACTION;\n        }\n        else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.BSC) {\n            type = arkane_connect_1.SignatureRequestType.BSC_TRANSACTION;\n        }\n        else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.AVAC) {\n            type = arkane_connect_1.SignatureRequestType.AVAC_TRANSACTION;\n        }\n        var retVal = {\n            gasPrice: txParams.gasPrice ? BigInt(txParams.gasPrice).toString(10) : txParams.gasPrice,\n            gas: txParams.gas ? BigInt(txParams.gas).toString(10) : txParams.gas,\n            to: txParams.to,\n            nonce: txParams.nonce ? BigInt(txParams.nonce).toString(10) : txParams.nonce,\n            data: (txParams.data) || '0x',\n            value: txParams.value ? BigInt(txParams.value).toString(10) : \"0\",\n            submit: false,\n            type: type,\n            walletId: this.getWalletIdFrom(txParams.from),\n        };\n        return retVal;\n    };\n    /**\n     * Sign a personal Ethereum signed message. The signing account will be the account\n     * associated with the provided address.\n     * If you've added this Subprovider to your app's provider, you can simply send an `eth_sign`\n     * or `personal_sign` JSON RPC request, and this method will be called auto-magically.\n     * If you are not using this via a ProviderEngine instance, you can call it directly.\n     * @param data Hex string message to sign\n     * @param address Address of the account to sign with\n     * @return Signature hex string (order: rsv)\n     */\n    ArkaneWalletSubProvider.prototype.signPersonalMessageAsync = function (data, address) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var signer, type;\n            return tslib_1.__generator(this, function (_a) {\n                signer = this.arkaneConnect.createSigner();\n                type = arkane_connect_1.SignatureRequestType.ETHEREUM_RAW;\n                if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.ETHEREUM) {\n                    type = arkane_connect_1.SignatureRequestType.ETHEREUM_RAW;\n                }\n                else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.MATIC) {\n                    type = arkane_connect_1.SignatureRequestType.MATIC_RAW;\n                }\n                else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.BSC) {\n                    type = arkane_connect_1.SignatureRequestType.BSC_RAW;\n                }\n                else if (this.options.secretType && this.options.secretType == arkane_connect_1.SecretType.AVAC) {\n                    type = arkane_connect_1.SignatureRequestType.AVAC_RAW;\n                }\n                return [2 /*return*/, signer.signTransaction({\n                        type: type,\n                        walletId: this.getWalletIdFrom(address),\n                        data: data\n                    })\n                        .then(function (result) {\n                        if (result.status === 'SUCCESS') {\n                            return result.result.signature;\n                        }\n                        else {\n                            throw new Error((result.errors && result.errors.join(\", \")));\n                        }\n                    })];\n            });\n        });\n    };\n    /**\n     * Sign an EIP712 Typed Data message. The signing address will associated with the provided address.\n     * If you've added this Subprovider to your app's provider, you can simply send an `eth_signTypedData`\n     * JSON RPC request, and this method will be called auto-magically.\n     * If you are not using this via a ProviderEngine instance, you can call it directly.\n     * @param address Address of the account to sign with\n     * @param data the typed data object\n     * @return Signature hex string (order: rsv)\n     */\n    ArkaneWalletSubProvider.prototype.signTypedDataAsync = function (address, typedData) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var signer, request;\n            return tslib_1.__generator(this, function (_a) {\n                signer = this.arkaneConnect.createSigner();\n                if (typeof typedData === 'string') {\n                    typedData = JSON.parse(typedData);\n                }\n                request = {\n                    data: typedData,\n                    walletId: this.getWalletIdFrom(address),\n                    secretType: this.options.secretType || arkane_connect_1.SecretType.ETHEREUM\n                };\n                return [2 /*return*/, signer.signEip712(request)\n                        .then(function (result) {\n                        if (result.status === 'SUCCESS') {\n                            return result.result.signature;\n                        }\n                        else {\n                            throw new Error((result.errors && result.errors.join(\", \")));\n                        }\n                    })];\n            });\n        });\n    };\n    ArkaneWalletSubProvider.prototype.getWalletIdFrom = function (address) {\n        var foundWallet = this.wallets.find(function (wallet) {\n            return wallet.address.toLowerCase() === address.toLowerCase();\n        });\n        return (foundWallet && foundWallet.id) || '';\n    };\n    return ArkaneWalletSubProvider;\n}(base_wallet_subprovider_1.BaseWalletSubprovider));\nexports.ArkaneWalletSubProvider = ArkaneWalletSubProvider;\n//# sourceMappingURL=ArkaneWalletSubProvider.js.map"]},"metadata":{},"sourceType":"script"}