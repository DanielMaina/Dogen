{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.promisify = void 0;\n\nvar util_1 = require(\"util\");\n\nObject.defineProperty(exports, \"promisify\", {\n  enumerable: true,\n  get: function () {\n    return util_1.promisify;\n  }\n}); // /**\n//  * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) -- into an ES6-compatible Promise.\n//  * Promisify provides a default callback of the form (error, result) and rejects when `error` is not null. You can also\n//  * supply thisArg object as the second argument which will be passed to `apply`.\n//  */\n// // HACK: This can't be properly typed without variadic kinds https://github.com/Microsoft/TypeScript/issues/5453\n// export function promisify<T>(originalFn: (...args: any[]) => void, thisArg?: any): (...callArgs: any[]) => Promise<T> {\n//     const promisifiedFunction = async (...callArgs: any[]): Promise<T> => {\n//         return new Promise<T>((resolve, reject) => {\n//             const callback = (err: Error | null, data?: T) => {\n//                 err === null || err === undefined ? resolve(data) : reject(err);\n//             };\n//             originalFn.apply(thisArg, [...callArgs, callback]);\n//         });\n//     };\n//     return promisifiedFunction;\n// }","map":{"version":3,"sources":["../../src/promisify.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AAAS,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,WAAA,EAAA;AAAA,EAAA,UAAA,EAAA,IAAA;AAAA,EAAA,GAAA,EAAA,YAAA;AAAA,WAAA,MAAA,CAAA,SAAA;AAAS;AAAT,CAAA,E,CAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.promisify = void 0;\nvar util_1 = require(\"util\");\nObject.defineProperty(exports, \"promisify\", { enumerable: true, get: function () { return util_1.promisify; } });\n// /**\n//  * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) -- into an ES6-compatible Promise.\n//  * Promisify provides a default callback of the form (error, result) and rejects when `error` is not null. You can also\n//  * supply thisArg object as the second argument which will be passed to `apply`.\n//  */\n// // HACK: This can't be properly typed without variadic kinds https://github.com/Microsoft/TypeScript/issues/5453\n// export function promisify<T>(originalFn: (...args: any[]) => void, thisArg?: any): (...callArgs: any[]) => Promise<T> {\n//     const promisifiedFunction = async (...callArgs: any[]): Promise<T> => {\n//         return new Promise<T>((resolve, reject) => {\n//             const callback = (err: Error | null, data?: T) => {\n//                 err === null || err === undefined ? resolve(data) : reject(err);\n//             };\n//             originalFn.apply(thisArg, [...callArgs, callback]);\n//         });\n//     };\n//     return promisifiedFunction;\n// }\n//# sourceMappingURL=promisify.js.map"]},"metadata":{},"sourceType":"script"}