{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.signTypedDataUtils = void 0;\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst ethers = require(\"ethers\");\n\nconst configured_bignumber_1 = require(\"./configured_bignumber\");\n\nexports.signTypedDataUtils = {\n  /**\n   * Generates the EIP712 Typed Data hash for signing\n   * @param   typedData An object that conforms to the EIP712TypedData interface\n   * @return  A Buffer containing the hash of the typed data.\n   */\n  generateTypedDataHash(typedData) {\n    return ethUtil.keccak256(Buffer.concat([Buffer.from('1901', 'hex'), exports.signTypedDataUtils._structHash('EIP712Domain', typedData.domain, typedData.types), exports.signTypedDataUtils._structHash(typedData.primaryType, typedData.message, typedData.types)]));\n  },\n\n  /**\n   * Generates the EIP712 Typed Data hash for a typed data object without using the domain field. This\n   * makes hashing easier for non-EIP712 data.\n   * @param   typedData An object that conforms to the EIP712TypedData interface\n   * @return  A Buffer containing the hash of the typed data.\n   */\n  generateTypedDataHashWithoutDomain(typedData) {\n    return exports.signTypedDataUtils._structHash(typedData.primaryType, typedData.message, typedData.types);\n  },\n\n  /**\n   * Generates the hash of a EIP712 Domain with the default schema\n   * @param  domain An EIP712 domain with the default schema containing a name, version, chain id,\n   *                and verifying address.\n   * @return A buffer that contains the hash of the domain.\n   */\n  generateDomainHash(domain) {\n    return exports.signTypedDataUtils._structHash('EIP712Domain', domain, // HACK(jalextowle): When we consolidate our testing packages into test-utils, we can use a constant\n    // to eliminate code duplication. At the moment, there isn't a good way to do that because of cyclic-dependencies.\n    {\n      EIP712Domain: [{\n        name: 'name',\n        type: 'string'\n      }, {\n        name: 'version',\n        type: 'string'\n      }, {\n        name: 'chainId',\n        type: 'uint256'\n      }, {\n        name: 'verifyingContract',\n        type: 'address'\n      }]\n    });\n  },\n\n  _findDependencies(primaryType, types) {\n    let found = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    if (found.includes(primaryType) || types[primaryType] === undefined) {\n      return found;\n    }\n\n    found.push(primaryType);\n\n    for (const field of types[primaryType]) {\n      for (const dep of exports.signTypedDataUtils._findDependencies(field.type, types, found)) {\n        if (!found.includes(dep)) {\n          found.push(dep);\n        }\n      }\n    }\n\n    return found;\n  },\n\n  _encodeType(primaryType, types) {\n    let deps = exports.signTypedDataUtils._findDependencies(primaryType, types);\n\n    deps = deps.filter(d => d !== primaryType);\n    deps = [primaryType].concat(deps.sort());\n    let result = '';\n\n    for (const dep of deps) {\n      result += `${dep}(${types[dep].map(_ref => {\n        let {\n          name,\n          type\n        } = _ref;\n        return `${type} ${name}`;\n      }).join(',')})`;\n    }\n\n    return result;\n  },\n\n  _encodeData(primaryType, data, types) {\n    const encodedTypes = ['bytes32'];\n    const encodedValues = [exports.signTypedDataUtils._typeHash(primaryType, types)];\n\n    for (const field of types[primaryType]) {\n      const value = data[field.name];\n\n      if (field.type === 'string') {\n        const hashValue = ethUtil.keccak256(Buffer.from(value));\n        encodedTypes.push('bytes32');\n        encodedValues.push(hashValue);\n      } else if (field.type === 'bytes') {\n        const hashValue = ethUtil.keccak256(ethUtil.toBuffer(value));\n        encodedTypes.push('bytes32');\n        encodedValues.push(hashValue);\n      } else if (types[field.type] !== undefined) {\n        encodedTypes.push('bytes32');\n        const hashValue = ethUtil.keccak256( // tslint:disable-next-line:no-unnecessary-type-assertion\n        ethUtil.toBuffer(exports.signTypedDataUtils._encodeData(field.type, value, types)));\n        encodedValues.push(hashValue);\n      } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n        throw new Error('Arrays currently unimplemented in encodeData');\n      } else {\n        encodedTypes.push(field.type);\n\n        const normalizedValue = exports.signTypedDataUtils._normalizeValue(field.type, value);\n\n        encodedValues.push(normalizedValue);\n      }\n    }\n\n    return ethers.utils.defaultAbiCoder.encode(encodedTypes, encodedValues);\n  },\n\n  _normalizeValue(type, value) {\n    const STRING_BASE = 10;\n\n    if (type === 'uint256') {\n      if (configured_bignumber_1.BigNumber.isBigNumber(value)) {\n        return value.toString(STRING_BASE);\n      }\n\n      return new configured_bignumber_1.BigNumber(value).toString(STRING_BASE);\n    }\n\n    return value;\n  },\n\n  _typeHash(primaryType, types) {\n    return ethUtil.keccak256(Buffer.from(exports.signTypedDataUtils._encodeType(primaryType, types)));\n  },\n\n  _structHash(primaryType, data, types) {\n    return ethUtil.keccak256(ethUtil.toBuffer(exports.signTypedDataUtils._encodeData(primaryType, data, types)));\n  }\n\n};","map":{"version":3,"sources":["../../src/sign_typed_data_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.signTypedDataUtils = void 0;\nconst ethUtil = require(\"ethereumjs-util\");\nconst ethers = require(\"ethers\");\nconst configured_bignumber_1 = require(\"./configured_bignumber\");\nexports.signTypedDataUtils = {\n    /**\n     * Generates the EIP712 Typed Data hash for signing\n     * @param   typedData An object that conforms to the EIP712TypedData interface\n     * @return  A Buffer containing the hash of the typed data.\n     */\n    generateTypedDataHash(typedData) {\n        return ethUtil.keccak256(Buffer.concat([\n            Buffer.from('1901', 'hex'),\n            exports.signTypedDataUtils._structHash('EIP712Domain', typedData.domain, typedData.types),\n            exports.signTypedDataUtils._structHash(typedData.primaryType, typedData.message, typedData.types),\n        ]));\n    },\n    /**\n     * Generates the EIP712 Typed Data hash for a typed data object without using the domain field. This\n     * makes hashing easier for non-EIP712 data.\n     * @param   typedData An object that conforms to the EIP712TypedData interface\n     * @return  A Buffer containing the hash of the typed data.\n     */\n    generateTypedDataHashWithoutDomain(typedData) {\n        return exports.signTypedDataUtils._structHash(typedData.primaryType, typedData.message, typedData.types);\n    },\n    /**\n     * Generates the hash of a EIP712 Domain with the default schema\n     * @param  domain An EIP712 domain with the default schema containing a name, version, chain id,\n     *                and verifying address.\n     * @return A buffer that contains the hash of the domain.\n     */\n    generateDomainHash(domain) {\n        return exports.signTypedDataUtils._structHash('EIP712Domain', domain, \n        // HACK(jalextowle): When we consolidate our testing packages into test-utils, we can use a constant\n        // to eliminate code duplication. At the moment, there isn't a good way to do that because of cyclic-dependencies.\n        {\n            EIP712Domain: [\n                { name: 'name', type: 'string' },\n                { name: 'version', type: 'string' },\n                { name: 'chainId', type: 'uint256' },\n                { name: 'verifyingContract', type: 'address' },\n            ],\n        });\n    },\n    _findDependencies(primaryType, types, found = []) {\n        if (found.includes(primaryType) || types[primaryType] === undefined) {\n            return found;\n        }\n        found.push(primaryType);\n        for (const field of types[primaryType]) {\n            for (const dep of exports.signTypedDataUtils._findDependencies(field.type, types, found)) {\n                if (!found.includes(dep)) {\n                    found.push(dep);\n                }\n            }\n        }\n        return found;\n    },\n    _encodeType(primaryType, types) {\n        let deps = exports.signTypedDataUtils._findDependencies(primaryType, types);\n        deps = deps.filter(d => d !== primaryType);\n        deps = [primaryType].concat(deps.sort());\n        let result = '';\n        for (const dep of deps) {\n            result += `${dep}(${types[dep].map(({ name, type }) => `${type} ${name}`).join(',')})`;\n        }\n        return result;\n    },\n    _encodeData(primaryType, data, types) {\n        const encodedTypes = ['bytes32'];\n        const encodedValues = [exports.signTypedDataUtils._typeHash(primaryType, types)];\n        for (const field of types[primaryType]) {\n            const value = data[field.name];\n            if (field.type === 'string') {\n                const hashValue = ethUtil.keccak256(Buffer.from(value));\n                encodedTypes.push('bytes32');\n                encodedValues.push(hashValue);\n            }\n            else if (field.type === 'bytes') {\n                const hashValue = ethUtil.keccak256(ethUtil.toBuffer(value));\n                encodedTypes.push('bytes32');\n                encodedValues.push(hashValue);\n            }\n            else if (types[field.type] !== undefined) {\n                encodedTypes.push('bytes32');\n                const hashValue = ethUtil.keccak256(\n                // tslint:disable-next-line:no-unnecessary-type-assertion\n                ethUtil.toBuffer(exports.signTypedDataUtils._encodeData(field.type, value, types)));\n                encodedValues.push(hashValue);\n            }\n            else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n                throw new Error('Arrays currently unimplemented in encodeData');\n            }\n            else {\n                encodedTypes.push(field.type);\n                const normalizedValue = exports.signTypedDataUtils._normalizeValue(field.type, value);\n                encodedValues.push(normalizedValue);\n            }\n        }\n        return ethers.utils.defaultAbiCoder.encode(encodedTypes, encodedValues);\n    },\n    _normalizeValue(type, value) {\n        const STRING_BASE = 10;\n        if (type === 'uint256') {\n            if (configured_bignumber_1.BigNumber.isBigNumber(value)) {\n                return value.toString(STRING_BASE);\n            }\n            return new configured_bignumber_1.BigNumber(value).toString(STRING_BASE);\n        }\n        return value;\n    },\n    _typeHash(primaryType, types) {\n        return ethUtil.keccak256(Buffer.from(exports.signTypedDataUtils._encodeType(primaryType, types)));\n    },\n    _structHash(primaryType, data, types) {\n        return ethUtil.keccak256(ethUtil.toBuffer(exports.signTypedDataUtils._encodeData(primaryType, data, types)));\n    },\n};\n//# sourceMappingURL=sign_typed_data_utils.js.map"]},"metadata":{},"sourceType":"script"}