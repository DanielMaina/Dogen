{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { Trade } from '@uniswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useMemo } from 'react';\nimport { GlobalData } from '../constants';\nimport { PairState, usePairs } from '../data/Reserves';\nimport { wrappedCurrency } from '../utils/wrappedCurrency';\nimport { useActiveWeb3React } from './index';\n\nfunction useAllCommonPairs(currencyA, currencyB) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const bases = useMemo(() => chainId ? GlobalData.bases.BASES_TO_CHECK_TRADES_AGAINST[chainId] : [], [chainId]);\n  const [tokenA, tokenB] = chainId ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)] : [undefined, undefined];\n  const basePairs = useMemo(() => flatMap(bases, base => bases.map(otherBase => [base, otherBase])).filter(_ref => {\n    let [t0, t1] = _ref;\n    return t0.address !== t1.address;\n  }), [bases]);\n  const allPairCombinations = useMemo(() => tokenA && tokenB ? [// the direct pair\n  [tokenA, tokenB], // token A against all bases\n  ...bases.map(base => [tokenA, base]), // token B against all bases\n  ...bases.map(base => [tokenB, base]), // each base against all bases\n  ...basePairs].filter(tokens => Boolean(tokens[0] && tokens[1])).filter(_ref2 => {\n    let [t0, t1] = _ref2;\n    return t0.address !== t1.address;\n  }).filter(_ref3 => {\n    let [tokenA, tokenB] = _ref3;\n    if (!chainId) return true;\n    const customBases = GlobalData.bases.CUSTOM_BASES[chainId];\n    if (!customBases) return true;\n    const customBasesA = customBases[tokenA.address];\n    const customBasesB = customBases[tokenB.address];\n    if (!customBasesA && !customBasesB) return true;\n    if (customBasesA && !customBasesA.find(base => tokenB.equals(base))) return false;\n    if (customBasesB && !customBasesB.find(base => tokenA.equals(base))) return false;\n    return true;\n  }) : [], [tokenA, tokenB, bases, basePairs, chainId]);\n  const allPairs = usePairs(allPairCombinations); // only pass along valid pairs, non-duplicated pairs\n\n  return useMemo(() => Object.values(allPairs // filter out invalid pairs\n  .filter(result => Boolean(result[0] === PairState.EXISTS && result[1])) // filter out duplicated pairs\n  .reduce((memo, _ref4) => {\n    var _memo$curr$liquidityT;\n\n    let [, curr] = _ref4;\n    memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n    return memo;\n  }, {})), [allPairs]);\n}\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\n\n\n_s(useAllCommonPairs, \"yOlOGLSe6CG5zU7a8alITxmtf8s=\", false, function () {\n  return [useActiveWeb3React, usePairs];\n});\n\nexport function useTradeExactIn(currencyAmountIn, currencyOut) {\n  _s2();\n\n  const allowedPairs = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      var _Trade$bestTradeExact;\n\n      return (_Trade$bestTradeExact = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n        maxHops: 3,\n        maxNumResults: 1\n      })[0]) !== null && _Trade$bestTradeExact !== void 0 ? _Trade$bestTradeExact : null;\n    }\n\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut]);\n}\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\n\n_s2(useTradeExactIn, \"VKnNShbqc2Xh9bmx09RrKz6CRDo=\", false, function () {\n  return [useAllCommonPairs];\n});\n\nexport function useTradeExactOut(currencyIn, currencyAmountOut) {\n  _s3();\n\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      var _Trade$bestTradeExact2;\n\n      return (_Trade$bestTradeExact2 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n        maxHops: 3,\n        maxNumResults: 1\n      })[0]) !== null && _Trade$bestTradeExact2 !== void 0 ? _Trade$bestTradeExact2 : null;\n    }\n\n    return null;\n  }, [allowedPairs, currencyIn, currencyAmountOut]);\n}\n\n_s3(useTradeExactOut, \"VKnNShbqc2Xh9bmx09RrKz6CRDo=\", false, function () {\n  return [useAllCommonPairs];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/hooks/Trades.ts"],"names":["Trade","flatMap","useMemo","GlobalData","PairState","usePairs","wrappedCurrency","useActiveWeb3React","useAllCommonPairs","currencyA","currencyB","chainId","bases","BASES_TO_CHECK_TRADES_AGAINST","tokenA","tokenB","undefined","basePairs","base","map","otherBase","filter","t0","t1","address","allPairCombinations","tokens","Boolean","customBases","CUSTOM_BASES","customBasesA","customBasesB","find","equals","allPairs","Object","values","result","EXISTS","reduce","memo","curr","liquidityToken","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","length","bestTradeExactIn","maxHops","maxNumResults","useTradeExactOut","currencyIn","currencyAmountOut","bestTradeExactOut"],"mappings":"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","sourcesContent":["import { Currency, CurrencyAmount, Pair, Token, Trade } from '@uniswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useMemo } from 'react';\n\nimport { GlobalData } from '../constants';\nimport { PairState, usePairs } from '../data/Reserves';\nimport { wrappedCurrency } from '../utils/wrappedCurrency';\n\nimport { useActiveWeb3React } from './index';\n\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\n  const { chainId } = useActiveWeb3React();\n\n  const bases: Token[] = useMemo(\n    () =>\n      chainId ? GlobalData.bases.BASES_TO_CHECK_TRADES_AGAINST[chainId] : [],\n    [chainId],\n  );\n\n  const [tokenA, tokenB] = chainId\n    ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n    : [undefined, undefined];\n\n  const basePairs: [Token, Token][] = useMemo(\n    () =>\n      flatMap(bases, (base): [Token, Token][] =>\n        bases.map((otherBase) => [base, otherBase]),\n      ).filter(([t0, t1]) => t0.address !== t1.address),\n    [bases],\n  );\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs,\n          ]\n            .filter((tokens): tokens is [Token, Token] =>\n              Boolean(tokens[0] && tokens[1]),\n            )\n            .filter(([t0, t1]) => t0.address !== t1.address)\n            .filter(([tokenA, tokenB]) => {\n              if (!chainId) return true;\n              const customBases = GlobalData.bases.CUSTOM_BASES[chainId];\n              if (!customBases) return true;\n\n              const customBasesA: Token[] | undefined =\n                customBases[tokenA.address];\n              const customBasesB: Token[] | undefined =\n                customBases[tokenB.address];\n\n              if (!customBasesA && !customBasesB) return true;\n\n              if (\n                customBasesA &&\n                !(customBasesA as Token[]).find((base) => tokenB.equals(base))\n              )\n                return false;\n              if (\n                customBasesB &&\n                !(customBasesB as Token[]).find((base) => tokenA.equals(base))\n              )\n                return false;\n\n              return true;\n            })\n        : [],\n    [tokenA, tokenB, bases, basePairs, chainId],\n  );\n\n  const allPairs = usePairs(allPairCombinations);\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] =>\n            Boolean(result[0] === PairState.EXISTS && result[1]),\n          )\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] =\n              memo[curr.liquidityToken.address] ?? curr;\n            return memo;\n          }, {}),\n      ),\n    [allPairs],\n  );\n}\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useTradeExactIn(\n  currencyAmountIn?: CurrencyAmount,\n  currencyOut?: Currency,\n): Trade | null {\n  const allowedPairs = useAllCommonPairs(\n    currencyAmountIn?.currency,\n    currencyOut,\n  );\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      return (\n        Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: 3,\n          maxNumResults: 1,\n        })[0] ?? null\n      );\n    }\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut]);\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useTradeExactOut(\n  currencyIn?: Currency,\n  currencyAmountOut?: CurrencyAmount,\n): Trade | null {\n  const allowedPairs = useAllCommonPairs(\n    currencyIn,\n    currencyAmountOut?.currency,\n  );\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      return (\n        Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: 3,\n          maxNumResults: 1,\n        })[0] ?? null\n      );\n    }\n    return null;\n  }, [allowedPairs, currencyIn, currencyAmountOut]);\n}\n"]},"metadata":{},"sourceType":"module"}