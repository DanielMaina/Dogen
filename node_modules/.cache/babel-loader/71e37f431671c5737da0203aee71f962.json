{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useMemo, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from 'hooks';\nimport { useBlockNumber } from 'state/application/hooks';\nimport { useAddPopup, useRemovePopup } from 'state/application/hooks';\nimport { checkedTransaction, finalizeTransaction } from './actions';\nimport { updateBlockNumber } from 'state/application/actions';\nexport function shouldCheck(lastBlockNumber, tx) {\n  if (tx.receipt) return false;\n  if (!tx.lastCheckedBlockNumber) return true;\n  const blocksSinceCheck = lastBlockNumber - tx.lastCheckedBlockNumber;\n  if (blocksSinceCheck < 1) return false;\n  const minutesPending = (new Date().getTime() - tx.addedTime) / 1000 / 60;\n\n  if (minutesPending > 60) {\n    // every 10 blocks if pending for longer than an hour\n    return blocksSinceCheck > 9;\n  } else if (minutesPending > 5) {\n    // every 3 blocks if pending more than 5 minutes\n    return blocksSinceCheck > 2;\n  } else {\n    // otherwise every block\n    return true;\n  }\n}\nexport default function Updater() {\n  _s();\n\n  const {\n    chainId,\n    library\n  } = useActiveWeb3React();\n  const [popupTxHashes, setPopupTxHashes] = useState(''); // to store hash of the transactions already opened a popup.\n\n  const lastBlockNumber = useBlockNumber();\n  const dispatch = useDispatch();\n  const state = useSelector(state => state.transactions);\n  const transactions = useMemo(() => {\n    var _state$chainId;\n\n    return chainId ? (_state$chainId = state[chainId]) !== null && _state$chainId !== void 0 ? _state$chainId : {} : {};\n  }, [chainId, state]); // show popup on confirm\n\n  const addPopup = useAddPopup();\n  const removePopup = useRemovePopup();\n  useEffect(() => {\n    if (!chainId || !library || !lastBlockNumber) return;\n    Object.keys(transactions).filter(hash => shouldCheck(lastBlockNumber, transactions[hash])).forEach(hash => {\n      library.getTransaction(hash).then(res => {\n        // to prevent opening the processing popup multiple times when the transaction is pending for a long time.\n        if (popupTxHashes.indexOf(hash) === -1 && res) {\n          var _transactions$hash;\n\n          addPopup({\n            txn: {\n              hash,\n              pending: true,\n              success: false,\n              summary: (_transactions$hash = transactions[hash]) === null || _transactions$hash === void 0 ? void 0 : _transactions$hash.summary\n            }\n          }, hash, null);\n          setTimeout(() => {\n            removePopup(hash);\n          }, 20000);\n          let hashStr = popupTxHashes;\n          hashStr += hash + ',';\n          setPopupTxHashes(hashStr);\n        }\n\n        if (!res) {\n          dispatch(finalizeTransaction({\n            chainId,\n            hash,\n            receipt: 'failed'\n          }));\n        }\n      });\n      library.getTransactionReceipt(hash).then(receipt => {\n        if (receipt) {\n          var _transactions$hash2;\n\n          // the receipt was fetched before the block, fast forward to that block to trigger balance updates\n          if (receipt.blockNumber > lastBlockNumber) {\n            dispatch(updateBlockNumber({\n              chainId,\n              blockNumber: receipt.blockNumber\n            }));\n          }\n\n          dispatch(finalizeTransaction({\n            chainId,\n            hash,\n            receipt: {\n              blockHash: receipt.blockHash,\n              blockNumber: receipt.blockNumber,\n              contractAddress: receipt.contractAddress,\n              from: receipt.from,\n              status: receipt.status,\n              to: receipt.to,\n              transactionHash: receipt.transactionHash,\n              transactionIndex: receipt.transactionIndex\n            }\n          }));\n          removePopup(hash);\n          addPopup({\n            txn: {\n              hash,\n              success: receipt.status === 1,\n              summary: (_transactions$hash2 = transactions[hash]) === null || _transactions$hash2 === void 0 ? void 0 : _transactions$hash2.summary\n            }\n          }, hash);\n        } else {\n          dispatch(checkedTransaction({\n            chainId,\n            hash,\n            blockNumber: lastBlockNumber\n          }));\n        }\n      }).catch(error => {\n        console.error(`failed to check transaction hash: ${hash}`, error);\n      });\n    });\n  }, [chainId, library, transactions, removePopup, lastBlockNumber, dispatch, addPopup, popupTxHashes]);\n  return null;\n}\n\n_s(Updater, \"fLOla6reaTq2K06827QF9HDZlNQ=\", false, function () {\n  return [useActiveWeb3React, useBlockNumber, useDispatch, useSelector, useAddPopup, useRemovePopup];\n});\n\n_c = Updater;\n\nvar _c;\n\n$RefreshReg$(_c, \"Updater\");","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/state/transactions/updater.tsx"],"names":["useEffect","useMemo","useState","useDispatch","useSelector","useActiveWeb3React","useBlockNumber","useAddPopup","useRemovePopup","checkedTransaction","finalizeTransaction","updateBlockNumber","shouldCheck","lastBlockNumber","tx","receipt","lastCheckedBlockNumber","blocksSinceCheck","minutesPending","Date","getTime","addedTime","Updater","chainId","library","popupTxHashes","setPopupTxHashes","dispatch","state","transactions","addPopup","removePopup","Object","keys","filter","hash","forEach","getTransaction","then","res","indexOf","txn","pending","success","summary","setTimeout","hashStr","getTransactionReceipt","blockNumber","blockHash","contractAddress","from","status","to","transactionHash","transactionIndex","catch","error","console"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from 'hooks';\nimport { useBlockNumber } from 'state/application/hooks';\nimport { useAddPopup, useRemovePopup } from 'state/application/hooks';\nimport { AppDispatch, AppState } from 'state';\nimport { checkedTransaction, finalizeTransaction } from './actions';\nimport { updateBlockNumber } from 'state/application/actions';\n\nexport function shouldCheck(\n  lastBlockNumber: number,\n  tx: { addedTime: number; receipt?: any; lastCheckedBlockNumber?: number },\n): boolean {\n  if (tx.receipt) return false;\n  if (!tx.lastCheckedBlockNumber) return true;\n  const blocksSinceCheck = lastBlockNumber - tx.lastCheckedBlockNumber;\n  if (blocksSinceCheck < 1) return false;\n  const minutesPending = (new Date().getTime() - tx.addedTime) / 1000 / 60;\n  if (minutesPending > 60) {\n    // every 10 blocks if pending for longer than an hour\n    return blocksSinceCheck > 9;\n  } else if (minutesPending > 5) {\n    // every 3 blocks if pending more than 5 minutes\n    return blocksSinceCheck > 2;\n  } else {\n    // otherwise every block\n    return true;\n  }\n}\n\nexport default function Updater(): null {\n  const { chainId, library } = useActiveWeb3React();\n  const [popupTxHashes, setPopupTxHashes] = useState(''); // to store hash of the transactions already opened a popup.\n\n  const lastBlockNumber = useBlockNumber();\n\n  const dispatch = useDispatch<AppDispatch>();\n  const state = useSelector<AppState, AppState['transactions']>(\n    (state) => state.transactions,\n  );\n\n  const transactions = useMemo(() => (chainId ? state[chainId] ?? {} : {}), [\n    chainId,\n    state,\n  ]);\n\n  // show popup on confirm\n  const addPopup = useAddPopup();\n  const removePopup = useRemovePopup();\n\n  useEffect(() => {\n    if (!chainId || !library || !lastBlockNumber) return;\n\n    Object.keys(transactions)\n      .filter((hash) => shouldCheck(lastBlockNumber, transactions[hash]))\n      .forEach((hash) => {\n        library.getTransaction(hash).then((res) => {\n          // to prevent opening the processing popup multiple times when the transaction is pending for a long time.\n          if (popupTxHashes.indexOf(hash) === -1 && res) {\n            addPopup(\n              {\n                txn: {\n                  hash,\n                  pending: true,\n                  success: false,\n                  summary: transactions[hash]?.summary,\n                },\n              },\n              hash,\n              null,\n            );\n\n            setTimeout(() => {\n              removePopup(hash);\n            }, 20000);\n\n            let hashStr = popupTxHashes;\n            hashStr += hash + ',';\n            setPopupTxHashes(hashStr);\n          }\n          if (!res) {\n            dispatch(\n              finalizeTransaction({\n                chainId,\n                hash,\n                receipt: 'failed',\n              }),\n            );\n          }\n        });\n\n        library\n          .getTransactionReceipt(hash)\n          .then((receipt) => {\n            if (receipt) {\n              // the receipt was fetched before the block, fast forward to that block to trigger balance updates\n              if (receipt.blockNumber > lastBlockNumber) {\n                dispatch(\n                  updateBlockNumber({\n                    chainId,\n                    blockNumber: receipt.blockNumber,\n                  }),\n                );\n              }\n\n              dispatch(\n                finalizeTransaction({\n                  chainId,\n                  hash,\n                  receipt: {\n                    blockHash: receipt.blockHash,\n                    blockNumber: receipt.blockNumber,\n                    contractAddress: receipt.contractAddress,\n                    from: receipt.from,\n                    status: receipt.status,\n                    to: receipt.to,\n                    transactionHash: receipt.transactionHash,\n                    transactionIndex: receipt.transactionIndex,\n                  },\n                }),\n              );\n\n              removePopup(hash);\n\n              addPopup(\n                {\n                  txn: {\n                    hash,\n                    success: receipt.status === 1,\n                    summary: transactions[hash]?.summary,\n                  },\n                },\n                hash,\n              );\n            } else {\n              dispatch(\n                checkedTransaction({\n                  chainId,\n                  hash,\n                  blockNumber: lastBlockNumber,\n                }),\n              );\n            }\n          })\n          .catch((error) => {\n            console.error(`failed to check transaction hash: ${hash}`, error);\n          });\n      });\n  }, [\n    chainId,\n    library,\n    transactions,\n    removePopup,\n    lastBlockNumber,\n    dispatch,\n    addPopup,\n    popupTxHashes,\n  ]);\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}