{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\"; ///////////////////////////////////////////////////////////\n// ReflexContainer\n// By Philippe Leefsma\n// December 2016\n//\n///////////////////////////////////////////////////////////\n\nimport ReflexSplitter from './ReflexSplitter';\nimport ReflexEvents from './ReflexEvents';\nimport { getDataProps } from './utilities';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport './Polyfills';\nexport default class ReflexContainer extends React.Component {\n  /////////////////////////////////////////////////////////\n  // orientation: Orientation of the layout container\n  //              valid values are ['horizontal', 'vertical'] \n  // maxRecDepth: Maximun recursion depth to solve initial flex\n  //              of layout elements based on user provided values\n  // className: Space separated classnames to apply custom styles \n  //            to the layout container  \n  // style: allows passing inline style to the container\n  /////////////////////////////////////////////////////////\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"onWindowResize\", () => {\n      this.setState({\n        flexData: this.computeFlexData()\n      });\n    });\n\n    _defineProperty(this, \"onStartResize\", data => {\n      const pos = data.event.changedTouches ? data.event.changedTouches[0] : data.event;\n\n      switch (this.props.orientation) {\n        case 'horizontal':\n          document.body.classList.add('reflex-row-resize');\n          this.previousPos = pos.clientY;\n          break;\n\n        case 'vertical':\n        default:\n          document.body.classList.add('reflex-col-resize');\n          this.previousPos = pos.clientX;\n          break;\n      }\n\n      this.elements = [this.children[data.index - 1], this.children[data.index + 1]];\n      this.emitElementsEvent(this.elements, 'onStartResize');\n    });\n\n    _defineProperty(this, \"onResize\", data => {\n      const pos = data.event.changedTouches ? data.event.changedTouches[0] : data.event;\n      const offset = this.getOffset(pos, data.domElement);\n\n      switch (this.props.orientation) {\n        case 'horizontal':\n          this.previousPos = pos.clientY;\n          break;\n\n        case 'vertical':\n        default:\n          this.previousPos = pos.clientX;\n          break;\n      }\n\n      if (offset) {\n        const availableOffset = this.computeAvailableOffset(data.index, offset);\n\n        if (availableOffset) {\n          this.elements = this.dispatchOffset(data.index, availableOffset);\n          this.adjustFlex(this.elements);\n          this.setState({\n            resizing: true\n          }, () => {\n            this.emitElementsEvent(this.elements, 'onResize');\n          });\n        }\n      }\n    });\n\n    _defineProperty(this, \"onStopResize\", data => {\n      document.body.classList.remove('reflex-row-resize');\n      document.body.classList.remove('reflex-col-resize');\n      const resizedRefs = this.elements ? this.elements.map(element => {\n        return element.ref;\n      }) : [];\n      const elements = this.children.filter(child => {\n        return !ReflexSplitter.isA(child) && resizedRefs.includes(child.ref);\n      });\n      this.emitElementsEvent(elements, 'onStopResize');\n      this.setState({\n        resizing: false\n      });\n    });\n\n    _defineProperty(this, \"onElementSize\", data => {\n      return new Promise(resolve => {\n        try {\n          const idx = data.index;\n          const size = this.getSize(this.children[idx]);\n          const offset = data.size - size;\n          const dir = data.direction;\n          const splitterIdx = idx + dir;\n          const availableOffset = this.computeAvailableOffset(splitterIdx, dir * offset);\n          this.elements = null;\n\n          if (availableOffset) {\n            this.elements = this.dispatchOffset(splitterIdx, availableOffset);\n            this.adjustFlex(this.elements);\n          }\n\n          this.setState(this.state, () => {\n            this.emitElementsEvent(this.elements, 'onResize');\n            resolve();\n          });\n        } catch (ex) {\n          // TODO handle exception ...\n          console.log(ex);\n        }\n      });\n    });\n\n    this.events = new ReflexEvents();\n    this.children = [];\n    this.state = {\n      flexData: []\n    };\n    this.ref = React.createRef();\n  }\n\n  componentDidMount() {\n    const flexData = this.computeFlexData();\n    const {\n      windowResizeAware\n    } = this.props;\n\n    if (windowResizeAware) {\n      window.addEventListener('resize', this.onWindowResize);\n    }\n\n    this.setState({\n      windowResizeAware,\n      flexData\n    });\n    this.events.on('element.size', this.onElementSize);\n    this.events.on('startResize', this.onStartResize);\n    this.events.on('stopResize', this.onStopResize);\n    this.events.on('resize', this.onResize);\n  }\n\n  componentWillUnmount() {\n    this.events.off();\n    window.removeEventListener('resize', this.onWindowResize);\n  }\n\n  getValidChildren() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n    return this.toArray(props.children).filter(child => {\n      return !!child;\n    });\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const children = this.getValidChildren(this.props);\n\n    if (children.length !== this.state.flexData.length || prevProps.orientation !== this.props.orientation || this.flexHasChanged(prevProps)) {\n      const flexData = this.computeFlexData(children, this.props);\n      this.setState({\n        flexData\n      });\n    }\n\n    if (this.props.windowResizeAware !== this.state.windowResizeAware) {\n      !this.props.windowResizeAware ? window.removeEventListener('resize', this.onWindowResize) : window.addEventListener('resize', this.onWindowResize);\n      this.setState({\n        windowResizeAware: this.props.windowResizeAware\n      });\n    }\n  } // UNSAFE_componentWillReceiveProps(props) {\n  //   const children = this.getValidChildren(props)\n  //   if (children.length !== this.state.flexData.length || \n  //     props.orientation !== this.props.orientation || \n  //     this.flexHasChanged(props)) \n  //   {\n  //     const flexData = this.computeFlexData(\n  //       children, props)\n  //     this.setState({\n  //       flexData\n  //     });\n  //   }\n  //   if (props.windowResizeAware !== this.state.windowResizeAware) {\n  //     !props.windowResizeAware\n  //       ? window.removeEventListener('resize', this.onWindowResize)\n  //       : window.addEventListener('resize', this.onWindowResize)\n  //     this.setState({\n  //       windowResizeAware: props.windowResizeAware\n  //     })\n  //   }\n  // } \n  /////////////////////////////////////////////////////////\n  // attempts to preserve current flex on window resize\n  //\n  /////////////////////////////////////////////////////////\n  /////////////////////////////////////////////////////////\n  // Check if flex has changed: this allows updating the\n  // component when different flex is passed as property\n  // to one or several children\n  //\n  /////////////////////////////////////////////////////////\n\n\n  flexHasChanged(prevProps) {\n    const prevChildrenFlex = this.getValidChildren(prevProps).map(child => {\n      return child.props.flex || 0;\n    });\n    const childrenFlex = this.getValidChildren().map(child => {\n      return child.props.flex || 0;\n    });\n    return !childrenFlex.every((flex, idx) => {\n      return flex === prevChildrenFlex[idx];\n    });\n  } /////////////////////////////////////////////////////////\n  // Returns size of a ReflexElement\n  //\n  /////////////////////////////////////////////////////////\n\n\n  getSize(element) {\n    const domElement = element.ref.current;\n\n    switch (this.props.orientation) {\n      case 'horizontal':\n        return domElement.offsetHeight;\n\n      case 'vertical':\n      default:\n        return domElement.offsetWidth;\n    }\n  } /////////////////////////////////////////////////////////\n  // Computes offset from pointer position\n  //\n  /////////////////////////////////////////////////////////\n\n\n  getOffset(pos, domElement) {\n    const {\n      top,\n      bottom,\n      left,\n      right\n    } = domElement.getBoundingClientRect();\n\n    switch (this.props.orientation) {\n      case 'horizontal':\n        {\n          const offset = pos.clientY - this.previousPos;\n\n          if (offset > 0) {\n            if (pos.clientY >= top) {\n              return offset;\n            }\n          } else {\n            if (pos.clientY <= bottom) {\n              return offset;\n            }\n          }\n\n          break;\n        }\n\n      case 'vertical':\n      default:\n        {\n          const offset = pos.clientX - this.previousPos;\n\n          if (offset > 0) {\n            if (pos.clientX > left) {\n              return offset;\n            }\n          } else {\n            if (pos.clientX < right) {\n              return offset;\n            }\n          }\n        }\n        break;\n    }\n\n    return 0;\n  } /////////////////////////////////////////////////////////\n  // Handles startResize event\n  //\n  /////////////////////////////////////////////////////////\n  /////////////////////////////////////////////////////////\n  // Adjusts flex after a dispatch to make sure\n  // total flex of modified elements remains the same\n  //\n  /////////////////////////////////////////////////////////\n\n\n  adjustFlex(elements) {\n    const diffFlex = elements.reduce((sum, element) => {\n      const idx = element.props.index;\n      const previousFlex = element.props.flex;\n      const nextFlex = this.state.flexData[idx].flex;\n      return sum + (previousFlex - nextFlex) / elements.length;\n    }, 0);\n    elements.forEach(element => {\n      this.state.flexData[element.props.index].flex += diffFlex;\n    });\n  } /////////////////////////////////////////////////////////\n  // Returns available offset for a given raw offset value\n  // This checks how much the panes can be stretched and\n  // shrink, then returns the min\n  //\n  /////////////////////////////////////////////////////////\n\n\n  computeAvailableOffset(idx, offset) {\n    const stretch = this.computeAvailableStretch(idx, offset);\n    const shrink = this.computeAvailableShrink(idx, offset);\n    const availableOffset = Math.min(stretch, shrink) * Math.sign(offset);\n    return availableOffset;\n  } /////////////////////////////////////////////////////////\n  // Returns true if the next splitter than the one at idx\n  // can propagate the drag. This can happen if that\n  // next element is actually a splitter and it has\n  // propagate=true property set\n  //\n  /////////////////////////////////////////////////////////\n\n\n  checkPropagate(idx, direction) {\n    if (direction > 0) {\n      if (idx < this.children.length - 2) {\n        const child = this.children[idx + 2];\n        const typeCheck = ReflexSplitter.isA(child);\n        return typeCheck && child.props.propagate;\n      }\n    } else {\n      if (idx > 2) {\n        const child = this.children[idx - 2];\n        const typeCheck = ReflexSplitter.isA(child);\n        return typeCheck && child.props.propagate;\n      }\n    }\n\n    return false;\n  } /////////////////////////////////////////////////////////\n  // Recursively computes available stretch at splitter\n  // idx for given raw offset\n  //\n  /////////////////////////////////////////////////////////\n\n\n  computeAvailableStretch(idx, offset) {\n    const childIdx = offset < 0 ? idx + 1 : idx - 1;\n    const child = this.children[childIdx];\n    const size = this.getSize(child);\n    const maxSize = child.props.maxSize;\n    const availableStretch = maxSize - size;\n\n    if (availableStretch < Math.abs(offset)) {\n      if (this.checkPropagate(idx, -1 * offset)) {\n        const nextOffset = Math.sign(offset) * (Math.abs(offset) - availableStretch);\n        return availableStretch + this.computeAvailableStretch(offset < 0 ? idx + 2 : idx - 2, nextOffset);\n      }\n    }\n\n    return Math.min(availableStretch, Math.abs(offset));\n  } /////////////////////////////////////////////////////////\n  // Recursively computes available shrink at splitter\n  // idx for given raw offset\n  //\n  /////////////////////////////////////////////////////////\n\n\n  computeAvailableShrink(idx, offset) {\n    const childIdx = offset > 0 ? idx + 1 : idx - 1;\n    const child = this.children[childIdx];\n    const size = this.getSize(child);\n    const minSize = Math.max(child.props.minSize, 0);\n    const availableShrink = size - minSize;\n\n    if (availableShrink < Math.abs(offset)) {\n      if (this.checkPropagate(idx, offset)) {\n        const nextOffset = Math.sign(offset) * (Math.abs(offset) - availableShrink);\n        return availableShrink + this.computeAvailableShrink(offset > 0 ? idx + 2 : idx - 2, nextOffset);\n      }\n    }\n\n    return Math.min(availableShrink, Math.abs(offset));\n  } /////////////////////////////////////////////////////////\n  // Returns flex value for unit pixel\n  //\n  /////////////////////////////////////////////////////////\n\n\n  computePixelFlex() {\n    let orientation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.orientation;\n\n    if (!this.ref.current) {\n      console.warn('Unable to locate ReflexContainer dom node');\n      return 0.0;\n    }\n\n    switch (orientation) {\n      case 'horizontal':\n        if (this.ref.current.offsetHeight === 0.0) {\n          console.warn('Found ReflexContainer with height=0, ' + 'this will cause invalid behavior...');\n          console.warn(this.ref.current);\n          return 0.0;\n        }\n\n        return 1.0 / this.ref.current.offsetHeight;\n\n      case 'vertical':\n      default:\n        if (this.ref.current.offsetWidth === 0.0) {\n          console.warn('Found ReflexContainer with width=0, ' + 'this will cause invalid behavior...');\n          console.warn(this.ref.current);\n          return 0.0;\n        }\n\n        return 1.0 / this.ref.current.offsetWidth;\n    }\n  } /////////////////////////////////////////////////////////\n  // Adds offset to a given ReflexElement\n  //\n  /////////////////////////////////////////////////////////\n\n\n  addOffset(element, offset) {\n    const size = this.getSize(element);\n    const idx = element.props.index;\n    const newSize = Math.max(size + offset, 0);\n    const currentFlex = this.state.flexData[idx].flex;\n    const newFlex = currentFlex > 0 ? currentFlex * newSize / size : this.computePixelFlex() * newSize;\n    this.state.flexData[idx].flex = !isFinite(newFlex) || isNaN(newFlex) ? 0 : newFlex;\n  } /////////////////////////////////////////////////////////\n  // Recursively dispatches stretch offset across\n  // children elements starting at splitter idx\n  //\n  /////////////////////////////////////////////////////////\n\n\n  dispatchStretch(idx, offset) {\n    const childIdx = offset < 0 ? idx + 1 : idx - 1;\n\n    if (childIdx < 0 || childIdx > this.children.length - 1) {\n      return [];\n    }\n\n    const child = this.children[childIdx];\n    const size = this.getSize(child);\n    const newSize = Math.min(child.props.maxSize, size + Math.abs(offset));\n    const dispatchedStretch = newSize - size;\n    this.addOffset(child, dispatchedStretch);\n\n    if (dispatchedStretch < Math.abs(offset)) {\n      const nextIdx = idx - Math.sign(offset) * 2;\n      const nextOffset = Math.sign(offset) * (Math.abs(offset) - dispatchedStretch);\n      return [child, ...this.dispatchStretch(nextIdx, nextOffset)];\n    }\n\n    return [child];\n  } /////////////////////////////////////////////////////////\n  // Recursively dispatches shrink offset across\n  // children elements starting at splitter idx\n  //\n  /////////////////////////////////////////////////////////\n\n\n  dispatchShrink(idx, offset) {\n    const childIdx = offset > 0 ? idx + 1 : idx - 1;\n\n    if (childIdx < 0 || childIdx > this.children.length - 1) {\n      return [];\n    }\n\n    const child = this.children[childIdx];\n    const size = this.getSize(child);\n    const newSize = Math.max(child.props.minSize, size - Math.abs(offset));\n    const dispatchedShrink = newSize - size;\n    this.addOffset(child, dispatchedShrink);\n\n    if (Math.abs(dispatchedShrink) < Math.abs(offset)) {\n      const nextIdx = idx + Math.sign(offset) * 2;\n      const nextOffset = Math.sign(offset) * (Math.abs(offset) + dispatchedShrink);\n      return [child, ...this.dispatchShrink(nextIdx, nextOffset)];\n    }\n\n    return [child];\n  } /////////////////////////////////////////////////////////\n  // Dispatch offset at splitter idx\n  //\n  /////////////////////////////////////////////////////////\n\n\n  dispatchOffset(idx, offset) {\n    return [...this.dispatchStretch(idx, offset), ...this.dispatchShrink(idx, offset)];\n  } /////////////////////////////////////////////////////////\n  // Emits given if event for each given element\n  // if present in the component props\n  //\n  /////////////////////////////////////////////////////////\n\n\n  emitElementsEvent(elements, event) {\n    this.toArray(elements).forEach(component => {\n      if (component.props[event]) {\n        component.props[event]({\n          domElement: component.ref.current,\n          component\n        });\n      }\n    });\n  } /////////////////////////////////////////////////////////\n  // Computes initial flex data based on provided flex\n  // properties. By default each ReflexElement gets\n  // evenly arranged within its container\n  //\n  /////////////////////////////////////////////////////////\n\n\n  computeFlexData() {\n    var _this = this;\n\n    let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getValidChildren();\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;\n    const pixelFlex = this.computePixelFlex(props.orientation);\n\n    const computeFreeFlex = flexData => {\n      return flexData.reduce((sum, entry) => {\n        if (!ReflexSplitter.isA(entry) && entry.constrained) {\n          return sum - entry.flex;\n        }\n\n        return sum;\n      }, 1.0);\n    };\n\n    const computeFreeElements = flexData => {\n      return flexData.reduce((sum, entry) => {\n        if (!ReflexSplitter.isA(entry) && !entry.constrained) {\n          return sum + 1;\n        }\n\n        return sum;\n      }, 0.0);\n    };\n\n    const flexDataInit = children.map(child => {\n      const props = child.props;\n      return {\n        maxFlex: (props.maxSize || Number.MAX_VALUE) * pixelFlex,\n        sizeFlex: (props.size || Number.MAX_VALUE) * pixelFlex,\n        minFlex: (props.minSize || 1) * pixelFlex,\n        constrained: props.flex !== undefined,\n        flex: props.flex || 0,\n        type: child.type\n      };\n    });\n\n    const computeFlexDataRec = function (flexDataIn) {\n      let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      let hasContrain = false;\n      const freeElements = computeFreeElements(flexDataIn);\n      const freeFlex = computeFreeFlex(flexDataIn);\n      const flexDataOut = flexDataIn.map(entry => {\n        if (ReflexSplitter.isA(entry)) {\n          return entry;\n        }\n\n        const proposedFlex = !entry.constrained ? freeFlex / freeElements : entry.flex;\n        const constrainedFlex = Math.min(entry.sizeFlex, Math.min(entry.maxFlex, Math.max(entry.minFlex, proposedFlex)));\n        const constrained = entry.constrained || constrainedFlex !== proposedFlex;\n        hasContrain = hasContrain || constrained;\n        return _objectSpread({}, entry, {\n          flex: constrainedFlex,\n          constrained\n        });\n      });\n      return hasContrain && depth < _this.props.maxRecDepth ? computeFlexDataRec(flexDataOut, depth + 1) : flexDataOut;\n    };\n\n    const flexData = computeFlexDataRec(flexDataInit);\n    return flexData.map(entry => {\n      return {\n        flex: !ReflexSplitter.isA(entry) ? entry.flex : 0.0,\n        ref: React.createRef()\n      };\n    });\n  } /////////////////////////////////////////////////////////\n  // Utility method to ensure given argument is\n  // returned as an array\n  //\n  /////////////////////////////////////////////////////////\n\n\n  toArray(obj) {\n    return obj ? Array.isArray(obj) ? obj : [obj] : [];\n  } /////////////////////////////////////////////////////////\n  // Render container. This will clone all original child\n  // components in order to pass some internal properties\n  // used to handle resizing logic\n  //\n  /////////////////////////////////////////////////////////\n\n\n  render() {\n    const className = [this.state.resizing ? 'reflex-resizing' : '', ...this.props.className.split(' '), this.props.orientation, 'reflex-container'].join(' ').trim();\n    this.children = React.Children.map(this.getValidChildren(), (child, index) => {\n      if (index > this.state.flexData.length - 1) {\n        return React.createElement(\"div\", null);\n      }\n\n      const flexData = this.state.flexData[index];\n\n      const newProps = _objectSpread({}, child.props, {\n        maxSize: child.props.maxSize || Number.MAX_VALUE,\n        orientation: this.props.orientation,\n        minSize: child.props.minSize || 1,\n        events: this.events,\n        flex: flexData.flex,\n        ref: flexData.ref,\n        index\n      });\n\n      return React.cloneElement(child, newProps);\n    });\n    return React.createElement(\"div\", _extends({}, getDataProps(this.props), {\n      style: this.props.style,\n      className: className,\n      ref: this.ref\n    }), this.children);\n  }\n\n}\n\n_defineProperty(ReflexContainer, \"propTypes\", {\n  windowResizeAware: PropTypes.bool,\n  orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n  maxRecDepth: PropTypes.number,\n  className: PropTypes.string,\n  style: PropTypes.object\n});\n\n_defineProperty(ReflexContainer, \"defaultProps\", {\n  orientation: 'horizontal',\n  windowResizeAware: false,\n  maxRecDepth: 100,\n  className: '',\n  style: {}\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/node_modules/react-reflex/dist/es/ReflexContainer.js"],"names":["_extends","_objectSpread","_defineProperty","ReflexSplitter","ReflexEvents","getDataProps","PropTypes","React","ReflexContainer","Component","constructor","props","setState","flexData","computeFlexData","data","pos","event","changedTouches","orientation","document","body","classList","add","previousPos","clientY","clientX","elements","children","index","emitElementsEvent","offset","getOffset","domElement","availableOffset","computeAvailableOffset","dispatchOffset","adjustFlex","resizing","remove","resizedRefs","map","element","ref","filter","child","isA","includes","Promise","resolve","idx","size","getSize","dir","direction","splitterIdx","state","ex","console","log","events","createRef","componentDidMount","windowResizeAware","window","addEventListener","onWindowResize","on","onElementSize","onStartResize","onStopResize","onResize","componentWillUnmount","off","removeEventListener","getValidChildren","toArray","componentDidUpdate","prevProps","prevState","length","flexHasChanged","prevChildrenFlex","flex","childrenFlex","every","current","offsetHeight","offsetWidth","top","bottom","left","right","getBoundingClientRect","diffFlex","reduce","sum","previousFlex","nextFlex","forEach","stretch","computeAvailableStretch","shrink","computeAvailableShrink","Math","min","sign","checkPropagate","typeCheck","propagate","childIdx","maxSize","availableStretch","abs","nextOffset","minSize","max","availableShrink","computePixelFlex","warn","addOffset","newSize","currentFlex","newFlex","isFinite","isNaN","dispatchStretch","dispatchedStretch","nextIdx","dispatchShrink","dispatchedShrink","component","pixelFlex","computeFreeFlex","entry","constrained","computeFreeElements","flexDataInit","maxFlex","Number","MAX_VALUE","sizeFlex","minFlex","undefined","type","computeFlexDataRec","flexDataIn","depth","hasContrain","freeElements","freeFlex","flexDataOut","proposedFlex","constrainedFlex","maxRecDepth","obj","Array","isArray","render","className","split","join","trim","Children","createElement","newProps","cloneElement","style","bool","oneOf","number","string","object"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n///////////////////////////////////////////////////////////\n// ReflexContainer\n// By Philippe Leefsma\n// December 2016\n//\n///////////////////////////////////////////////////////////\nimport ReflexSplitter from './ReflexSplitter';\nimport ReflexEvents from './ReflexEvents';\nimport { getDataProps } from './utilities';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport './Polyfills';\nexport default class ReflexContainer extends React.Component {\n  /////////////////////////////////////////////////////////\n  // orientation: Orientation of the layout container\n  //              valid values are ['horizontal', 'vertical'] \n  // maxRecDepth: Maximun recursion depth to solve initial flex\n  //              of layout elements based on user provided values\n  // className: Space separated classnames to apply custom styles \n  //            to the layout container  \n  // style: allows passing inline style to the container\n  /////////////////////////////////////////////////////////\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"onWindowResize\", () => {\n      this.setState({\n        flexData: this.computeFlexData()\n      });\n    });\n\n    _defineProperty(this, \"onStartResize\", data => {\n      const pos = data.event.changedTouches ? data.event.changedTouches[0] : data.event;\n\n      switch (this.props.orientation) {\n        case 'horizontal':\n          document.body.classList.add('reflex-row-resize');\n          this.previousPos = pos.clientY;\n          break;\n\n        case 'vertical':\n        default:\n          document.body.classList.add('reflex-col-resize');\n          this.previousPos = pos.clientX;\n          break;\n      }\n\n      this.elements = [this.children[data.index - 1], this.children[data.index + 1]];\n      this.emitElementsEvent(this.elements, 'onStartResize');\n    });\n\n    _defineProperty(this, \"onResize\", data => {\n      const pos = data.event.changedTouches ? data.event.changedTouches[0] : data.event;\n      const offset = this.getOffset(pos, data.domElement);\n\n      switch (this.props.orientation) {\n        case 'horizontal':\n          this.previousPos = pos.clientY;\n          break;\n\n        case 'vertical':\n        default:\n          this.previousPos = pos.clientX;\n          break;\n      }\n\n      if (offset) {\n        const availableOffset = this.computeAvailableOffset(data.index, offset);\n\n        if (availableOffset) {\n          this.elements = this.dispatchOffset(data.index, availableOffset);\n          this.adjustFlex(this.elements);\n          this.setState({\n            resizing: true\n          }, () => {\n            this.emitElementsEvent(this.elements, 'onResize');\n          });\n        }\n      }\n    });\n\n    _defineProperty(this, \"onStopResize\", data => {\n      document.body.classList.remove('reflex-row-resize');\n      document.body.classList.remove('reflex-col-resize');\n      const resizedRefs = this.elements ? this.elements.map(element => {\n        return element.ref;\n      }) : [];\n      const elements = this.children.filter(child => {\n        return !ReflexSplitter.isA(child) && resizedRefs.includes(child.ref);\n      });\n      this.emitElementsEvent(elements, 'onStopResize');\n      this.setState({\n        resizing: false\n      });\n    });\n\n    _defineProperty(this, \"onElementSize\", data => {\n      return new Promise(resolve => {\n        try {\n          const idx = data.index;\n          const size = this.getSize(this.children[idx]);\n          const offset = data.size - size;\n          const dir = data.direction;\n          const splitterIdx = idx + dir;\n          const availableOffset = this.computeAvailableOffset(splitterIdx, dir * offset);\n          this.elements = null;\n\n          if (availableOffset) {\n            this.elements = this.dispatchOffset(splitterIdx, availableOffset);\n            this.adjustFlex(this.elements);\n          }\n\n          this.setState(this.state, () => {\n            this.emitElementsEvent(this.elements, 'onResize');\n            resolve();\n          });\n        } catch (ex) {\n          // TODO handle exception ...\n          console.log(ex);\n        }\n      });\n    });\n\n    this.events = new ReflexEvents();\n    this.children = [];\n    this.state = {\n      flexData: []\n    };\n    this.ref = React.createRef();\n  }\n\n  componentDidMount() {\n    const flexData = this.computeFlexData();\n    const {\n      windowResizeAware\n    } = this.props;\n\n    if (windowResizeAware) {\n      window.addEventListener('resize', this.onWindowResize);\n    }\n\n    this.setState({\n      windowResizeAware,\n      flexData\n    });\n    this.events.on('element.size', this.onElementSize);\n    this.events.on('startResize', this.onStartResize);\n    this.events.on('stopResize', this.onStopResize);\n    this.events.on('resize', this.onResize);\n  }\n\n  componentWillUnmount() {\n    this.events.off();\n    window.removeEventListener('resize', this.onWindowResize);\n  }\n\n  getValidChildren(props = this.props) {\n    return this.toArray(props.children).filter(child => {\n      return !!child;\n    });\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const children = this.getValidChildren(this.props);\n\n    if (children.length !== this.state.flexData.length || prevProps.orientation !== this.props.orientation || this.flexHasChanged(prevProps)) {\n      const flexData = this.computeFlexData(children, this.props);\n      this.setState({\n        flexData\n      });\n    }\n\n    if (this.props.windowResizeAware !== this.state.windowResizeAware) {\n      !this.props.windowResizeAware ? window.removeEventListener('resize', this.onWindowResize) : window.addEventListener('resize', this.onWindowResize);\n      this.setState({\n        windowResizeAware: this.props.windowResizeAware\n      });\n    }\n  } // UNSAFE_componentWillReceiveProps(props) {\n  //   const children = this.getValidChildren(props)\n  //   if (children.length !== this.state.flexData.length || \n  //     props.orientation !== this.props.orientation || \n  //     this.flexHasChanged(props)) \n  //   {\n  //     const flexData = this.computeFlexData(\n  //       children, props)\n  //     this.setState({\n  //       flexData\n  //     });\n  //   }\n  //   if (props.windowResizeAware !== this.state.windowResizeAware) {\n  //     !props.windowResizeAware\n  //       ? window.removeEventListener('resize', this.onWindowResize)\n  //       : window.addEventListener('resize', this.onWindowResize)\n  //     this.setState({\n  //       windowResizeAware: props.windowResizeAware\n  //     })\n  //   }\n  // } \n  /////////////////////////////////////////////////////////\n  // attempts to preserve current flex on window resize\n  //\n  /////////////////////////////////////////////////////////\n\n\n  /////////////////////////////////////////////////////////\n  // Check if flex has changed: this allows updating the\n  // component when different flex is passed as property\n  // to one or several children\n  //\n  /////////////////////////////////////////////////////////\n  flexHasChanged(prevProps) {\n    const prevChildrenFlex = this.getValidChildren(prevProps).map(child => {\n      return child.props.flex || 0;\n    });\n    const childrenFlex = this.getValidChildren().map(child => {\n      return child.props.flex || 0;\n    });\n    return !childrenFlex.every((flex, idx) => {\n      return flex === prevChildrenFlex[idx];\n    });\n  } /////////////////////////////////////////////////////////\n  // Returns size of a ReflexElement\n  //\n  /////////////////////////////////////////////////////////\n\n\n  getSize(element) {\n    const domElement = element.ref.current;\n\n    switch (this.props.orientation) {\n      case 'horizontal':\n        return domElement.offsetHeight;\n\n      case 'vertical':\n      default:\n        return domElement.offsetWidth;\n    }\n  } /////////////////////////////////////////////////////////\n  // Computes offset from pointer position\n  //\n  /////////////////////////////////////////////////////////\n\n\n  getOffset(pos, domElement) {\n    const {\n      top,\n      bottom,\n      left,\n      right\n    } = domElement.getBoundingClientRect();\n\n    switch (this.props.orientation) {\n      case 'horizontal':\n        {\n          const offset = pos.clientY - this.previousPos;\n\n          if (offset > 0) {\n            if (pos.clientY >= top) {\n              return offset;\n            }\n          } else {\n            if (pos.clientY <= bottom) {\n              return offset;\n            }\n          }\n\n          break;\n        }\n\n      case 'vertical':\n      default:\n        {\n          const offset = pos.clientX - this.previousPos;\n\n          if (offset > 0) {\n            if (pos.clientX > left) {\n              return offset;\n            }\n          } else {\n            if (pos.clientX < right) {\n              return offset;\n            }\n          }\n        }\n        break;\n    }\n\n    return 0;\n  } /////////////////////////////////////////////////////////\n  // Handles startResize event\n  //\n  /////////////////////////////////////////////////////////\n\n\n  /////////////////////////////////////////////////////////\n  // Adjusts flex after a dispatch to make sure\n  // total flex of modified elements remains the same\n  //\n  /////////////////////////////////////////////////////////\n  adjustFlex(elements) {\n    const diffFlex = elements.reduce((sum, element) => {\n      const idx = element.props.index;\n      const previousFlex = element.props.flex;\n      const nextFlex = this.state.flexData[idx].flex;\n      return sum + (previousFlex - nextFlex) / elements.length;\n    }, 0);\n    elements.forEach(element => {\n      this.state.flexData[element.props.index].flex += diffFlex;\n    });\n  } /////////////////////////////////////////////////////////\n  // Returns available offset for a given raw offset value\n  // This checks how much the panes can be stretched and\n  // shrink, then returns the min\n  //\n  /////////////////////////////////////////////////////////\n\n\n  computeAvailableOffset(idx, offset) {\n    const stretch = this.computeAvailableStretch(idx, offset);\n    const shrink = this.computeAvailableShrink(idx, offset);\n    const availableOffset = Math.min(stretch, shrink) * Math.sign(offset);\n    return availableOffset;\n  } /////////////////////////////////////////////////////////\n  // Returns true if the next splitter than the one at idx\n  // can propagate the drag. This can happen if that\n  // next element is actually a splitter and it has\n  // propagate=true property set\n  //\n  /////////////////////////////////////////////////////////\n\n\n  checkPropagate(idx, direction) {\n    if (direction > 0) {\n      if (idx < this.children.length - 2) {\n        const child = this.children[idx + 2];\n        const typeCheck = ReflexSplitter.isA(child);\n        return typeCheck && child.props.propagate;\n      }\n    } else {\n      if (idx > 2) {\n        const child = this.children[idx - 2];\n        const typeCheck = ReflexSplitter.isA(child);\n        return typeCheck && child.props.propagate;\n      }\n    }\n\n    return false;\n  } /////////////////////////////////////////////////////////\n  // Recursively computes available stretch at splitter\n  // idx for given raw offset\n  //\n  /////////////////////////////////////////////////////////\n\n\n  computeAvailableStretch(idx, offset) {\n    const childIdx = offset < 0 ? idx + 1 : idx - 1;\n    const child = this.children[childIdx];\n    const size = this.getSize(child);\n    const maxSize = child.props.maxSize;\n    const availableStretch = maxSize - size;\n\n    if (availableStretch < Math.abs(offset)) {\n      if (this.checkPropagate(idx, -1 * offset)) {\n        const nextOffset = Math.sign(offset) * (Math.abs(offset) - availableStretch);\n        return availableStretch + this.computeAvailableStretch(offset < 0 ? idx + 2 : idx - 2, nextOffset);\n      }\n    }\n\n    return Math.min(availableStretch, Math.abs(offset));\n  } /////////////////////////////////////////////////////////\n  // Recursively computes available shrink at splitter\n  // idx for given raw offset\n  //\n  /////////////////////////////////////////////////////////\n\n\n  computeAvailableShrink(idx, offset) {\n    const childIdx = offset > 0 ? idx + 1 : idx - 1;\n    const child = this.children[childIdx];\n    const size = this.getSize(child);\n    const minSize = Math.max(child.props.minSize, 0);\n    const availableShrink = size - minSize;\n\n    if (availableShrink < Math.abs(offset)) {\n      if (this.checkPropagate(idx, offset)) {\n        const nextOffset = Math.sign(offset) * (Math.abs(offset) - availableShrink);\n        return availableShrink + this.computeAvailableShrink(offset > 0 ? idx + 2 : idx - 2, nextOffset);\n      }\n    }\n\n    return Math.min(availableShrink, Math.abs(offset));\n  } /////////////////////////////////////////////////////////\n  // Returns flex value for unit pixel\n  //\n  /////////////////////////////////////////////////////////\n\n\n  computePixelFlex(orientation = this.props.orientation) {\n    if (!this.ref.current) {\n      console.warn('Unable to locate ReflexContainer dom node');\n      return 0.0;\n    }\n\n    switch (orientation) {\n      case 'horizontal':\n        if (this.ref.current.offsetHeight === 0.0) {\n          console.warn('Found ReflexContainer with height=0, ' + 'this will cause invalid behavior...');\n          console.warn(this.ref.current);\n          return 0.0;\n        }\n\n        return 1.0 / this.ref.current.offsetHeight;\n\n      case 'vertical':\n      default:\n        if (this.ref.current.offsetWidth === 0.0) {\n          console.warn('Found ReflexContainer with width=0, ' + 'this will cause invalid behavior...');\n          console.warn(this.ref.current);\n          return 0.0;\n        }\n\n        return 1.0 / this.ref.current.offsetWidth;\n    }\n  } /////////////////////////////////////////////////////////\n  // Adds offset to a given ReflexElement\n  //\n  /////////////////////////////////////////////////////////\n\n\n  addOffset(element, offset) {\n    const size = this.getSize(element);\n    const idx = element.props.index;\n    const newSize = Math.max(size + offset, 0);\n    const currentFlex = this.state.flexData[idx].flex;\n    const newFlex = currentFlex > 0 ? currentFlex * newSize / size : this.computePixelFlex() * newSize;\n    this.state.flexData[idx].flex = !isFinite(newFlex) || isNaN(newFlex) ? 0 : newFlex;\n  } /////////////////////////////////////////////////////////\n  // Recursively dispatches stretch offset across\n  // children elements starting at splitter idx\n  //\n  /////////////////////////////////////////////////////////\n\n\n  dispatchStretch(idx, offset) {\n    const childIdx = offset < 0 ? idx + 1 : idx - 1;\n\n    if (childIdx < 0 || childIdx > this.children.length - 1) {\n      return [];\n    }\n\n    const child = this.children[childIdx];\n    const size = this.getSize(child);\n    const newSize = Math.min(child.props.maxSize, size + Math.abs(offset));\n    const dispatchedStretch = newSize - size;\n    this.addOffset(child, dispatchedStretch);\n\n    if (dispatchedStretch < Math.abs(offset)) {\n      const nextIdx = idx - Math.sign(offset) * 2;\n      const nextOffset = Math.sign(offset) * (Math.abs(offset) - dispatchedStretch);\n      return [child, ...this.dispatchStretch(nextIdx, nextOffset)];\n    }\n\n    return [child];\n  } /////////////////////////////////////////////////////////\n  // Recursively dispatches shrink offset across\n  // children elements starting at splitter idx\n  //\n  /////////////////////////////////////////////////////////\n\n\n  dispatchShrink(idx, offset) {\n    const childIdx = offset > 0 ? idx + 1 : idx - 1;\n\n    if (childIdx < 0 || childIdx > this.children.length - 1) {\n      return [];\n    }\n\n    const child = this.children[childIdx];\n    const size = this.getSize(child);\n    const newSize = Math.max(child.props.minSize, size - Math.abs(offset));\n    const dispatchedShrink = newSize - size;\n    this.addOffset(child, dispatchedShrink);\n\n    if (Math.abs(dispatchedShrink) < Math.abs(offset)) {\n      const nextIdx = idx + Math.sign(offset) * 2;\n      const nextOffset = Math.sign(offset) * (Math.abs(offset) + dispatchedShrink);\n      return [child, ...this.dispatchShrink(nextIdx, nextOffset)];\n    }\n\n    return [child];\n  } /////////////////////////////////////////////////////////\n  // Dispatch offset at splitter idx\n  //\n  /////////////////////////////////////////////////////////\n\n\n  dispatchOffset(idx, offset) {\n    return [...this.dispatchStretch(idx, offset), ...this.dispatchShrink(idx, offset)];\n  } /////////////////////////////////////////////////////////\n  // Emits given if event for each given element\n  // if present in the component props\n  //\n  /////////////////////////////////////////////////////////\n\n\n  emitElementsEvent(elements, event) {\n    this.toArray(elements).forEach(component => {\n      if (component.props[event]) {\n        component.props[event]({\n          domElement: component.ref.current,\n          component\n        });\n      }\n    });\n  } /////////////////////////////////////////////////////////\n  // Computes initial flex data based on provided flex\n  // properties. By default each ReflexElement gets\n  // evenly arranged within its container\n  //\n  /////////////////////////////////////////////////////////\n\n\n  computeFlexData(children = this.getValidChildren(), props = this.props) {\n    const pixelFlex = this.computePixelFlex(props.orientation);\n\n    const computeFreeFlex = flexData => {\n      return flexData.reduce((sum, entry) => {\n        if (!ReflexSplitter.isA(entry) && entry.constrained) {\n          return sum - entry.flex;\n        }\n\n        return sum;\n      }, 1.0);\n    };\n\n    const computeFreeElements = flexData => {\n      return flexData.reduce((sum, entry) => {\n        if (!ReflexSplitter.isA(entry) && !entry.constrained) {\n          return sum + 1;\n        }\n\n        return sum;\n      }, 0.0);\n    };\n\n    const flexDataInit = children.map(child => {\n      const props = child.props;\n      return {\n        maxFlex: (props.maxSize || Number.MAX_VALUE) * pixelFlex,\n        sizeFlex: (props.size || Number.MAX_VALUE) * pixelFlex,\n        minFlex: (props.minSize || 1) * pixelFlex,\n        constrained: props.flex !== undefined,\n        flex: props.flex || 0,\n        type: child.type\n      };\n    });\n\n    const computeFlexDataRec = (flexDataIn, depth = 0) => {\n      let hasContrain = false;\n      const freeElements = computeFreeElements(flexDataIn);\n      const freeFlex = computeFreeFlex(flexDataIn);\n      const flexDataOut = flexDataIn.map(entry => {\n        if (ReflexSplitter.isA(entry)) {\n          return entry;\n        }\n\n        const proposedFlex = !entry.constrained ? freeFlex / freeElements : entry.flex;\n        const constrainedFlex = Math.min(entry.sizeFlex, Math.min(entry.maxFlex, Math.max(entry.minFlex, proposedFlex)));\n        const constrained = entry.constrained || constrainedFlex !== proposedFlex;\n        hasContrain = hasContrain || constrained;\n        return _objectSpread({}, entry, {\n          flex: constrainedFlex,\n          constrained\n        });\n      });\n      return hasContrain && depth < this.props.maxRecDepth ? computeFlexDataRec(flexDataOut, depth + 1) : flexDataOut;\n    };\n\n    const flexData = computeFlexDataRec(flexDataInit);\n    return flexData.map(entry => {\n      return {\n        flex: !ReflexSplitter.isA(entry) ? entry.flex : 0.0,\n        ref: React.createRef()\n      };\n    });\n  } /////////////////////////////////////////////////////////\n  // Utility method to ensure given argument is\n  // returned as an array\n  //\n  /////////////////////////////////////////////////////////\n\n\n  toArray(obj) {\n    return obj ? Array.isArray(obj) ? obj : [obj] : [];\n  } /////////////////////////////////////////////////////////\n  // Render container. This will clone all original child\n  // components in order to pass some internal properties\n  // used to handle resizing logic\n  //\n  /////////////////////////////////////////////////////////\n\n\n  render() {\n    const className = [this.state.resizing ? 'reflex-resizing' : '', ...this.props.className.split(' '), this.props.orientation, 'reflex-container'].join(' ').trim();\n    this.children = React.Children.map(this.getValidChildren(), (child, index) => {\n      if (index > this.state.flexData.length - 1) {\n        return React.createElement(\"div\", null);\n      }\n\n      const flexData = this.state.flexData[index];\n\n      const newProps = _objectSpread({}, child.props, {\n        maxSize: child.props.maxSize || Number.MAX_VALUE,\n        orientation: this.props.orientation,\n        minSize: child.props.minSize || 1,\n        events: this.events,\n        flex: flexData.flex,\n        ref: flexData.ref,\n        index\n      });\n\n      return React.cloneElement(child, newProps);\n    });\n    return React.createElement(\"div\", _extends({}, getDataProps(this.props), {\n      style: this.props.style,\n      className: className,\n      ref: this.ref\n    }), this.children);\n  }\n\n}\n\n_defineProperty(ReflexContainer, \"propTypes\", {\n  windowResizeAware: PropTypes.bool,\n  orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n  maxRecDepth: PropTypes.number,\n  className: PropTypes.string,\n  style: PropTypes.object\n});\n\n_defineProperty(ReflexContainer, \"defaultProps\", {\n  orientation: 'horizontal',\n  windowResizeAware: false,\n  maxRecDepth: 100,\n  className: '',\n  style: {}\n});"]},"metadata":{},"sourceType":"module"}