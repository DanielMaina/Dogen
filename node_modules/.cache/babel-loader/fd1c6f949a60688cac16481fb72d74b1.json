{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nimport { ChainId, currencyEquals, JSBI, Price, WETH } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { PairState, usePairs, usePair } from 'data/Reserves';\nimport { useActiveWeb3React } from 'hooks';\nimport { unwrappedToken, wrappedCurrency } from './wrappedCurrency';\nimport { useDQUICKtoQUICK } from 'state/stake/hooks';\nimport { GlobalValue } from 'constants/index';\n/**\n * Returns the price in USDC of the input currency\n * @param currency currency to compute the USDC price of\n */\n\nexport default function useUSDCPrice(currency) {\n  _s();\n\n  var _wrapped;\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  let wrapped = wrappedCurrency(currency, chainId);\n  const internalWrapped = wrapped;\n\n  if ((_wrapped = wrapped) !== null && _wrapped !== void 0 && _wrapped.equals(GlobalValue.tokens.COMMON.CXETH)) {\n    wrapped = wrappedCurrency(GlobalValue.tokens.COMMON.ETHER, chainId);\n  }\n\n  const oldQuickToken = GlobalValue.tokens.COMMON.OLD_QUICK;\n  const usdcToken = GlobalValue.tokens.COMMON.USDC;\n  const usdtToken = GlobalValue.tokens.COMMON.USDT;\n  const daiToken = GlobalValue.tokens.COMMON.DAI;\n  const cxETHToken = GlobalValue.tokens.COMMON.CXETH;\n  const tokenPairs = useMemo(() => {\n    var _wrapped2, _wrapped3, _wrapped4, _wrapped5;\n\n    return [[chainId && wrapped && currencyEquals(WETH[chainId], wrapped) ? undefined : wrapped, chainId ? WETH[chainId] : undefined], [(_wrapped2 = wrapped) !== null && _wrapped2 !== void 0 && _wrapped2.equals(oldQuickToken) ? undefined : wrapped, chainId === ChainId.MAINNET ? oldQuickToken : undefined], [(_wrapped3 = wrapped) !== null && _wrapped3 !== void 0 && _wrapped3.equals(usdcToken) ? undefined : wrapped, chainId === ChainId.MAINNET ? usdcToken : undefined], [(_wrapped4 = wrapped) !== null && _wrapped4 !== void 0 && _wrapped4.equals(usdtToken) ? undefined : wrapped, chainId === ChainId.MAINNET ? usdtToken : undefined], [(_wrapped5 = wrapped) !== null && _wrapped5 !== void 0 && _wrapped5.equals(daiToken) ? undefined : wrapped, chainId === ChainId.MAINNET ? daiToken : undefined], [chainId ? WETH[chainId] : undefined, chainId === ChainId.MAINNET ? usdcToken : undefined], [chainId === ChainId.MAINNET ? oldQuickToken : undefined, chainId === ChainId.MAINNET ? usdcToken : undefined]];\n  }, [chainId, wrapped, daiToken, oldQuickToken, usdcToken, usdtToken]);\n  const [[ethPairState, ethPair], [quickPairState, quickPair], [usdcPairState, usdcPair], [usdtPairState, usdtPair], [daiPairState, daiPair], [usdcEthPairState, usdcEthPair], [usdcQuickPairState, usdcQuickPair]] = usePairs(tokenPairs);\n  return useMemo(() => {\n    if (!currency || !wrapped || !chainId) {\n      return undefined;\n    } // handle weth/eth\n\n\n    if (wrapped.equals(WETH[chainId])) {\n      if (usdcPair) {\n        const price = usdcPair.priceOf(WETH[chainId]);\n        return new Price(currency, usdcToken, price.denominator, price.numerator);\n      } else {\n        return undefined;\n      }\n    } // handle usdc\n\n\n    if (wrapped.equals(usdcToken)) {\n      return new Price(usdcToken, usdcToken, '1', '1');\n    }\n\n    const ethPairETHAmount = ethPair === null || ethPair === void 0 ? void 0 : ethPair.reserveOf(WETH[chainId]);\n    const ethPairETHUSDCValue = ethPairETHAmount && usdcEthPair ? usdcEthPair.priceOf(WETH[chainId]).quote(ethPairETHAmount).raw : JSBI.BigInt(0); // all other tokens\n    // first try the usdc pair\n\n    if (usdcPairState === PairState.EXISTS && usdcPair && usdcPair.reserveOf(usdcToken).greaterThan(ethPairETHUSDCValue)) {\n      const price = usdcPair.priceOf(wrapped);\n\n      if (internalWrapped !== null && internalWrapped !== void 0 && internalWrapped.equals(cxETHToken)) {\n        return new Price(cxETHToken, usdcToken, price.denominator, price.numerator);\n      }\n\n      return new Price(currency, usdcToken, price.denominator, price.numerator);\n    }\n\n    if (usdtPairState === PairState.EXISTS && usdtPair && usdtPair.reserveOf(usdtToken).greaterThan(ethPairETHUSDCValue)) {\n      const price = usdtPair.priceOf(wrapped);\n      return new Price(currency, usdtToken, price.denominator, price.numerator);\n    }\n\n    if (daiPairState === PairState.EXISTS && daiPair && daiPair.reserveOf(daiToken).greaterThan(ethPairETHUSDCValue)) {\n      const price = daiPair.priceOf(wrapped);\n      return new Price(currency, daiToken, price.denominator, price.numerator);\n    }\n\n    if (ethPairState === PairState.EXISTS && ethPair && usdcEthPairState === PairState.EXISTS && usdcEthPair) {\n      if (usdcEthPair.reserveOf(usdcToken).greaterThan('0') && ethPair.reserveOf(WETH[chainId]).greaterThan('1')) {\n        const ethUsdcPrice = usdcEthPair.priceOf(usdcToken);\n        const currencyEthPrice = ethPair.priceOf(WETH[chainId]);\n        const usdcPrice = ethUsdcPrice.multiply(currencyEthPrice).invert();\n        return new Price(currency, usdcToken, usdcPrice.denominator, usdcPrice.numerator);\n      }\n    }\n\n    if (quickPairState === PairState.EXISTS && quickPair && usdcQuickPairState === PairState.EXISTS && usdcQuickPair) {\n      if (usdcQuickPair.reserveOf(usdcToken).greaterThan('0') && quickPair.reserveOf(oldQuickToken).greaterThan('5')) {\n        const quickUsdcPrice = usdcQuickPair.priceOf(usdcToken);\n        const currencyQuickPrice = quickPair.priceOf(oldQuickToken);\n        const usdcPrice = quickUsdcPrice.multiply(currencyQuickPrice).invert();\n        return new Price(currency, usdcToken, usdcPrice.denominator, usdcPrice.numerator);\n      }\n    }\n\n    return undefined;\n  }, [currency, wrapped, chainId, ethPair, usdcEthPair, usdcPairState, usdcPair, usdtPairState, usdtPair, daiPairState, daiPair, ethPairState, usdcEthPairState, quickPairState, quickPair, usdcQuickPairState, usdcQuickPair, internalWrapped, cxETHToken, daiToken, oldQuickToken, usdcToken, usdtToken]);\n} //TODO: the majority of these functions share alot of common logic,\n//There also seems to be bugs, sometimes the CXETH Pair returns CXEth, sometimes ETH\n//Investigate more fully\n\n_s(useUSDCPrice, \"IdgwIO76QYh/fqCvq5EXWc9n0+k=\", false, function () {\n  return [useActiveWeb3React, usePairs];\n});\n\nexport function useUSDCPrices(currencies) {\n  _s2();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const oldQuickToken = GlobalValue.tokens.COMMON.OLD_QUICK;\n  const usdcToken = GlobalValue.tokens.COMMON.USDC;\n  const usdtToken = GlobalValue.tokens.COMMON.USDT;\n  const daiToken = GlobalValue.tokens.COMMON.DAI;\n  const cxETHToken = GlobalValue.tokens.COMMON.CXETH;\n  const ETHToken = GlobalValue.tokens.COMMON.CXETH;\n  const wrappedCurrencies = currencies.map(currency => {\n    var _wrapped6;\n\n    let wrapped = wrappedCurrency(currency, chainId);\n\n    if ((_wrapped6 = wrapped) !== null && _wrapped6 !== void 0 && _wrapped6.equals(cxETHToken)) {\n      wrapped = wrappedCurrency(ETHToken, chainId);\n    }\n\n    return wrapped;\n  });\n  const tokenPairs = [];\n  wrappedCurrencies.forEach((wrapped, ind) => {\n    tokenPairs.push([chainId && wrapped && currencyEquals(WETH[chainId], wrapped) ? undefined : currencies[ind], chainId ? WETH[chainId] : undefined]);\n    tokenPairs.push([wrapped !== null && wrapped !== void 0 && wrapped.equals(oldQuickToken) ? undefined : wrapped, chainId === ChainId.MAINNET ? oldQuickToken : undefined]);\n    tokenPairs.push([wrapped !== null && wrapped !== void 0 && wrapped.equals(usdcToken) ? undefined : wrapped, chainId === ChainId.MAINNET ? usdcToken : undefined]);\n    tokenPairs.push([wrapped !== null && wrapped !== void 0 && wrapped.equals(usdtToken) ? undefined : wrapped, chainId === ChainId.MAINNET ? usdtToken : undefined]);\n    tokenPairs.push([wrapped !== null && wrapped !== void 0 && wrapped.equals(daiToken) ? undefined : wrapped, chainId === ChainId.MAINNET ? daiToken : undefined]);\n    tokenPairs.push([chainId ? WETH[chainId] : undefined, chainId === ChainId.MAINNET ? usdcToken : undefined]);\n    tokenPairs.push([chainId ? oldQuickToken : undefined, chainId === ChainId.MAINNET ? usdcToken : undefined]);\n  });\n  const pairs = usePairs(tokenPairs);\n  const remainPairs = currencies.map((_, index) => {\n    return pairs.slice(7 * index, 7 * (index + 1));\n  });\n  return currencies.map((currency, index) => {\n    const [[ethPairState, ethPair], [quickPairState, quickPair], [usdcPairState, usdcPair], [usdtPairState, usdtPair], [daiPairState, daiPair], [usdcEthPairState, usdcEthPair], [usdcQuickPairState, usdcQuickPair]] = remainPairs[index];\n    const wrapped = wrappedCurrencies[index];\n    const internalWrapped = wrappedCurrency(currency, chainId);\n\n    if (!wrapped || !chainId) {\n      return undefined;\n    }\n\n    if (wrapped.equals(WETH[chainId])) {\n      if (usdcPair) {\n        const price = usdcPair.priceOf(WETH[chainId]);\n        return new Price(currency, usdcToken, price.denominator, price.numerator);\n      } else {\n        return undefined;\n      }\n    } // handle usdc\n\n\n    if (wrapped.equals(usdcToken)) {\n      return new Price(usdcToken, usdcToken, '1', '1');\n    }\n\n    const ethPairETHAmount = ethPair === null || ethPair === void 0 ? void 0 : ethPair.reserveOf(WETH[chainId]);\n    const ethPairETHUSDCValue = ethPairETHAmount && usdcEthPair ? usdcEthPair.priceOf(WETH[chainId]).quote(ethPairETHAmount).raw : JSBI.BigInt(0); // all other tokens\n    // first try the usdc pair\n\n    if (usdcPairState === PairState.EXISTS && usdcPair && usdcPair.reserveOf(usdcToken).greaterThan(ethPairETHUSDCValue)) {\n      const price = usdcPair.priceOf(wrapped);\n\n      if (internalWrapped !== null && internalWrapped !== void 0 && internalWrapped.equals(cxETHToken)) {\n        return new Price(cxETHToken, usdcToken, price.denominator, price.numerator);\n      }\n\n      return new Price(currency, usdcToken, price.denominator, price.numerator);\n    }\n\n    if (usdtPairState === PairState.EXISTS && usdtPair && usdtPair.reserveOf(usdtToken).greaterThan(ethPairETHUSDCValue)) {\n      const price = usdtPair.priceOf(wrapped);\n      return new Price(currency, usdtToken, price.denominator, price.numerator);\n    }\n\n    if (daiPairState === PairState.EXISTS && daiPair && daiPair.reserveOf(daiToken).greaterThan(ethPairETHUSDCValue)) {\n      const price = daiPair.priceOf(wrapped);\n      return new Price(currency, daiToken, price.denominator, price.numerator);\n    }\n\n    if (ethPairState === PairState.EXISTS && ethPair && usdcEthPairState === PairState.EXISTS && usdcEthPair) {\n      if (usdcEthPair.reserveOf(usdcToken).greaterThan('0') && ethPair.reserveOf(WETH[chainId]).greaterThan('1')) {\n        const ethUsdcPrice = usdcEthPair.priceOf(usdcToken);\n        const currencyEthPrice = ethPair.priceOf(WETH[chainId]);\n        const usdcPrice = ethUsdcPrice.multiply(currencyEthPrice).invert();\n        return new Price(currency, usdcToken, usdcPrice.denominator, usdcPrice.numerator);\n      }\n    }\n\n    if (quickPairState === PairState.EXISTS && quickPair && usdcQuickPairState === PairState.EXISTS && usdcQuickPair) {\n      if (usdcQuickPair.reserveOf(usdcToken).greaterThan('0') && quickPair.reserveOf(oldQuickToken).greaterThan('5')) {\n        const quickUsdcPrice = usdcQuickPair.priceOf(usdcToken);\n        const currencyQuickPrice = quickPair.priceOf(oldQuickToken);\n        const usdcPrice = quickUsdcPrice.multiply(currencyQuickPrice).invert();\n        return new Price(currency, usdcToken, usdcPrice.denominator, usdcPrice.numerator);\n      }\n    }\n\n    return undefined;\n  });\n}\n\n_s2(useUSDCPrices, \"2bk/DE1M6MX3rFhZ2kwqdb90iyI=\", false, function () {\n  return [useActiveWeb3React, usePairs];\n});\n\nexport function useUSDCPricesToken(tokens) {\n  _s3();\n\n  var _quickUsdcPair$priceO, _quickUsdcPair$priceO2, _newQuickUsdcPair$pri, _newQuickUsdcPair$pri2;\n\n  const dQUICKtoQUICK = useDQUICKtoQUICK();\n  const oldQuickToken = GlobalValue.tokens.COMMON.OLD_QUICK;\n  const oldDQuickToken = GlobalValue.tokens.COMMON.OLD_DQUICK;\n  const newQuickToken = GlobalValue.tokens.COMMON.NEW_QUICK;\n  const newDQuickToken = GlobalValue.tokens.COMMON.NEW_DQUICK;\n  const usdcToken = GlobalValue.tokens.COMMON.USDC;\n  const [, quickUsdcPair] = usePair(oldQuickToken, usdcToken);\n  const [, newQuickUsdcPair] = usePair(newQuickToken, usdcToken);\n  const quickPrice = Number((_quickUsdcPair$priceO = quickUsdcPair === null || quickUsdcPair === void 0 ? void 0 : (_quickUsdcPair$priceO2 = quickUsdcPair.priceOf(oldQuickToken)) === null || _quickUsdcPair$priceO2 === void 0 ? void 0 : _quickUsdcPair$priceO2.toSignificant(6)) !== null && _quickUsdcPair$priceO !== void 0 ? _quickUsdcPair$priceO : 0);\n  const newQuickPrice = Number((_newQuickUsdcPair$pri = newQuickUsdcPair === null || newQuickUsdcPair === void 0 ? void 0 : (_newQuickUsdcPair$pri2 = newQuickUsdcPair.priceOf(newQuickToken)) === null || _newQuickUsdcPair$pri2 === void 0 ? void 0 : _newQuickUsdcPair$pri2.toSignificant(6)) !== null && _newQuickUsdcPair$pri !== void 0 ? _newQuickUsdcPair$pri : 0);\n  const filteredTokens = tokens.filter((item, pos, self) => {\n    return self.findIndex(token => token.equals(item)) == pos;\n  }).filter(token => !token.equals(oldQuickToken) && !token.equals(newQuickToken) && !token.equals(oldDQuickToken) && !token.equals(newDQuickToken));\n  const currencies = filteredTokens.map(token => unwrappedToken(token));\n  const usdPrices = useUSDCPrices(currencies);\n  const usdPricesWithToken = filteredTokens.map((token, index) => {\n    var _usdPrices$index$toSi, _usdPrices$index;\n\n    return {\n      token,\n      price: Number((_usdPrices$index$toSi = (_usdPrices$index = usdPrices[index]) === null || _usdPrices$index === void 0 ? void 0 : _usdPrices$index.toSignificant(6)) !== null && _usdPrices$index$toSi !== void 0 ? _usdPrices$index$toSi : 0)\n    };\n  });\n  return tokens.map(token => {\n    if (token.equals(oldDQuickToken)) {\n      return dQUICKtoQUICK * quickPrice;\n    } else if (token.equals(oldQuickToken)) {\n      return quickPrice;\n    } else if (token.equals(newDQuickToken)) {\n      return dQUICKtoQUICK * newQuickPrice;\n    } else if (token.equals(newQuickToken)) {\n      return newQuickPrice;\n    } else {\n      var _priceObj$price;\n\n      const priceObj = usdPricesWithToken.find(item => item.token.equals(token));\n      return (_priceObj$price = priceObj === null || priceObj === void 0 ? void 0 : priceObj.price) !== null && _priceObj$price !== void 0 ? _priceObj$price : 0;\n    }\n  });\n}\n\n_s3(useUSDCPricesToken, \"4iu0MzZpTsQcfRdlU/f1etuUWRM=\", false, function () {\n  return [useDQUICKtoQUICK, usePair, usePair, useUSDCPrices];\n});\n\nexport function useUSDCPriceToken(token) {\n  _s4();\n\n  return useUSDCPricesToken([token])[0];\n}\n\n_s4(useUSDCPriceToken, \"0oEHGnWZXpCkYXwgSneBrOEbExQ=\", false, function () {\n  return [useUSDCPricesToken];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/utils/useUSDCPrice.ts"],"names":["ChainId","currencyEquals","JSBI","Price","WETH","useMemo","PairState","usePairs","usePair","useActiveWeb3React","unwrappedToken","wrappedCurrency","useDQUICKtoQUICK","GlobalValue","useUSDCPrice","currency","chainId","wrapped","internalWrapped","equals","tokens","COMMON","CXETH","ETHER","oldQuickToken","OLD_QUICK","usdcToken","USDC","usdtToken","USDT","daiToken","DAI","cxETHToken","tokenPairs","undefined","MAINNET","ethPairState","ethPair","quickPairState","quickPair","usdcPairState","usdcPair","usdtPairState","usdtPair","daiPairState","daiPair","usdcEthPairState","usdcEthPair","usdcQuickPairState","usdcQuickPair","price","priceOf","denominator","numerator","ethPairETHAmount","reserveOf","ethPairETHUSDCValue","quote","raw","BigInt","EXISTS","greaterThan","ethUsdcPrice","currencyEthPrice","usdcPrice","multiply","invert","quickUsdcPrice","currencyQuickPrice","useUSDCPrices","currencies","ETHToken","wrappedCurrencies","map","forEach","ind","push","pairs","remainPairs","_","index","slice","useUSDCPricesToken","dQUICKtoQUICK","oldDQuickToken","OLD_DQUICK","newQuickToken","NEW_QUICK","newDQuickToken","NEW_DQUICK","quickUsdcPair","newQuickUsdcPair","quickPrice","Number","toSignificant","newQuickPrice","filteredTokens","filter","item","pos","self","findIndex","token","usdPrices","usdPricesWithToken","priceObj","find","useUSDCPriceToken"],"mappings":"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","sourcesContent":["import {\n  ChainId,\n  Currency,\n  currencyEquals,\n  JSBI,\n  Price,\n  WETH,\n  Token,\n} from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { PairState, usePairs, usePair } from 'data/Reserves';\nimport { useActiveWeb3React } from 'hooks';\nimport { unwrappedToken, wrappedCurrency } from './wrappedCurrency';\nimport { useDQUICKtoQUICK } from 'state/stake/hooks';\nimport { GlobalValue } from 'constants/index';\n\n/**\n * Returns the price in USDC of the input currency\n * @param currency currency to compute the USDC price of\n */\nexport default function useUSDCPrice(currency?: Currency): Price | undefined {\n  const { chainId } = useActiveWeb3React();\n  let wrapped = wrappedCurrency(currency, chainId);\n  const internalWrapped = wrapped;\n  if (wrapped?.equals(GlobalValue.tokens.COMMON.CXETH)) {\n    wrapped = wrappedCurrency(GlobalValue.tokens.COMMON.ETHER, chainId);\n  }\n  const oldQuickToken = GlobalValue.tokens.COMMON.OLD_QUICK;\n  const usdcToken = GlobalValue.tokens.COMMON.USDC;\n  const usdtToken = GlobalValue.tokens.COMMON.USDT;\n  const daiToken = GlobalValue.tokens.COMMON.DAI;\n  const cxETHToken = GlobalValue.tokens.COMMON.CXETH;\n  const tokenPairs: [Currency | undefined, Currency | undefined][] = useMemo(\n    () => [\n      [\n        chainId && wrapped && currencyEquals(WETH[chainId], wrapped)\n          ? undefined\n          : wrapped,\n        chainId ? WETH[chainId] : undefined,\n      ],\n      [\n        wrapped?.equals(oldQuickToken) ? undefined : wrapped,\n        chainId === ChainId.MAINNET ? oldQuickToken : undefined,\n      ],\n      [\n        wrapped?.equals(usdcToken) ? undefined : wrapped,\n        chainId === ChainId.MAINNET ? usdcToken : undefined,\n      ],\n      [\n        wrapped?.equals(usdtToken) ? undefined : wrapped,\n        chainId === ChainId.MAINNET ? usdtToken : undefined,\n      ],\n      [\n        wrapped?.equals(daiToken) ? undefined : wrapped,\n        chainId === ChainId.MAINNET ? daiToken : undefined,\n      ],\n      [\n        chainId ? WETH[chainId] : undefined,\n        chainId === ChainId.MAINNET ? usdcToken : undefined,\n      ],\n      [\n        chainId === ChainId.MAINNET ? oldQuickToken : undefined,\n        chainId === ChainId.MAINNET ? usdcToken : undefined,\n      ],\n    ],\n    [chainId, wrapped, daiToken, oldQuickToken, usdcToken, usdtToken],\n  );\n  const [\n    [ethPairState, ethPair],\n    [quickPairState, quickPair],\n    [usdcPairState, usdcPair],\n    [usdtPairState, usdtPair],\n    [daiPairState, daiPair],\n    [usdcEthPairState, usdcEthPair],\n    [usdcQuickPairState, usdcQuickPair],\n  ] = usePairs(tokenPairs);\n\n  return useMemo(() => {\n    if (!currency || !wrapped || !chainId) {\n      return undefined;\n    }\n    // handle weth/eth\n    if (wrapped.equals(WETH[chainId])) {\n      if (usdcPair) {\n        const price = usdcPair.priceOf(WETH[chainId]);\n        return new Price(\n          currency,\n          usdcToken,\n          price.denominator,\n          price.numerator,\n        );\n      } else {\n        return undefined;\n      }\n    }\n    // handle usdc\n    if (wrapped.equals(usdcToken)) {\n      return new Price(usdcToken, usdcToken, '1', '1');\n    }\n\n    const ethPairETHAmount = ethPair?.reserveOf(WETH[chainId]);\n    const ethPairETHUSDCValue: JSBI =\n      ethPairETHAmount && usdcEthPair\n        ? usdcEthPair.priceOf(WETH[chainId]).quote(ethPairETHAmount).raw\n        : JSBI.BigInt(0);\n\n    // all other tokens\n    // first try the usdc pair\n    if (\n      usdcPairState === PairState.EXISTS &&\n      usdcPair &&\n      usdcPair.reserveOf(usdcToken).greaterThan(ethPairETHUSDCValue)\n    ) {\n      const price = usdcPair.priceOf(wrapped);\n\n      if (internalWrapped?.equals(cxETHToken)) {\n        return new Price(\n          cxETHToken,\n          usdcToken,\n          price.denominator,\n          price.numerator,\n        );\n      }\n\n      return new Price(currency, usdcToken, price.denominator, price.numerator);\n    }\n    if (\n      usdtPairState === PairState.EXISTS &&\n      usdtPair &&\n      usdtPair.reserveOf(usdtToken).greaterThan(ethPairETHUSDCValue)\n    ) {\n      const price = usdtPair.priceOf(wrapped);\n      return new Price(currency, usdtToken, price.denominator, price.numerator);\n    }\n    if (\n      daiPairState === PairState.EXISTS &&\n      daiPair &&\n      daiPair.reserveOf(daiToken).greaterThan(ethPairETHUSDCValue)\n    ) {\n      const price = daiPair.priceOf(wrapped);\n      return new Price(currency, daiToken, price.denominator, price.numerator);\n    }\n    if (\n      ethPairState === PairState.EXISTS &&\n      ethPair &&\n      usdcEthPairState === PairState.EXISTS &&\n      usdcEthPair\n    ) {\n      if (\n        usdcEthPair.reserveOf(usdcToken).greaterThan('0') &&\n        ethPair.reserveOf(WETH[chainId]).greaterThan('1')\n      ) {\n        const ethUsdcPrice = usdcEthPair.priceOf(usdcToken);\n        const currencyEthPrice = ethPair.priceOf(WETH[chainId]);\n        const usdcPrice = ethUsdcPrice.multiply(currencyEthPrice).invert();\n        return new Price(\n          currency,\n          usdcToken,\n          usdcPrice.denominator,\n          usdcPrice.numerator,\n        );\n      }\n    }\n    if (\n      quickPairState === PairState.EXISTS &&\n      quickPair &&\n      usdcQuickPairState === PairState.EXISTS &&\n      usdcQuickPair\n    ) {\n      if (\n        usdcQuickPair.reserveOf(usdcToken).greaterThan('0') &&\n        quickPair.reserveOf(oldQuickToken).greaterThan('5')\n      ) {\n        const quickUsdcPrice = usdcQuickPair.priceOf(usdcToken);\n        const currencyQuickPrice = quickPair.priceOf(oldQuickToken);\n        const usdcPrice = quickUsdcPrice.multiply(currencyQuickPrice).invert();\n        return new Price(\n          currency,\n          usdcToken,\n          usdcPrice.denominator,\n          usdcPrice.numerator,\n        );\n      }\n    }\n    return undefined;\n  }, [\n    currency,\n    wrapped,\n    chainId,\n    ethPair,\n    usdcEthPair,\n    usdcPairState,\n    usdcPair,\n    usdtPairState,\n    usdtPair,\n    daiPairState,\n    daiPair,\n    ethPairState,\n    usdcEthPairState,\n    quickPairState,\n    quickPair,\n    usdcQuickPairState,\n    usdcQuickPair,\n    internalWrapped,\n    cxETHToken,\n    daiToken,\n    oldQuickToken,\n    usdcToken,\n    usdtToken,\n  ]);\n}\n\n//TODO: the majority of these functions share alot of common logic,\n//There also seems to be bugs, sometimes the CXETH Pair returns CXEth, sometimes ETH\n//Investigate more fully\nexport function useUSDCPrices(currencies: Currency[]): (Price | undefined)[] {\n  const { chainId } = useActiveWeb3React();\n  const oldQuickToken = GlobalValue.tokens.COMMON.OLD_QUICK;\n  const usdcToken = GlobalValue.tokens.COMMON.USDC;\n  const usdtToken = GlobalValue.tokens.COMMON.USDT;\n  const daiToken = GlobalValue.tokens.COMMON.DAI;\n  const cxETHToken = GlobalValue.tokens.COMMON.CXETH;\n  const ETHToken = GlobalValue.tokens.COMMON.CXETH;\n  const wrappedCurrencies = currencies.map((currency) => {\n    let wrapped = wrappedCurrency(currency, chainId);\n    if (wrapped?.equals(cxETHToken)) {\n      wrapped = wrappedCurrency(ETHToken, chainId);\n    }\n    return wrapped;\n  });\n  const tokenPairs: [Currency | undefined, Currency | undefined][] = [];\n  wrappedCurrencies.forEach((wrapped, ind) => {\n    tokenPairs.push([\n      chainId && wrapped && currencyEquals(WETH[chainId], wrapped)\n        ? undefined\n        : currencies[ind],\n      chainId ? WETH[chainId] : undefined,\n    ]);\n    tokenPairs.push([\n      wrapped?.equals(oldQuickToken) ? undefined : wrapped,\n      chainId === ChainId.MAINNET ? oldQuickToken : undefined,\n    ]);\n    tokenPairs.push([\n      wrapped?.equals(usdcToken) ? undefined : wrapped,\n      chainId === ChainId.MAINNET ? usdcToken : undefined,\n    ]);\n    tokenPairs.push([\n      wrapped?.equals(usdtToken) ? undefined : wrapped,\n      chainId === ChainId.MAINNET ? usdtToken : undefined,\n    ]);\n    tokenPairs.push([\n      wrapped?.equals(daiToken) ? undefined : wrapped,\n      chainId === ChainId.MAINNET ? daiToken : undefined,\n    ]);\n    tokenPairs.push([\n      chainId ? WETH[chainId] : undefined,\n      chainId === ChainId.MAINNET ? usdcToken : undefined,\n    ]);\n    tokenPairs.push([\n      chainId ? oldQuickToken : undefined,\n      chainId === ChainId.MAINNET ? usdcToken : undefined,\n    ]);\n  });\n  const pairs = usePairs(tokenPairs);\n  const remainPairs = currencies.map((_, index) => {\n    return pairs.slice(7 * index, 7 * (index + 1));\n  });\n\n  return currencies.map((currency, index) => {\n    const [\n      [ethPairState, ethPair],\n      [quickPairState, quickPair],\n      [usdcPairState, usdcPair],\n      [usdtPairState, usdtPair],\n      [daiPairState, daiPair],\n      [usdcEthPairState, usdcEthPair],\n      [usdcQuickPairState, usdcQuickPair],\n    ] = remainPairs[index];\n    const wrapped = wrappedCurrencies[index];\n    const internalWrapped = wrappedCurrency(currency, chainId);\n    if (!wrapped || !chainId) {\n      return undefined;\n    }\n    if (wrapped.equals(WETH[chainId])) {\n      if (usdcPair) {\n        const price = usdcPair.priceOf(WETH[chainId]);\n        return new Price(\n          currency,\n          usdcToken,\n          price.denominator,\n          price.numerator,\n        );\n      } else {\n        return undefined;\n      }\n    }\n    // handle usdc\n    if (wrapped.equals(usdcToken)) {\n      return new Price(usdcToken, usdcToken, '1', '1');\n    }\n\n    const ethPairETHAmount = ethPair?.reserveOf(WETH[chainId]);\n    const ethPairETHUSDCValue: JSBI =\n      ethPairETHAmount && usdcEthPair\n        ? usdcEthPair.priceOf(WETH[chainId]).quote(ethPairETHAmount).raw\n        : JSBI.BigInt(0);\n\n    // all other tokens\n    // first try the usdc pair\n    if (\n      usdcPairState === PairState.EXISTS &&\n      usdcPair &&\n      usdcPair.reserveOf(usdcToken).greaterThan(ethPairETHUSDCValue)\n    ) {\n      const price = usdcPair.priceOf(wrapped);\n      if (internalWrapped?.equals(cxETHToken)) {\n        return new Price(\n          cxETHToken,\n          usdcToken,\n          price.denominator,\n          price.numerator,\n        );\n      }\n      return new Price(currency, usdcToken, price.denominator, price.numerator);\n    }\n    if (\n      usdtPairState === PairState.EXISTS &&\n      usdtPair &&\n      usdtPair.reserveOf(usdtToken).greaterThan(ethPairETHUSDCValue)\n    ) {\n      const price = usdtPair.priceOf(wrapped);\n      return new Price(currency, usdtToken, price.denominator, price.numerator);\n    }\n    if (\n      daiPairState === PairState.EXISTS &&\n      daiPair &&\n      daiPair.reserveOf(daiToken).greaterThan(ethPairETHUSDCValue)\n    ) {\n      const price = daiPair.priceOf(wrapped);\n      return new Price(currency, daiToken, price.denominator, price.numerator);\n    }\n    if (\n      ethPairState === PairState.EXISTS &&\n      ethPair &&\n      usdcEthPairState === PairState.EXISTS &&\n      usdcEthPair\n    ) {\n      if (\n        usdcEthPair.reserveOf(usdcToken).greaterThan('0') &&\n        ethPair.reserveOf(WETH[chainId]).greaterThan('1')\n      ) {\n        const ethUsdcPrice = usdcEthPair.priceOf(usdcToken);\n        const currencyEthPrice = ethPair.priceOf(WETH[chainId]);\n        const usdcPrice = ethUsdcPrice.multiply(currencyEthPrice).invert();\n        return new Price(\n          currency,\n          usdcToken,\n          usdcPrice.denominator,\n          usdcPrice.numerator,\n        );\n      }\n    }\n    if (\n      quickPairState === PairState.EXISTS &&\n      quickPair &&\n      usdcQuickPairState === PairState.EXISTS &&\n      usdcQuickPair\n    ) {\n      if (\n        usdcQuickPair.reserveOf(usdcToken).greaterThan('0') &&\n        quickPair.reserveOf(oldQuickToken).greaterThan('5')\n      ) {\n        const quickUsdcPrice = usdcQuickPair.priceOf(usdcToken);\n        const currencyQuickPrice = quickPair.priceOf(oldQuickToken);\n        const usdcPrice = quickUsdcPrice.multiply(currencyQuickPrice).invert();\n        return new Price(\n          currency,\n          usdcToken,\n          usdcPrice.denominator,\n          usdcPrice.numerator,\n        );\n      }\n    }\n    return undefined;\n  });\n}\n\nexport function useUSDCPricesToken(tokens: Token[]) {\n  const dQUICKtoQUICK = useDQUICKtoQUICK();\n  const oldQuickToken = GlobalValue.tokens.COMMON.OLD_QUICK;\n  const oldDQuickToken = GlobalValue.tokens.COMMON.OLD_DQUICK;\n  const newQuickToken = GlobalValue.tokens.COMMON.NEW_QUICK;\n  const newDQuickToken = GlobalValue.tokens.COMMON.NEW_DQUICK;\n  const usdcToken = GlobalValue.tokens.COMMON.USDC;\n  const [, quickUsdcPair] = usePair(oldQuickToken, usdcToken);\n  const [, newQuickUsdcPair] = usePair(newQuickToken, usdcToken);\n  const quickPrice = Number(\n    quickUsdcPair?.priceOf(oldQuickToken)?.toSignificant(6) ?? 0,\n  );\n  const newQuickPrice = Number(\n    newQuickUsdcPair?.priceOf(newQuickToken)?.toSignificant(6) ?? 0,\n  );\n  const filteredTokens = tokens\n    .filter((item, pos, self) => {\n      return self.findIndex((token) => token.equals(item)) == pos;\n    })\n    .filter(\n      (token) =>\n        !token.equals(oldQuickToken) &&\n        !token.equals(newQuickToken) &&\n        !token.equals(oldDQuickToken) &&\n        !token.equals(newDQuickToken),\n    );\n  const currencies = filteredTokens.map((token) => unwrappedToken(token));\n  const usdPrices = useUSDCPrices(currencies);\n  const usdPricesWithToken = filteredTokens.map((token, index) => {\n    return { token, price: Number(usdPrices[index]?.toSignificant(6) ?? 0) };\n  });\n  return tokens.map((token) => {\n    if (token.equals(oldDQuickToken)) {\n      return dQUICKtoQUICK * quickPrice;\n    } else if (token.equals(oldQuickToken)) {\n      return quickPrice;\n    } else if (token.equals(newDQuickToken)) {\n      return dQUICKtoQUICK * newQuickPrice;\n    } else if (token.equals(newQuickToken)) {\n      return newQuickPrice;\n    } else {\n      const priceObj = usdPricesWithToken.find((item) =>\n        item.token.equals(token),\n      );\n      return priceObj?.price ?? 0;\n    }\n  });\n}\nexport function useUSDCPriceToken(token: Token) {\n  return useUSDCPricesToken([token])[0];\n}\n"]},"metadata":{},"sourceType":"module"}