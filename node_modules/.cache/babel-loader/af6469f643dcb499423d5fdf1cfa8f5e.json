{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { JSBI, Percent, Router, TradeType } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { GlobalConst } from 'constants/index';\nimport { useTransactionAdder } from 'state/transactions/hooks';\nimport { calculateGasMargin, isZero, isAddress, shortenAddress, formatTokenAmount } from 'utils';\nimport { useActiveWeb3React } from 'hooks';\nimport { useRouterContract } from './useContract';\nimport useTransactionDeadline from './useTransactionDeadline';\nimport useENS from './useENS';\nimport { Version } from './useToggledVersion';\nexport let SwapCallbackState;\n\n(function (SwapCallbackState) {\n  SwapCallbackState[SwapCallbackState[\"INVALID\"] = 0] = \"INVALID\";\n  SwapCallbackState[SwapCallbackState[\"LOADING\"] = 1] = \"LOADING\";\n  SwapCallbackState[SwapCallbackState[\"VALID\"] = 2] = \"VALID\";\n})(SwapCallbackState || (SwapCallbackState = {}));\n\n/**\n * Returns the swap calls that can be used to make the trade\n * @param trade trade to execute\n * @param allowedSlippage user allowed slippage\n * @param recipientAddressOrName\n */\nfunction useSwapCallArguments(trade) {\n  _s();\n\n  let allowedSlippage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GlobalConst.utils.INITIAL_ALLOWED_SLIPPAGE;\n  let // in bips\n  recipientAddressOrName // the ENS name or address of the recipient of the trade, or null if swap should be returned to sender\n  = arguments.length > 2 ? arguments[2] : undefined;\n  const {\n    account,\n    chainId,\n    library\n  } = useActiveWeb3React();\n  const {\n    address: recipientAddress\n  } = useENS(recipientAddressOrName);\n  const recipient = recipientAddressOrName === null ? account : recipientAddress;\n  const deadline = useTransactionDeadline();\n  const contract = useRouterContract();\n  return useMemo(() => {\n    const tradeVersion = Version.v2;\n    if (!trade || !recipient || !library || !account || !tradeVersion || !chainId) return [];\n\n    if (!contract) {\n      return [];\n    }\n\n    const swapMethods = [];\n\n    switch (tradeVersion) {\n      case Version.v2:\n        swapMethods.push(Router.swapCallParameters(trade, {\n          feeOnTransfer: false,\n          allowedSlippage: new Percent(JSBI.BigInt(allowedSlippage), GlobalConst.utils.BIPS_BASE),\n          recipient,\n          ttl: deadline ? deadline.toNumber() : GlobalConst.utils.DEFAULT_DEADLINE_FROM_NOW\n        }));\n\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          swapMethods.push(Router.swapCallParameters(trade, {\n            feeOnTransfer: true,\n            allowedSlippage: new Percent(JSBI.BigInt(allowedSlippage), GlobalConst.utils.BIPS_BASE),\n            recipient,\n            ttl: deadline ? deadline.toNumber() : GlobalConst.utils.DEFAULT_DEADLINE_FROM_NOW\n          }));\n        }\n\n        break;\n    }\n\n    return swapMethods.map(parameters => ({\n      parameters,\n      contract\n    }));\n  }, [account, allowedSlippage, chainId, deadline, library, recipient, trade, contract]);\n} // returns a function that will execute a swap, if the parameters are all valid\n// and the user has approved the slippage adjusted input amount for the trade\n\n\n_s(useSwapCallArguments, \"nycfOdvGzYOlca2yiDBgId9rCUI=\", false, function () {\n  return [useActiveWeb3React, useENS, useTransactionDeadline, useRouterContract];\n});\n\nexport function useSwapCallback(trade) {\n  _s2();\n\n  let allowedSlippage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GlobalConst.utils.INITIAL_ALLOWED_SLIPPAGE;\n  let // in bips\n  recipientAddressOrName // the ENS name or address of the recipient of the trade, or null if swap should be returned to sender\n  = arguments.length > 2 ? arguments[2] : undefined;\n  const {\n    account,\n    chainId,\n    library\n  } = useActiveWeb3React();\n  const swapCalls = useSwapCallArguments(trade, allowedSlippage, recipientAddressOrName);\n  const addTransaction = useTransactionAdder();\n  const {\n    address: recipientAddress\n  } = useENS(recipientAddressOrName);\n  const recipient = recipientAddressOrName === null ? account : recipientAddress;\n  return useMemo(() => {\n    if (!trade || !library || !account || !chainId) {\n      return {\n        state: SwapCallbackState.INVALID,\n        callback: null,\n        error: 'Missing dependencies'\n      };\n    }\n\n    if (!recipient) {\n      if (recipientAddressOrName !== null) {\n        return {\n          state: SwapCallbackState.INVALID,\n          callback: null,\n          error: 'Invalid recipient'\n        };\n      } else {\n        return {\n          state: SwapCallbackState.LOADING,\n          callback: null,\n          error: null\n        };\n      }\n    }\n\n    const tradeVersion = Version.v2;\n    return {\n      state: SwapCallbackState.VALID,\n      callback: async function onSwap() {\n        const estimatedCalls = await Promise.all(swapCalls.map(call => {\n          const {\n            parameters: {\n              methodName,\n              args,\n              value\n            },\n            contract\n          } = call;\n          const options = !value || isZero(value) ? {} : {\n            value\n          };\n          return contract.estimateGas[methodName](...args, options).then(gasEstimate => {\n            return {\n              call,\n              gasEstimate: gasEstimate.add(100000)\n            };\n          }).catch(gasError => {\n            console.debug('Gas estimate failed, trying eth_call to extract error', call);\n            return contract.callStatic[methodName](...args, options).then(result => {\n              console.debug('Unexpected successful call after failed estimate gas', call, gasError, result);\n              return {\n                call,\n                error: new Error('Unexpected issue with estimating the gas. Please try again.')\n              };\n            }).catch(callError => {\n              console.debug('Call threw error', call, callError);\n              let errorMessage;\n\n              switch (callError.reason) {\n                case 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT':\n                case 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT':\n                  errorMessage = 'This transaction will not succeed either due to price movement or fee on transfer. Try increasing your slippage tolerance.';\n                  break;\n\n                default:\n                  errorMessage = `The transaction cannot succeed due to error: ${callError.reason}. This is probably an issue with one of the tokens you are swapping.`;\n              }\n\n              return {\n                call,\n                error: new Error(errorMessage)\n              };\n            });\n          });\n        })); // a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate\n\n        const successfulEstimation = estimatedCalls.find((el, ix, list) => 'gasEstimate' in el && (ix === list.length - 1 || 'gasEstimate' in list[ix + 1]));\n\n        if (!successfulEstimation) {\n          const errorCalls = estimatedCalls.filter(call => 'error' in call);\n          if (errorCalls.length > 0) throw errorCalls[errorCalls.length - 1].error;\n          throw new Error('Unexpected error. Please contact support: none of the calls threw an error');\n        }\n\n        const {\n          call: {\n            contract,\n            parameters: {\n              methodName,\n              args,\n              value\n            }\n          },\n          gasEstimate\n        } = successfulEstimation;\n        return contract[methodName](...args, {\n          gasLimit: calculateGasMargin(gasEstimate),\n          ...(value && !isZero(value) ? {\n            value,\n            from: account\n          } : {\n            from: account\n          })\n        }).then(response => {\n          const inputSymbol = trade.inputAmount.currency.symbol;\n          const outputSymbol = trade.outputAmount.currency.symbol;\n          const inputAmount = formatTokenAmount(trade.inputAmount);\n          const outputAmount = formatTokenAmount(trade.outputAmount);\n          const base = `Swap ${inputAmount} ${inputSymbol} for ${outputAmount} ${outputSymbol}`;\n          const withRecipient = recipient === account ? base : `${base} to ${recipientAddressOrName && isAddress(recipientAddressOrName) ? shortenAddress(recipientAddressOrName) : recipientAddressOrName}`;\n          const withVersion = tradeVersion === Version.v2 ? withRecipient : `${withRecipient} on ${tradeVersion.toUpperCase()}`;\n          addTransaction(response, {\n            summary: withVersion\n          });\n          return {\n            response,\n            summary: withVersion\n          };\n        }).catch(error => {\n          // if the user rejected the tx, pass this along\n          if ((error === null || error === void 0 ? void 0 : error.code) === 4001) {\n            throw new Error('Transaction rejected.');\n          } else {\n            // otherwise, the error was unexpected and we need to convey that\n            console.error(`Swap failed`, error, methodName, args, value);\n            throw new Error(`Swap failed: ${error.message}`);\n          }\n        });\n      },\n      error: null\n    };\n  }, [trade, library, account, chainId, recipient, recipientAddressOrName, swapCalls, addTransaction]);\n}\n\n_s2(useSwapCallback, \"G8+T55P1ph4OGYQvDIdQ9DZmL+I=\", false, function () {\n  return [useActiveWeb3React, useSwapCallArguments, useTransactionAdder, useENS];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/hooks/useSwapCallback.ts"],"names":["JSBI","Percent","Router","TradeType","useMemo","GlobalConst","useTransactionAdder","calculateGasMargin","isZero","isAddress","shortenAddress","formatTokenAmount","useActiveWeb3React","useRouterContract","useTransactionDeadline","useENS","Version","SwapCallbackState","useSwapCallArguments","trade","allowedSlippage","utils","INITIAL_ALLOWED_SLIPPAGE","recipientAddressOrName","account","chainId","library","address","recipientAddress","recipient","deadline","contract","tradeVersion","v2","swapMethods","push","swapCallParameters","feeOnTransfer","BigInt","BIPS_BASE","ttl","toNumber","DEFAULT_DEADLINE_FROM_NOW","tradeType","EXACT_INPUT","map","parameters","useSwapCallback","swapCalls","addTransaction","state","INVALID","callback","error","LOADING","VALID","onSwap","estimatedCalls","Promise","all","call","methodName","args","value","options","estimateGas","then","gasEstimate","add","catch","gasError","console","debug","callStatic","result","Error","callError","errorMessage","reason","successfulEstimation","find","el","ix","list","length","errorCalls","filter","gasLimit","from","response","inputSymbol","inputAmount","currency","symbol","outputSymbol","outputAmount","base","withRecipient","withVersion","toUpperCase","summary","code","message"],"mappings":"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","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { Contract } from '@ethersproject/contracts';\nimport { TransactionResponse } from '@ethersproject/providers';\nimport {\n  JSBI,\n  Percent,\n  Router,\n  SwapParameters,\n  Trade,\n  TradeType,\n} from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { GlobalConst } from 'constants/index';\nimport { useTransactionAdder } from 'state/transactions/hooks';\nimport {\n  calculateGasMargin,\n  isZero,\n  isAddress,\n  shortenAddress,\n  formatTokenAmount,\n} from 'utils';\nimport { useActiveWeb3React } from 'hooks';\nimport { useRouterContract } from './useContract';\nimport useTransactionDeadline from './useTransactionDeadline';\nimport useENS from './useENS';\nimport { Version } from './useToggledVersion';\n\nexport enum SwapCallbackState {\n  INVALID,\n  LOADING,\n  VALID,\n}\n\ninterface SwapCall {\n  contract: Contract;\n  parameters: SwapParameters;\n}\n\ninterface SuccessfulCall {\n  call: SwapCall;\n  gasEstimate: BigNumber;\n}\n\ninterface FailedCall {\n  call: SwapCall;\n  error: Error;\n}\n\ntype EstimatedSwapCall = SuccessfulCall | FailedCall;\n\n/**\n * Returns the swap calls that can be used to make the trade\n * @param trade trade to execute\n * @param allowedSlippage user allowed slippage\n * @param recipientAddressOrName\n */\nfunction useSwapCallArguments(\n  trade: Trade | undefined, // trade to execute, required\n  allowedSlippage: number = GlobalConst.utils.INITIAL_ALLOWED_SLIPPAGE, // in bips\n  recipientAddressOrName: string | null, // the ENS name or address of the recipient of the trade, or null if swap should be returned to sender\n): SwapCall[] {\n  const { account, chainId, library } = useActiveWeb3React();\n\n  const { address: recipientAddress } = useENS(recipientAddressOrName);\n  const recipient =\n    recipientAddressOrName === null ? account : recipientAddress;\n  const deadline = useTransactionDeadline();\n  const contract = useRouterContract();\n\n  return useMemo(() => {\n    const tradeVersion = Version.v2;\n    if (\n      !trade ||\n      !recipient ||\n      !library ||\n      !account ||\n      !tradeVersion ||\n      !chainId\n    )\n      return [];\n\n    if (!contract) {\n      return [];\n    }\n\n    const swapMethods = [];\n\n    switch (tradeVersion) {\n      case Version.v2:\n        swapMethods.push(\n          Router.swapCallParameters(trade, {\n            feeOnTransfer: false,\n            allowedSlippage: new Percent(\n              JSBI.BigInt(allowedSlippage),\n              GlobalConst.utils.BIPS_BASE,\n            ),\n            recipient,\n            ttl: deadline\n              ? deadline.toNumber()\n              : GlobalConst.utils.DEFAULT_DEADLINE_FROM_NOW,\n          }),\n        );\n\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          swapMethods.push(\n            Router.swapCallParameters(trade, {\n              feeOnTransfer: true,\n              allowedSlippage: new Percent(\n                JSBI.BigInt(allowedSlippage),\n                GlobalConst.utils.BIPS_BASE,\n              ),\n              recipient,\n              ttl: deadline\n                ? deadline.toNumber()\n                : GlobalConst.utils.DEFAULT_DEADLINE_FROM_NOW,\n            }),\n          );\n        }\n        break;\n    }\n    return swapMethods.map((parameters) => ({ parameters, contract }));\n  }, [\n    account,\n    allowedSlippage,\n    chainId,\n    deadline,\n    library,\n    recipient,\n    trade,\n    contract,\n  ]);\n}\n\n// returns a function that will execute a swap, if the parameters are all valid\n// and the user has approved the slippage adjusted input amount for the trade\nexport function useSwapCallback(\n  trade: Trade | undefined, // trade to execute, required\n  allowedSlippage: number = GlobalConst.utils.INITIAL_ALLOWED_SLIPPAGE, // in bips\n  recipientAddressOrName: string | null, // the ENS name or address of the recipient of the trade, or null if swap should be returned to sender\n): {\n  state: SwapCallbackState;\n  callback:\n    | null\n    | (() => Promise<{ response: TransactionResponse; summary: string }>);\n  error: string | null;\n} {\n  const { account, chainId, library } = useActiveWeb3React();\n\n  const swapCalls = useSwapCallArguments(\n    trade,\n    allowedSlippage,\n    recipientAddressOrName,\n  );\n\n  const addTransaction = useTransactionAdder();\n\n  const { address: recipientAddress } = useENS(recipientAddressOrName);\n  const recipient =\n    recipientAddressOrName === null ? account : recipientAddress;\n\n  return useMemo(() => {\n    if (!trade || !library || !account || !chainId) {\n      return {\n        state: SwapCallbackState.INVALID,\n        callback: null,\n        error: 'Missing dependencies',\n      };\n    }\n    if (!recipient) {\n      if (recipientAddressOrName !== null) {\n        return {\n          state: SwapCallbackState.INVALID,\n          callback: null,\n          error: 'Invalid recipient',\n        };\n      } else {\n        return {\n          state: SwapCallbackState.LOADING,\n          callback: null,\n          error: null,\n        };\n      }\n    }\n\n    const tradeVersion = Version.v2;\n\n    return {\n      state: SwapCallbackState.VALID,\n      callback: async function onSwap(): Promise<{\n        response: TransactionResponse;\n        summary: string;\n      }> {\n        const estimatedCalls: EstimatedSwapCall[] = await Promise.all(\n          swapCalls.map((call) => {\n            const {\n              parameters: { methodName, args, value },\n              contract,\n            } = call;\n            const options = !value || isZero(value) ? {} : { value };\n\n            return contract.estimateGas[methodName](...args, options)\n              .then((gasEstimate) => {\n                return {\n                  call,\n                  gasEstimate: gasEstimate.add(100000),\n                };\n              })\n              .catch((gasError) => {\n                console.debug(\n                  'Gas estimate failed, trying eth_call to extract error',\n                  call,\n                );\n\n                return contract.callStatic[methodName](...args, options)\n                  .then((result) => {\n                    console.debug(\n                      'Unexpected successful call after failed estimate gas',\n                      call,\n                      gasError,\n                      result,\n                    );\n                    return {\n                      call,\n                      error: new Error(\n                        'Unexpected issue with estimating the gas. Please try again.',\n                      ),\n                    };\n                  })\n                  .catch((callError) => {\n                    console.debug('Call threw error', call, callError);\n                    let errorMessage: string;\n                    switch (callError.reason) {\n                      case 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT':\n                      case 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT':\n                        errorMessage =\n                          'This transaction will not succeed either due to price movement or fee on transfer. Try increasing your slippage tolerance.';\n                        break;\n                      default:\n                        errorMessage = `The transaction cannot succeed due to error: ${callError.reason}. This is probably an issue with one of the tokens you are swapping.`;\n                    }\n                    return { call, error: new Error(errorMessage) };\n                  });\n              });\n          }),\n        );\n\n        // a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate\n        const successfulEstimation = estimatedCalls.find(\n          (el, ix, list): el is SuccessfulCall =>\n            'gasEstimate' in el &&\n            (ix === list.length - 1 || 'gasEstimate' in list[ix + 1]),\n        );\n\n        if (!successfulEstimation) {\n          const errorCalls = estimatedCalls.filter(\n            (call): call is FailedCall => 'error' in call,\n          );\n          if (errorCalls.length > 0)\n            throw errorCalls[errorCalls.length - 1].error;\n          throw new Error(\n            'Unexpected error. Please contact support: none of the calls threw an error',\n          );\n        }\n\n        const {\n          call: {\n            contract,\n            parameters: { methodName, args, value },\n          },\n          gasEstimate,\n        } = successfulEstimation;\n\n        return contract[methodName](...args, {\n          gasLimit: calculateGasMargin(gasEstimate),\n          ...(value && !isZero(value)\n            ? { value, from: account }\n            : { from: account }),\n        })\n          .then((response: TransactionResponse) => {\n            const inputSymbol = trade.inputAmount.currency.symbol;\n            const outputSymbol = trade.outputAmount.currency.symbol;\n            const inputAmount = formatTokenAmount(trade.inputAmount);\n            const outputAmount = formatTokenAmount(trade.outputAmount);\n\n            const base = `Swap ${inputAmount} ${inputSymbol} for ${outputAmount} ${outputSymbol}`;\n            const withRecipient =\n              recipient === account\n                ? base\n                : `${base} to ${\n                    recipientAddressOrName && isAddress(recipientAddressOrName)\n                      ? shortenAddress(recipientAddressOrName)\n                      : recipientAddressOrName\n                  }`;\n\n            const withVersion =\n              tradeVersion === Version.v2\n                ? withRecipient\n                : `${withRecipient} on ${(tradeVersion as any).toUpperCase()}`;\n\n            addTransaction(response, {\n              summary: withVersion,\n            });\n\n            return { response, summary: withVersion };\n          })\n          .catch((error: any) => {\n            // if the user rejected the tx, pass this along\n            if (error?.code === 4001) {\n              throw new Error('Transaction rejected.');\n            } else {\n              // otherwise, the error was unexpected and we need to convey that\n              console.error(`Swap failed`, error, methodName, args, value);\n              throw new Error(`Swap failed: ${error.message}`);\n            }\n          });\n      },\n      error: null,\n    };\n  }, [\n    trade,\n    library,\n    account,\n    chainId,\n    recipient,\n    recipientAddressOrName,\n    swapCalls,\n    addTransaction,\n  ]);\n}\n"]},"metadata":{},"sourceType":"module"}