{"ast":null,"code":"import { GlobalValue } from 'constants/index';\nimport { CurrencyAmount, JSBI, Percent, TokenAmount } from '@uniswap/sdk';\nimport { Field } from 'state/swap/actions';\nimport { basisPointsToPercent } from 'utils';\nconst BASE_FEE = new Percent(JSBI.BigInt(30), JSBI.BigInt(10000));\nconst ONE_HUNDRED_PERCENT = new Percent(JSBI.BigInt(10000), JSBI.BigInt(10000));\nconst INPUT_FRACTION_AFTER_FEE = ONE_HUNDRED_PERCENT.subtract(BASE_FEE); // computes price breakdown for the trade\n\n_c = INPUT_FRACTION_AFTER_FEE;\nexport function computeTradePriceBreakdown(trade) {\n  // for each hop in our trade, take away the x*y=k price impact from 0.25% fees\n  // e.g. for 3 tokens/2 hops: 1 - ((1 - .03) * (1-.03))\n  const realizedLPFee = !trade ? undefined : ONE_HUNDRED_PERCENT.subtract(trade.route.pairs.reduce(currentFee => currentFee.multiply(INPUT_FRACTION_AFTER_FEE), ONE_HUNDRED_PERCENT)); // remove lp fees from price impact\n\n  const priceImpactWithoutFeeFraction = trade && realizedLPFee ? trade.priceImpact.subtract(realizedLPFee) : undefined; // the x*y=k impact\n\n  const priceImpactWithoutFeePercent = priceImpactWithoutFeeFraction ? new Percent(priceImpactWithoutFeeFraction === null || priceImpactWithoutFeeFraction === void 0 ? void 0 : priceImpactWithoutFeeFraction.numerator, priceImpactWithoutFeeFraction === null || priceImpactWithoutFeeFraction === void 0 ? void 0 : priceImpactWithoutFeeFraction.denominator) : undefined; // the amount of the input that accrues to LPs\n\n  const realizedLPFeeAmount = realizedLPFee && trade && (trade.inputAmount instanceof TokenAmount ? new TokenAmount(trade.inputAmount.token, realizedLPFee.multiply(trade.inputAmount.raw).quotient) : CurrencyAmount.ether(realizedLPFee.multiply(trade.inputAmount.raw).quotient));\n  return {\n    priceImpactWithoutFee: priceImpactWithoutFeePercent,\n    realizedLPFee: realizedLPFeeAmount\n  };\n} // computes the minimum amount out and maximum amount in for a trade given a user specified allowed slippage in bips\n\nexport function computeSlippageAdjustedAmounts(trade, allowedSlippage) {\n  const pct = basisPointsToPercent(allowedSlippage);\n  return {\n    [Field.INPUT]: trade === null || trade === void 0 ? void 0 : trade.maximumAmountIn(pct),\n    [Field.OUTPUT]: trade === null || trade === void 0 ? void 0 : trade.minimumAmountOut(pct)\n  };\n}\nexport function warningSeverity(priceImpact) {\n  if (!(priceImpact !== null && priceImpact !== void 0 && priceImpact.lessThan(GlobalValue.percents.BLOCKED_PRICE_IMPACT_NON_EXPERT))) return 4;\n  if (!(priceImpact !== null && priceImpact !== void 0 && priceImpact.lessThan(GlobalValue.percents.ALLOWED_PRICE_IMPACT_HIGH))) return 3;\n  if (!(priceImpact !== null && priceImpact !== void 0 && priceImpact.lessThan(GlobalValue.percents.ALLOWED_PRICE_IMPACT_MEDIUM))) return 2;\n  if (!(priceImpact !== null && priceImpact !== void 0 && priceImpact.lessThan(GlobalValue.percents.ALLOWED_PRICE_IMPACT_LOW))) return 1;\n  return 0;\n}\nexport function formatExecutionPrice(trade, inverted) {\n  if (!trade) {\n    return '';\n  }\n\n  return inverted ? `${trade.executionPrice.invert().toSignificant(6)} ${trade.inputAmount.currency.symbol} / ${trade.outputAmount.currency.symbol}` : `${trade.executionPrice.toSignificant(6)} ${trade.outputAmount.currency.symbol} / ${trade.inputAmount.currency.symbol}`;\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"INPUT_FRACTION_AFTER_FEE\");","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/utils/prices.ts"],"names":["GlobalValue","CurrencyAmount","JSBI","Percent","TokenAmount","Field","basisPointsToPercent","BASE_FEE","BigInt","ONE_HUNDRED_PERCENT","INPUT_FRACTION_AFTER_FEE","subtract","computeTradePriceBreakdown","trade","realizedLPFee","undefined","route","pairs","reduce","currentFee","multiply","priceImpactWithoutFeeFraction","priceImpact","priceImpactWithoutFeePercent","numerator","denominator","realizedLPFeeAmount","inputAmount","token","raw","quotient","ether","priceImpactWithoutFee","computeSlippageAdjustedAmounts","allowedSlippage","pct","INPUT","maximumAmountIn","OUTPUT","minimumAmountOut","warningSeverity","lessThan","percents","BLOCKED_PRICE_IMPACT_NON_EXPERT","ALLOWED_PRICE_IMPACT_HIGH","ALLOWED_PRICE_IMPACT_MEDIUM","ALLOWED_PRICE_IMPACT_LOW","formatExecutionPrice","inverted","executionPrice","invert","toSignificant","currency","symbol","outputAmount"],"mappings":"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","sourcesContent":["import { GlobalValue } from 'constants/index';\nimport {\n  CurrencyAmount,\n  Fraction,\n  JSBI,\n  Percent,\n  TokenAmount,\n  Trade,\n} from '@uniswap/sdk';\nimport { Field } from 'state/swap/actions';\nimport { basisPointsToPercent } from 'utils';\n\nconst BASE_FEE = new Percent(JSBI.BigInt(30), JSBI.BigInt(10000));\nconst ONE_HUNDRED_PERCENT = new Percent(JSBI.BigInt(10000), JSBI.BigInt(10000));\nconst INPUT_FRACTION_AFTER_FEE = ONE_HUNDRED_PERCENT.subtract(BASE_FEE);\n\n// computes price breakdown for the trade\nexport function computeTradePriceBreakdown(\n  trade?: Trade,\n): { priceImpactWithoutFee?: Percent; realizedLPFee?: CurrencyAmount } {\n  // for each hop in our trade, take away the x*y=k price impact from 0.25% fees\n  // e.g. for 3 tokens/2 hops: 1 - ((1 - .03) * (1-.03))\n  const realizedLPFee = !trade\n    ? undefined\n    : ONE_HUNDRED_PERCENT.subtract(\n        trade.route.pairs.reduce<Fraction>(\n          (currentFee: Fraction): Fraction =>\n            currentFee.multiply(INPUT_FRACTION_AFTER_FEE),\n          ONE_HUNDRED_PERCENT,\n        ),\n      );\n\n  // remove lp fees from price impact\n  const priceImpactWithoutFeeFraction =\n    trade && realizedLPFee\n      ? trade.priceImpact.subtract(realizedLPFee)\n      : undefined;\n\n  // the x*y=k impact\n  const priceImpactWithoutFeePercent = priceImpactWithoutFeeFraction\n    ? new Percent(\n        priceImpactWithoutFeeFraction?.numerator,\n        priceImpactWithoutFeeFraction?.denominator,\n      )\n    : undefined;\n\n  // the amount of the input that accrues to LPs\n  const realizedLPFeeAmount =\n    realizedLPFee &&\n    trade &&\n    (trade.inputAmount instanceof TokenAmount\n      ? new TokenAmount(\n          trade.inputAmount.token,\n          realizedLPFee.multiply(trade.inputAmount.raw).quotient,\n        )\n      : CurrencyAmount.ether(\n          realizedLPFee.multiply(trade.inputAmount.raw).quotient,\n        ));\n\n  return {\n    priceImpactWithoutFee: priceImpactWithoutFeePercent,\n    realizedLPFee: realizedLPFeeAmount,\n  };\n}\n\n// computes the minimum amount out and maximum amount in for a trade given a user specified allowed slippage in bips\nexport function computeSlippageAdjustedAmounts(\n  trade: Trade | undefined,\n  allowedSlippage: number,\n): { [field in Field]?: CurrencyAmount } {\n  const pct = basisPointsToPercent(allowedSlippage);\n  return {\n    [Field.INPUT]: trade?.maximumAmountIn(pct),\n    [Field.OUTPUT]: trade?.minimumAmountOut(pct),\n  };\n}\n\nexport function warningSeverity(\n  priceImpact: Percent | undefined,\n): 0 | 1 | 2 | 3 | 4 {\n  if (\n    !priceImpact?.lessThan(GlobalValue.percents.BLOCKED_PRICE_IMPACT_NON_EXPERT)\n  )\n    return 4;\n  if (!priceImpact?.lessThan(GlobalValue.percents.ALLOWED_PRICE_IMPACT_HIGH))\n    return 3;\n  if (!priceImpact?.lessThan(GlobalValue.percents.ALLOWED_PRICE_IMPACT_MEDIUM))\n    return 2;\n  if (!priceImpact?.lessThan(GlobalValue.percents.ALLOWED_PRICE_IMPACT_LOW))\n    return 1;\n  return 0;\n}\n\nexport function formatExecutionPrice(\n  trade?: Trade,\n  inverted?: boolean,\n): string {\n  if (!trade) {\n    return '';\n  }\n  return inverted\n    ? `${trade.executionPrice.invert().toSignificant(6)} ${\n        trade.inputAmount.currency.symbol\n      } / ${trade.outputAmount.currency.symbol}`\n    : `${trade.executionPrice.toSignificant(6)} ${\n        trade.outputAmount.currency.symbol\n      } / ${trade.inputAmount.currency.symbol}`;\n}\n"]},"metadata":{},"sourceType":"module"}