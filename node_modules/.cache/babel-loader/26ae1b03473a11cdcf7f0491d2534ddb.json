{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hexUtils = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst configured_bignumber_1 = require(\"./configured_bignumber\"); // tslint:disable:custom-no-magic-numbers\n\n\nconst WORD_LENGTH = 32;\nconst WORD_CEIL = new configured_bignumber_1.BigNumber(2).pow(WORD_LENGTH * 8);\nexports.hexUtils = {\n  concat,\n  random,\n  leftPad,\n  rightPad,\n  invert,\n  slice,\n  hash,\n  size,\n  toHex,\n  isHex\n};\n/**\n * Concatenate all arguments as a hex string.\n */\n\nfunction concat() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return ethUtil.bufferToHex(Buffer.concat(args.map(h => ethUtil.toBuffer(h))));\n}\n/**\n * Generate a random hex string.\n */\n\n\nfunction random() {\n  let _size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : WORD_LENGTH;\n\n  return ethUtil.bufferToHex(crypto.randomBytes(_size));\n}\n/**\n * Left-pad a hex number to a number of bytes.\n */\n\n\nfunction leftPad(n) {\n  let _size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WORD_LENGTH;\n\n  return ethUtil.bufferToHex(ethUtil.setLengthLeft(ethUtil.toBuffer(exports.hexUtils.toHex(n)), _size));\n}\n/**\n * Right-pad a hex number to a number of bytes.\n */\n\n\nfunction rightPad(n) {\n  let _size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WORD_LENGTH;\n\n  return ethUtil.bufferToHex(ethUtil.setLengthRight(ethUtil.toBuffer(exports.hexUtils.toHex(n)), _size));\n}\n/**\n * Inverts a hex word.\n */\n\n\nfunction invert(n) {\n  let _size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WORD_LENGTH;\n\n  const buf = ethUtil.setLengthLeft(ethUtil.toBuffer(exports.hexUtils.toHex(n)), _size); // tslint:disable-next-line: no-bitwise\n\n  return ethUtil.bufferToHex(Buffer.from(buf.map(b => ~b)));\n}\n/**\n * Slices a hex number.\n */\n\n\nfunction slice(n, start, end) {\n  const hex = exports.hexUtils.toHex(n).substr(2);\n  const sliceStart = start >= 0 ? start * 2 : Math.max(0, hex.length + start * 2);\n  let sliceEnd = hex.length;\n\n  if (end !== undefined) {\n    sliceEnd = end >= 0 ? end * 2 : Math.max(0, hex.length + end * 2);\n  }\n\n  return '0x'.concat(hex.substring(sliceStart, sliceEnd));\n}\n/**\n * Get the keccak hash of some data.\n */\n\n\nfunction hash(n) {\n  const buf = Buffer.isBuffer(n) ? n : ethUtil.toBuffer(exports.hexUtils.toHex(n));\n  return ethUtil.bufferToHex(ethUtil.keccak256(buf));\n}\n/**\n * Get the length, in bytes, of a hex string.\n */\n\n\nfunction size(hex) {\n  return Math.ceil((hex.length - 2) / 2);\n}\n/**\n * Convert a string, a number, a Buffer, or a BigNumber into a hex string.\n * Works with negative numbers, as well.\n */\n\n\nfunction toHex(n) {\n  let _size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WORD_LENGTH;\n\n  if (Buffer.isBuffer(n)) {\n    return `0x${n.toString('hex')}`;\n  }\n\n  if (typeof n === 'string' && isHex(n)) {\n    // Already a hex.\n    return n;\n  }\n\n  let _n = new configured_bignumber_1.BigNumber(n);\n\n  if (_n.isNegative()) {\n    // Perform two's-complement.\n    // prettier-ignore\n    _n = new configured_bignumber_1.BigNumber(invert(toHex(_n.abs()), _size).substr(2), 16).plus(1).mod(WORD_CEIL);\n  }\n\n  return `0x${_n.toString(16)}`;\n}\n/**\n * Check if a string is a hex string.\n */\n\n\nfunction isHex(s) {\n  return /^0x[0-9a-f]*$/i.test(s);\n}","map":{"version":3,"sources":["../../src/hex_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hexUtils = void 0;\nconst crypto = require(\"crypto\");\nconst ethUtil = require(\"ethereumjs-util\");\nconst configured_bignumber_1 = require(\"./configured_bignumber\");\n// tslint:disable:custom-no-magic-numbers\nconst WORD_LENGTH = 32;\nconst WORD_CEIL = new configured_bignumber_1.BigNumber(2).pow(WORD_LENGTH * 8);\nexports.hexUtils = {\n    concat,\n    random,\n    leftPad,\n    rightPad,\n    invert,\n    slice,\n    hash,\n    size,\n    toHex,\n    isHex,\n};\n/**\n * Concatenate all arguments as a hex string.\n */\nfunction concat(...args) {\n    return ethUtil.bufferToHex(Buffer.concat(args.map(h => ethUtil.toBuffer(h))));\n}\n/**\n * Generate a random hex string.\n */\nfunction random(_size = WORD_LENGTH) {\n    return ethUtil.bufferToHex(crypto.randomBytes(_size));\n}\n/**\n * Left-pad a hex number to a number of bytes.\n */\nfunction leftPad(n, _size = WORD_LENGTH) {\n    return ethUtil.bufferToHex(ethUtil.setLengthLeft(ethUtil.toBuffer(exports.hexUtils.toHex(n)), _size));\n}\n/**\n * Right-pad a hex number to a number of bytes.\n */\nfunction rightPad(n, _size = WORD_LENGTH) {\n    return ethUtil.bufferToHex(ethUtil.setLengthRight(ethUtil.toBuffer(exports.hexUtils.toHex(n)), _size));\n}\n/**\n * Inverts a hex word.\n */\nfunction invert(n, _size = WORD_LENGTH) {\n    const buf = ethUtil.setLengthLeft(ethUtil.toBuffer(exports.hexUtils.toHex(n)), _size);\n    // tslint:disable-next-line: no-bitwise\n    return ethUtil.bufferToHex(Buffer.from(buf.map(b => ~b)));\n}\n/**\n * Slices a hex number.\n */\nfunction slice(n, start, end) {\n    const hex = exports.hexUtils.toHex(n).substr(2);\n    const sliceStart = start >= 0 ? start * 2 : Math.max(0, hex.length + start * 2);\n    let sliceEnd = hex.length;\n    if (end !== undefined) {\n        sliceEnd = end >= 0 ? end * 2 : Math.max(0, hex.length + end * 2);\n    }\n    return '0x'.concat(hex.substring(sliceStart, sliceEnd));\n}\n/**\n * Get the keccak hash of some data.\n */\nfunction hash(n) {\n    const buf = Buffer.isBuffer(n) ? n : ethUtil.toBuffer(exports.hexUtils.toHex(n));\n    return ethUtil.bufferToHex(ethUtil.keccak256(buf));\n}\n/**\n * Get the length, in bytes, of a hex string.\n */\nfunction size(hex) {\n    return Math.ceil((hex.length - 2) / 2);\n}\n/**\n * Convert a string, a number, a Buffer, or a BigNumber into a hex string.\n * Works with negative numbers, as well.\n */\nfunction toHex(n, _size = WORD_LENGTH) {\n    if (Buffer.isBuffer(n)) {\n        return `0x${n.toString('hex')}`;\n    }\n    if (typeof n === 'string' && isHex(n)) {\n        // Already a hex.\n        return n;\n    }\n    let _n = new configured_bignumber_1.BigNumber(n);\n    if (_n.isNegative()) {\n        // Perform two's-complement.\n        // prettier-ignore\n        _n = new configured_bignumber_1.BigNumber(invert(toHex(_n.abs()), _size).substr(2), 16).plus(1).mod(WORD_CEIL);\n    }\n    return `0x${_n.toString(16)}`;\n}\n/**\n * Check if a string is a hex string.\n */\nfunction isHex(s) {\n    return /^0x[0-9a-f]*$/i.test(s);\n}\n//# sourceMappingURL=hex_utils.js.map"]},"metadata":{},"sourceType":"script"}