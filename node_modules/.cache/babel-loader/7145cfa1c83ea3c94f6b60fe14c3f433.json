{"ast":null,"code":"const clone = require('clone');\n\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware');\n\nconst cacheIdentifierForPayload = require('./cache-utils').cacheIdentifierForPayload;\n\nmodule.exports = createInflightCache;\n\nfunction createInflightCache() {\n  const inflightRequests = {};\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) return next(); // get cacheId, if cacheable\n\n    const cacheId = cacheIdentifierForPayload(req); // if not cacheable, skip\n\n    if (!cacheId) return next(); // check for matching requests\n\n    let activeRequestHandlers = inflightRequests[cacheId]; // if found, wait for the active request to be handled\n\n    if (activeRequestHandlers) {\n      // setup the response listener and wait for it to be called\n      // it will handle copying the result and request fields\n      await createActiveRequestHandler(res, activeRequestHandlers);\n      return;\n    } // setup response handler array for subsequent requests\n\n\n    activeRequestHandlers = [];\n    inflightRequests[cacheId] = activeRequestHandlers; // allow request to be handled normally\n\n    await next(); // clear inflight requests\n\n    delete inflightRequests[cacheId]; // schedule activeRequestHandlers to be handled\n\n    handleActiveRequest(res, activeRequestHandlers); // complete\n\n    return;\n  });\n\n  function createActiveRequestHandler(res, activeRequestHandlers) {\n    const {\n      resolve,\n      promise\n    } = deferredPromise();\n    activeRequestHandlers.push(handledRes => {\n      // append a copy of the result and error to the response\n      res.result = clone(handledRes.result);\n      res.error = clone(handledRes.error);\n      resolve();\n    });\n    return promise;\n  }\n\n  function handleActiveRequest(res, activeRequestHandlers) {\n    // use setTimeout so we can resolve our original request first\n    setTimeout(() => {\n      activeRequestHandlers.forEach(handler => {\n        try {\n          handler(res);\n        } catch (err) {\n          // catch error so all requests are handled correctly\n          console.error(err);\n        }\n      });\n    });\n  }\n}\n\nfunction deferredPromise() {\n  let resolve;\n  const promise = new Promise(_resolve => {\n    resolve = _resolve;\n  });\n  return {\n    resolve,\n    promise\n  };\n}","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/node_modules/eth-json-rpc-middleware/inflight-cache.js"],"names":["clone","require","createAsyncMiddleware","cacheIdentifierForPayload","module","exports","createInflightCache","inflightRequests","req","res","next","skipCache","cacheId","activeRequestHandlers","createActiveRequestHandler","handleActiveRequest","resolve","promise","deferredPromise","push","handledRes","result","error","setTimeout","forEach","handler","err","console","Promise","_resolve"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,qBAAqB,GAAGD,OAAO,CAAC,2CAAD,CAArC;;AACA,MAAME,yBAAyB,GAAGF,OAAO,CAAC,eAAD,CAAP,CAAyBE,yBAA3D;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,mBAAjB;;AAGA,SAASA,mBAAT,GAAgC;AAC9B,QAAMC,gBAAgB,GAAG,EAAzB;AAEA,SAAOL,qBAAqB,CAAC,OAAOM,GAAP,EAAYC,GAAZ,EAAiBC,IAAjB,KAA0B;AACrD;AACA,QAAIF,GAAG,CAACG,SAAR,EAAmB,OAAOD,IAAI,EAAX,CAFkC,CAGrD;;AACA,UAAME,OAAO,GAAGT,yBAAyB,CAACK,GAAD,CAAzC,CAJqD,CAKrD;;AACA,QAAI,CAACI,OAAL,EAAc,OAAOF,IAAI,EAAX,CANuC,CAOrD;;AACA,QAAIG,qBAAqB,GAAGN,gBAAgB,CAACK,OAAD,CAA5C,CARqD,CASrD;;AACA,QAAIC,qBAAJ,EAA2B;AACzB;AACA;AACA,YAAMC,0BAA0B,CAACL,GAAD,EAAMI,qBAAN,CAAhC;AACA;AACD,KAfoD,CAgBrD;;;AACAA,IAAAA,qBAAqB,GAAG,EAAxB;AACAN,IAAAA,gBAAgB,CAACK,OAAD,CAAhB,GAA4BC,qBAA5B,CAlBqD,CAmBrD;;AACA,UAAMH,IAAI,EAAV,CApBqD,CAqBrD;;AACA,WAAOH,gBAAgB,CAACK,OAAD,CAAvB,CAtBqD,CAuBrD;;AACAG,IAAAA,mBAAmB,CAACN,GAAD,EAAMI,qBAAN,CAAnB,CAxBqD,CAyBrD;;AACA;AACD,GA3B2B,CAA5B;;AA6BA,WAASC,0BAAT,CAAoCL,GAApC,EAAyCI,qBAAzC,EAAgE;AAC9D,UAAM;AAAEG,MAAAA,OAAF;AAAWC,MAAAA;AAAX,QAAuBC,eAAe,EAA5C;AACAL,IAAAA,qBAAqB,CAACM,IAAtB,CAA4BC,UAAD,IAAgB;AACzC;AACAX,MAAAA,GAAG,CAACY,MAAJ,GAAarB,KAAK,CAACoB,UAAU,CAACC,MAAZ,CAAlB;AACAZ,MAAAA,GAAG,CAACa,KAAJ,GAAYtB,KAAK,CAACoB,UAAU,CAACE,KAAZ,CAAjB;AACAN,MAAAA,OAAO;AACR,KALD;AAMA,WAAOC,OAAP;AACD;;AAED,WAASF,mBAAT,CAA6BN,GAA7B,EAAkCI,qBAAlC,EAAyD;AACvD;AACAU,IAAAA,UAAU,CAAC,MAAM;AACfV,MAAAA,qBAAqB,CAACW,OAAtB,CAA+BC,OAAD,IAAa;AACzC,YAAI;AACFA,UAAAA,OAAO,CAAChB,GAAD,CAAP;AACD,SAFD,CAEE,OAAOiB,GAAP,EAAY;AACZ;AACAC,UAAAA,OAAO,CAACL,KAAR,CAAcI,GAAd;AACD;AACF,OAPD;AAQD,KATS,CAAV;AAUD;AACF;;AAED,SAASR,eAAT,GAA2B;AACzB,MAAIF,OAAJ;AACA,QAAMC,OAAO,GAAG,IAAIW,OAAJ,CAAYC,QAAQ,IAAI;AAAEb,IAAAA,OAAO,GAAGa,QAAV;AAAoB,GAA9C,CAAhB;AACA,SAAO;AAAEb,IAAAA,OAAF;AAAWC,IAAAA;AAAX,GAAP;AACD","sourcesContent":["const clone = require('clone')\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')\nconst cacheIdentifierForPayload = require('./cache-utils').cacheIdentifierForPayload\n\nmodule.exports = createInflightCache\n\n\nfunction createInflightCache () {\n  const inflightRequests = {}\n\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) return next()\n    // get cacheId, if cacheable\n    const cacheId = cacheIdentifierForPayload(req)\n    // if not cacheable, skip\n    if (!cacheId) return next()\n    // check for matching requests\n    let activeRequestHandlers = inflightRequests[cacheId]\n    // if found, wait for the active request to be handled\n    if (activeRequestHandlers) {\n      // setup the response listener and wait for it to be called\n      // it will handle copying the result and request fields\n      await createActiveRequestHandler(res, activeRequestHandlers)\n      return\n    }\n    // setup response handler array for subsequent requests\n    activeRequestHandlers = []\n    inflightRequests[cacheId] = activeRequestHandlers\n    // allow request to be handled normally\n    await next()\n    // clear inflight requests\n    delete inflightRequests[cacheId]\n    // schedule activeRequestHandlers to be handled\n    handleActiveRequest(res, activeRequestHandlers)\n    // complete\n    return\n  })\n\n  function createActiveRequestHandler(res, activeRequestHandlers) {\n    const { resolve, promise } = deferredPromise()\n    activeRequestHandlers.push((handledRes) => {\n      // append a copy of the result and error to the response\n      res.result = clone(handledRes.result)\n      res.error = clone(handledRes.error)\n      resolve()\n    })\n    return promise\n  }\n\n  function handleActiveRequest(res, activeRequestHandlers) {\n    // use setTimeout so we can resolve our original request first\n    setTimeout(() => {\n      activeRequestHandlers.forEach((handler) => {\n        try {\n          handler(res)\n        } catch (err) {\n          // catch error so all requests are handled correctly\n          console.error(err)\n        }\n      })\n    })\n  }\n}\n\nfunction deferredPromise() {\n  let resolve\n  const promise = new Promise(_resolve => { resolve = _resolve })\n  return { resolve, promise }\n}\n"]},"metadata":{},"sourceType":"script"}