{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { ChainId } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { getTokenFromAddress } from 'utils';\nimport { useSelectedTokenList } from 'state/lists/hooks';\nimport { useTokens } from 'hooks/Tokens';\nimport { GlobalValue } from 'constants/index';\nexport class WrappedDualFarmInfo {\n  constructor(stakingInfo, tokenAddressMap, dualFarmTokens, chainId) {\n    this.stakingInfo = void 0;\n    this.chainId = void 0;\n    this.stakingRewardAddress = void 0;\n    this.pair = void 0;\n    this.tokens = void 0;\n    this.ended = void 0;\n    this.lp = void 0;\n    this.name = void 0;\n    this.baseToken = void 0;\n    this.rewardTokenA = void 0;\n    this.rewardTokenB = void 0;\n    this.rewardTokenBBase = void 0;\n    this.rateA = void 0;\n    this.rateB = void 0;\n    this.stakingInfo = stakingInfo; //TODO: Support Multichain\n\n    this.chainId = chainId;\n    this.stakingRewardAddress = stakingInfo.stakingRewardAddress;\n    this.ended = stakingInfo.ended;\n    this.pair = stakingInfo.pair;\n    this.lp = stakingInfo.lp;\n    this.name = stakingInfo.name;\n    this.rateA = stakingInfo.rateA;\n    this.rateB = stakingInfo.rateB;\n    this.baseToken = getTokenFromAddress(stakingInfo.baseToken, chainId, tokenAddressMap, dualFarmTokens);\n    this.tokens = [getTokenFromAddress(stakingInfo.tokens[0], chainId, tokenAddressMap, dualFarmTokens), getTokenFromAddress(stakingInfo.tokens[1], chainId, tokenAddressMap, dualFarmTokens)];\n    this.rewardTokenA = getTokenFromAddress(stakingInfo.rewardTokenA, chainId, tokenAddressMap, dualFarmTokens);\n    this.rewardTokenB = getTokenFromAddress(stakingInfo.rewardTokenB, chainId, tokenAddressMap, dualFarmTokens);\n    this.rewardTokenBBase = getTokenFromAddress(stakingInfo.rewardTokenBBase, chainId, tokenAddressMap, dualFarmTokens);\n  }\n\n}\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST = {\n  [ChainId.TESTNET]: {},\n  [ChainId.MAINNET]: {}\n};\nconst dualFarmCache = typeof WeakMap !== 'undefined' ? new WeakMap() : null;\nexport function listToDualFarmMap(list, tokenAddressMap, dualFarmTokens) {\n  const result = dualFarmCache === null || dualFarmCache === void 0 ? void 0 : dualFarmCache.get(list);\n  if (result) return result;\n  const map = list.active.concat(list.closed).reduce((stakingInfoMap, stakingInfo) => {\n    const wrappedStakingInfo = new WrappedDualFarmInfo(stakingInfo, tokenAddressMap, dualFarmTokens, ChainId.MAINNET);\n    if (stakingInfoMap[wrappedStakingInfo.chainId][wrappedStakingInfo.stakingRewardAddress] !== undefined) throw Error('Duplicate dual farms.');\n    return { ...stakingInfoMap,\n      [wrappedStakingInfo.chainId]: { ...stakingInfoMap[wrappedStakingInfo.chainId],\n        [wrappedStakingInfo.stakingRewardAddress]: wrappedStakingInfo\n      }\n    };\n  }, { ...EMPTY_LIST\n  });\n  dualFarmCache === null || dualFarmCache === void 0 ? void 0 : dualFarmCache.set(list, map);\n  return map;\n}\nexport function useDualFarmList(url) {\n  _s();\n\n  var _dualFarms$url;\n\n  const dualFarms = useSelector(state => state.dualFarms.byUrl);\n  const tokenMap = useSelectedTokenList();\n  const current = url ? (_dualFarms$url = dualFarms[url]) === null || _dualFarms$url === void 0 ? void 0 : _dualFarms$url.current : null;\n  const dualTokenAddresses = current && tokenMap ? current.active.concat(current.closed).map(item => [item.baseToken, item.tokens[0], item.tokens[1], item.rewardTokenA, item.rewardTokenB, item.rewardTokenBBase]).flat().filter(item => !!item).filter(address => !tokenMap[ChainId.MAINNET][address]).filter(address => !Object.values(GlobalValue.tokens.COMMON).find(token => token.address.toLowerCase() === address.toLowerCase())).filter((address, ind, self) => self.findIndex(addr => address.toLowerCase() === addr.toLowerCase()) === ind) : [];\n  const dualFarmTokens = useTokens(dualTokenAddresses);\n  return useMemo(() => {\n    if (!current || !tokenMap || (dualFarmTokens === null || dualFarmTokens === void 0 ? void 0 : dualFarmTokens.length) !== dualTokenAddresses.length) return EMPTY_LIST;\n\n    try {\n      return listToDualFarmMap(current, tokenMap, dualFarmTokens !== null && dualFarmTokens !== void 0 ? dualFarmTokens : []);\n    } catch (error) {\n      console.error('Could not show token list due to error', error);\n      return EMPTY_LIST;\n    }\n  }, [current, dualFarmTokens, dualTokenAddresses.length, tokenMap]);\n}\n\n_s(useDualFarmList, \"qUHz6ffc29Zh1UCMrb07OL8PDfI=\", false, function () {\n  return [useSelector, useSelectedTokenList, useTokens];\n});\n\nexport function useDefaultDualFarmList() {\n  _s2();\n\n  return useDualFarmList(process.env.REACT_APP_DUAL_STAKING_LIST_DEFAULT_URL);\n} // returns all downloaded current lists\n\n_s2(useDefaultDualFarmList, \"zy77yp8m2mGSqu6v4G+XJ/t4JfY=\", false, function () {\n  return [useDualFarmList];\n});\n\nexport function useAllFarms() {\n  _s3();\n\n  const dualFarms = useSelector(state => state.dualFarms.byUrl);\n  return useMemo(() => Object.keys(dualFarms).map(url => dualFarms[url].current).filter(l => Boolean(l)), [dualFarms]);\n}\n\n_s3(useAllFarms, \"/XB1OvvTNrg70U+A9qwkt8ovC8s=\", false, function () {\n  return [useSelector];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/state/dualfarms/hooks.ts"],"names":["ChainId","useMemo","useSelector","getTokenFromAddress","useSelectedTokenList","useTokens","GlobalValue","WrappedDualFarmInfo","constructor","stakingInfo","tokenAddressMap","dualFarmTokens","chainId","stakingRewardAddress","pair","tokens","ended","lp","name","baseToken","rewardTokenA","rewardTokenB","rewardTokenBBase","rateA","rateB","EMPTY_LIST","TESTNET","MAINNET","dualFarmCache","WeakMap","listToDualFarmMap","list","result","get","map","active","concat","closed","reduce","stakingInfoMap","wrappedStakingInfo","undefined","Error","set","useDualFarmList","url","dualFarms","state","byUrl","tokenMap","current","dualTokenAddresses","item","flat","filter","address","Object","values","COMMON","find","token","toLowerCase","ind","self","findIndex","addr","length","error","console","useDefaultDualFarmList","process","env","REACT_APP_DUAL_STAKING_LIST_DEFAULT_URL","useAllFarms","keys","l","Boolean"],"mappings":"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","sourcesContent":["import { ChainId } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { AppState } from 'state';\nimport { DualFarmListInfo, DualStakingRaw, DualStakingBasic } from 'types';\nimport { Token } from '@uniswap/sdk';\nimport { getTokenFromAddress } from 'utils';\nimport { TokenAddressMap, useSelectedTokenList } from 'state/lists/hooks';\nimport { useTokens } from 'hooks/Tokens';\nimport { GlobalValue } from 'constants/index';\n\nexport class WrappedDualFarmInfo implements DualStakingBasic {\n  public readonly stakingInfo: DualStakingRaw;\n  public readonly chainId: ChainId;\n  public readonly stakingRewardAddress: string;\n  public readonly pair: string;\n  public readonly tokens: [Token, Token];\n  public readonly ended: boolean;\n  public readonly lp: string;\n  public readonly name: string;\n  public readonly baseToken: Token;\n  public readonly rewardTokenA: Token;\n  public readonly rewardTokenB: Token;\n  public readonly rewardTokenBBase: Token;\n  public readonly rateA: number;\n  public readonly rateB: number;\n\n  constructor(\n    stakingInfo: DualStakingRaw,\n    tokenAddressMap: TokenAddressMap,\n    dualFarmTokens: Token[],\n    chainId: ChainId,\n  ) {\n    this.stakingInfo = stakingInfo;\n    //TODO: Support Multichain\n    this.chainId = chainId;\n    this.stakingRewardAddress = stakingInfo.stakingRewardAddress;\n    this.ended = stakingInfo.ended;\n    this.pair = stakingInfo.pair;\n    this.lp = stakingInfo.lp;\n    this.name = stakingInfo.name;\n    this.rateA = stakingInfo.rateA;\n    this.rateB = stakingInfo.rateB;\n\n    this.baseToken = getTokenFromAddress(\n      stakingInfo.baseToken,\n      chainId,\n      tokenAddressMap,\n      dualFarmTokens,\n    );\n    this.tokens = [\n      getTokenFromAddress(\n        stakingInfo.tokens[0],\n        chainId,\n        tokenAddressMap,\n        dualFarmTokens,\n      ),\n      getTokenFromAddress(\n        stakingInfo.tokens[1],\n        chainId,\n        tokenAddressMap,\n        dualFarmTokens,\n      ),\n    ];\n\n    this.rewardTokenA = getTokenFromAddress(\n      stakingInfo.rewardTokenA,\n      chainId,\n      tokenAddressMap,\n      dualFarmTokens,\n    );\n    this.rewardTokenB = getTokenFromAddress(\n      stakingInfo.rewardTokenB,\n      chainId,\n      tokenAddressMap,\n      dualFarmTokens,\n    );\n    this.rewardTokenBBase = getTokenFromAddress(\n      stakingInfo.rewardTokenBBase,\n      chainId,\n      tokenAddressMap,\n      dualFarmTokens,\n    );\n  }\n}\n\nexport type DualFarmInfoAddressMap = Readonly<\n  {\n    [chainId in ChainId]: Readonly<{\n      [stakingInfoAddress: string]: WrappedDualFarmInfo;\n    }>;\n  }\n>;\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST: DualFarmInfoAddressMap = {\n  [ChainId.TESTNET]: {},\n  [ChainId.MAINNET]: {},\n};\n\nconst dualFarmCache: WeakMap<DualFarmListInfo, DualFarmInfoAddressMap> | null =\n  typeof WeakMap !== 'undefined'\n    ? new WeakMap<DualFarmListInfo, DualFarmInfoAddressMap>()\n    : null;\n\nexport function listToDualFarmMap(\n  list: DualFarmListInfo,\n  tokenAddressMap: TokenAddressMap,\n  dualFarmTokens: Token[],\n): DualFarmInfoAddressMap {\n  const result = dualFarmCache?.get(list);\n  if (result) return result;\n\n  const map = list.active.concat(list.closed).reduce<DualFarmInfoAddressMap>(\n    (stakingInfoMap, stakingInfo) => {\n      const wrappedStakingInfo = new WrappedDualFarmInfo(\n        stakingInfo,\n        tokenAddressMap,\n        dualFarmTokens,\n        ChainId.MAINNET,\n      );\n      if (\n        stakingInfoMap[wrappedStakingInfo.chainId][\n          wrappedStakingInfo.stakingRewardAddress\n        ] !== undefined\n      )\n        throw Error('Duplicate dual farms.');\n      return {\n        ...stakingInfoMap,\n        [wrappedStakingInfo.chainId]: {\n          ...stakingInfoMap[wrappedStakingInfo.chainId],\n          [wrappedStakingInfo.stakingRewardAddress]: wrappedStakingInfo,\n        },\n      };\n    },\n    { ...EMPTY_LIST },\n  );\n  dualFarmCache?.set(list, map);\n  return map;\n}\n\nexport function useDualFarmList(\n  url: string | undefined,\n): DualFarmInfoAddressMap {\n  const dualFarms = useSelector<AppState, AppState['dualFarms']['byUrl']>(\n    (state) => state.dualFarms.byUrl,\n  );\n  const tokenMap = useSelectedTokenList();\n  const current = url ? dualFarms[url]?.current : null;\n  const dualTokenAddresses =\n    current && tokenMap\n      ? current.active\n          .concat(current.closed)\n          .map((item) => [\n            item.baseToken,\n            item.tokens[0],\n            item.tokens[1],\n            item.rewardTokenA,\n            item.rewardTokenB,\n            item.rewardTokenBBase,\n          ])\n          .flat()\n          .filter((item) => !!item)\n          .filter((address) => !tokenMap[ChainId.MAINNET][address])\n          .filter(\n            (address) =>\n              !Object.values(GlobalValue.tokens.COMMON).find(\n                (token) =>\n                  token.address.toLowerCase() === address.toLowerCase(),\n              ),\n          )\n          .filter(\n            (address, ind, self) =>\n              self.findIndex(\n                (addr) => address.toLowerCase() === addr.toLowerCase(),\n              ) === ind,\n          )\n      : [];\n  const dualFarmTokens = useTokens(dualTokenAddresses);\n  return useMemo(() => {\n    if (\n      !current ||\n      !tokenMap ||\n      dualFarmTokens?.length !== dualTokenAddresses.length\n    )\n      return EMPTY_LIST;\n    try {\n      return listToDualFarmMap(current, tokenMap, dualFarmTokens ?? []);\n    } catch (error) {\n      console.error('Could not show token list due to error', error);\n      return EMPTY_LIST;\n    }\n  }, [current, dualFarmTokens, dualTokenAddresses.length, tokenMap]);\n}\n\nexport function useDefaultDualFarmList(): DualFarmInfoAddressMap {\n  return useDualFarmList(process.env.REACT_APP_DUAL_STAKING_LIST_DEFAULT_URL);\n}\n\n// returns all downloaded current lists\nexport function useAllFarms(): DualFarmListInfo[] {\n  const dualFarms = useSelector<AppState, AppState['dualFarms']['byUrl']>(\n    (state) => state.dualFarms.byUrl,\n  );\n\n  return useMemo(\n    () =>\n      Object.keys(dualFarms)\n        .map((url) => dualFarms[url].current)\n        .filter((l): l is DualFarmListInfo => Boolean(l)),\n    [dualFarms],\n  );\n}\n"]},"metadata":{},"sourceType":"module"}