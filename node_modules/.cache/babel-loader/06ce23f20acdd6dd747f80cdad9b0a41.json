{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { currencyEquals, ETHER, WETH } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { tryParseAmount } from 'state/swap/hooks';\nimport { useTransactionAdder } from 'state/transactions/hooks';\nimport { useCurrencyBalance } from 'state/wallet/hooks';\nimport { useActiveWeb3React } from 'hooks';\nimport { useWETHContract } from './useContract';\nimport { formatTokenAmount } from 'utils';\nexport let WrapType;\n\n(function (WrapType) {\n  WrapType[WrapType[\"NOT_APPLICABLE\"] = 0] = \"NOT_APPLICABLE\";\n  WrapType[WrapType[\"WRAP\"] = 1] = \"WRAP\";\n  WrapType[WrapType[\"UNWRAP\"] = 2] = \"UNWRAP\";\n})(WrapType || (WrapType = {}));\n\nconst NOT_APPLICABLE = {\n  wrapType: WrapType.NOT_APPLICABLE\n};\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\n\nexport default function useWrapCallback(inputCurrency, outputCurrency, typedValue) {\n  _s();\n\n  const {\n    chainId,\n    account\n  } = useActiveWeb3React();\n  const wethContract = useWETHContract();\n  const balance = useCurrencyBalance(account !== null && account !== void 0 ? account : undefined, inputCurrency); // we can always parse the amount typed as the input currency, since wrapping is 1:1\n\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency), [inputCurrency, typedValue]);\n  const addTransaction = useTransactionAdder();\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE;\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);\n\n    if (inputCurrency === ETHER && currencyEquals(WETH[chainId], outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.deposit({\n              value: `0x${inputAmount.raw.toString(16)}`\n            });\n            addTransaction(txReceipt, {\n              summary: `Wrap ${formatTokenAmount(inputAmount)} ETH to WETH`\n            });\n          } catch (error) {\n            console.error('Could not deposit', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient ETH balance'\n      };\n    } else if (currencyEquals(WETH[chainId], inputCurrency) && outputCurrency === ETHER) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`);\n            addTransaction(txReceipt, {\n              summary: `Unwrap ${formatTokenAmount(inputAmount)} WETH to ETH`\n            });\n          } catch (error) {\n            console.error('Could not withdraw', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient WETH balance'\n      };\n    } else {\n      return NOT_APPLICABLE;\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction]);\n}\n\n_s(useWrapCallback, \"vntrhns1+yhOf5a8SvIDHA0AeGc=\", false, function () {\n  return [useActiveWeb3React, useWETHContract, useCurrencyBalance, useTransactionAdder];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/hooks/useWrapCallback.ts"],"names":["currencyEquals","ETHER","WETH","useMemo","tryParseAmount","useTransactionAdder","useCurrencyBalance","useActiveWeb3React","useWETHContract","formatTokenAmount","WrapType","NOT_APPLICABLE","wrapType","useWrapCallback","inputCurrency","outputCurrency","typedValue","chainId","account","wethContract","balance","undefined","inputAmount","addTransaction","sufficientBalance","lessThan","WRAP","execute","txReceipt","deposit","value","raw","toString","summary","error","console","inputError","UNWRAP","withdraw"],"mappings":"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","sourcesContent":["import { Currency, currencyEquals, ETHER, WETH } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { tryParseAmount } from 'state/swap/hooks';\nimport { useTransactionAdder } from 'state/transactions/hooks';\nimport { useCurrencyBalance } from 'state/wallet/hooks';\nimport { useActiveWeb3React } from 'hooks';\nimport { useWETHContract } from './useContract';\nimport { formatTokenAmount } from 'utils';\n\nexport enum WrapType {\n  NOT_APPLICABLE,\n  WRAP,\n  UNWRAP,\n}\n\nconst NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE };\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\nexport default function useWrapCallback(\n  inputCurrency: Currency | undefined,\n  outputCurrency: Currency | undefined,\n  typedValue: string | undefined,\n): {\n  wrapType: WrapType;\n  execute?: undefined | (() => Promise<void>);\n  inputError?: string;\n} {\n  const { chainId, account } = useActiveWeb3React();\n  const wethContract = useWETHContract();\n  const balance = useCurrencyBalance(account ?? undefined, inputCurrency);\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency), [\n    inputCurrency,\n    typedValue,\n  ]);\n  const addTransaction = useTransactionAdder();\n\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency)\n      return NOT_APPLICABLE;\n\n    const sufficientBalance =\n      inputAmount && balance && !balance.lessThan(inputAmount);\n\n    if (\n      inputCurrency === ETHER &&\n      currencyEquals(WETH[chainId], outputCurrency)\n    ) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const txReceipt = await wethContract.deposit({\n                    value: `0x${inputAmount.raw.toString(16)}`,\n                  });\n                  addTransaction(txReceipt, {\n                    summary: `Wrap ${formatTokenAmount(\n                      inputAmount,\n                    )} ETH to WETH`,\n                  });\n                } catch (error) {\n                  console.error('Could not deposit', error);\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient ETH balance',\n      };\n    } else if (\n      currencyEquals(WETH[chainId], inputCurrency) &&\n      outputCurrency === ETHER\n    ) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const txReceipt = await wethContract.withdraw(\n                    `0x${inputAmount.raw.toString(16)}`,\n                  );\n                  addTransaction(txReceipt, {\n                    summary: `Unwrap ${formatTokenAmount(\n                      inputAmount,\n                    )} WETH to ETH`,\n                  });\n                } catch (error) {\n                  console.error('Could not withdraw', error);\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient WETH balance',\n      };\n    } else {\n      return NOT_APPLICABLE;\n    }\n  }, [\n    wethContract,\n    chainId,\n    inputCurrency,\n    outputCurrency,\n    inputAmount,\n    balance,\n    addTransaction,\n  ]);\n}\n"]},"metadata":{},"sourceType":"module"}