{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { ChainId } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { useSelectedTokenList } from 'state/lists/hooks';\nimport { getTokenFromAddress } from 'utils';\nimport { useTokens } from 'hooks/Tokens';\nimport { GlobalValue } from 'constants/index';\nexport class WrappedSyrupInfo {\n  constructor(syrupInfo, tokenAddressMap, syrupTokens, chainId) {\n    this.stakingInfo = void 0;\n    this.chainId = void 0;\n    this.stakingRewardAddress = void 0;\n    this.rate = void 0;\n    this.ended = void 0;\n    this.lp = void 0;\n    this.name = void 0;\n    this.ending = void 0;\n    this.baseToken = void 0;\n    this.token = void 0;\n    this.stakingToken = void 0;\n    this.stakingInfo = syrupInfo; //TODO: Support Multichain\n\n    this.chainId = ChainId.MAINNET;\n    this.stakingRewardAddress = syrupInfo.stakingRewardAddress;\n    this.rate = syrupInfo.rate;\n    this.ended = syrupInfo.ended;\n    this.lp = syrupInfo.lp;\n    this.name = syrupInfo.name;\n    this.ending = syrupInfo.ending;\n    this.baseToken = getTokenFromAddress(syrupInfo.baseToken, chainId, tokenAddressMap, syrupTokens);\n    this.stakingToken = getTokenFromAddress(syrupInfo.stakingToken, chainId, tokenAddressMap, syrupTokens);\n    this.token = getTokenFromAddress(syrupInfo.token, chainId, tokenAddressMap, syrupTokens);\n  }\n\n}\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST = {\n  [ChainId.TESTNET]: {},\n  [ChainId.MAINNET]: {}\n};\nconst syrupCache = typeof WeakMap !== 'undefined' ? new WeakMap() : null;\nexport function listToSyrupMap(list, tokenAddressMap, syrupTokens) {\n  const result = syrupCache === null || syrupCache === void 0 ? void 0 : syrupCache.get(list);\n  if (result) return result;\n  const map = list.active.concat(list.closed).reduce((syrupInfoMap, syrup) => {\n    const wrappedSyrupInfo = new WrappedSyrupInfo(syrup, tokenAddressMap, syrupTokens, ChainId.MAINNET);\n    if (syrupInfoMap[wrappedSyrupInfo.chainId][wrappedSyrupInfo.stakingRewardAddress] !== undefined) throw Error('Duplicate syrups.');\n    return { ...syrupInfoMap,\n      [wrappedSyrupInfo.chainId]: { ...syrupInfoMap[wrappedSyrupInfo.chainId],\n        [wrappedSyrupInfo.stakingRewardAddress]: wrappedSyrupInfo\n      }\n    };\n  }, { ...EMPTY_LIST\n  });\n  syrupCache === null || syrupCache === void 0 ? void 0 : syrupCache.set(list, map);\n  return map;\n}\nexport function useSyrupList(url) {\n  _s();\n\n  var _syrups$url;\n\n  const syrups = useSelector(state => state.syrups.byUrl);\n  const tokenMap = useSelectedTokenList();\n  const current = url ? (_syrups$url = syrups[url]) === null || _syrups$url === void 0 ? void 0 : _syrups$url.current : null;\n  const syrupTokenAddresses = current && tokenMap ? current.active.concat(current.closed).map(item => [item.baseToken, item.token, item.stakingToken]).flat().filter(item => !!item).filter(address => !tokenMap[ChainId.MAINNET][address]).filter(address => !Object.values(GlobalValue.tokens.COMMON).find(token => token.address.toLowerCase() === address.toLowerCase())).filter((address, ind, self) => self.findIndex(addr => address.toLowerCase() === addr.toLowerCase()) === ind) : [];\n  const syrupTokens = useTokens(syrupTokenAddresses);\n  return useMemo(() => {\n    if (!current || !tokenMap || syrupTokenAddresses.length !== (syrupTokens === null || syrupTokens === void 0 ? void 0 : syrupTokens.length)) return EMPTY_LIST;\n\n    try {\n      return listToSyrupMap(current, tokenMap, syrupTokens !== null && syrupTokens !== void 0 ? syrupTokens : []);\n    } catch (error) {\n      console.error('Could not show token list due to error', error);\n      return EMPTY_LIST;\n    }\n  }, [current, tokenMap, syrupTokenAddresses.length, syrupTokens]);\n}\n\n_s(useSyrupList, \"2wXDB6LW+SH8U19J1cbAaMuLLUM=\", false, function () {\n  return [useSelector, useSelectedTokenList, useTokens];\n});\n\nexport function useDefaultSyrupList() {\n  _s2();\n\n  return useSyrupList(process.env.REACT_APP_SYRUP_LIST_DEFAULT_URL);\n} // returns all downloaded current lists\n\n_s2(useDefaultSyrupList, \"/XmcV6mMYJZZ6TOb6MFuwLO9dPA=\", false, function () {\n  return [useSyrupList];\n});\n\nexport function useAllSyrups() {\n  _s3();\n\n  const syrups = useSelector(state => state.syrups.byUrl);\n  return useMemo(() => Object.keys(syrups).map(url => syrups[url].current).filter(l => Boolean(l)), [syrups]);\n}\n\n_s3(useAllSyrups, \"6vFiUFhzIut+OcQ3sBhePhfTujQ=\", false, function () {\n  return [useSelector];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/state/syrups/hooks.ts"],"names":["ChainId","useMemo","useSelector","useSelectedTokenList","getTokenFromAddress","useTokens","GlobalValue","WrappedSyrupInfo","constructor","syrupInfo","tokenAddressMap","syrupTokens","chainId","stakingInfo","stakingRewardAddress","rate","ended","lp","name","ending","baseToken","token","stakingToken","MAINNET","EMPTY_LIST","TESTNET","syrupCache","WeakMap","listToSyrupMap","list","result","get","map","active","concat","closed","reduce","syrupInfoMap","syrup","wrappedSyrupInfo","undefined","Error","set","useSyrupList","url","syrups","state","byUrl","tokenMap","current","syrupTokenAddresses","item","flat","filter","address","Object","values","tokens","COMMON","find","toLowerCase","ind","self","findIndex","addr","length","error","console","useDefaultSyrupList","process","env","REACT_APP_SYRUP_LIST_DEFAULT_URL","useAllSyrups","keys","l","Boolean"],"mappings":";;;;AAAA,SAASA,OAAT,QAAwB,cAAxB;AACA,SAASC,OAAT,QAAwB,OAAxB;AACA,SAASC,WAAT,QAA4B,aAA5B;AAIA,SAA0BC,oBAA1B,QAAsD,mBAAtD;AACA,SAASC,mBAAT,QAAoC,OAApC;AACA,SAASC,SAAT,QAA0B,cAA1B;AACA,SAASC,WAAT,QAA4B,iBAA5B;AAEA,OAAO,MAAMC,gBAAN,CAA6C;AAalDC,EAAAA,WAAW,CACTC,SADS,EAETC,eAFS,EAGTC,WAHS,EAITC,OAJS,EAKT;AAAA,SAjBcC,WAiBd;AAAA,SAhBcD,OAgBd;AAAA,SAfcE,oBAed;AAAA,SAdcC,IAcd;AAAA,SAbcC,KAad;AAAA,SAZcC,EAYd;AAAA,SAXcC,IAWd;AAAA,SAVcC,MAUd;AAAA,SATcC,SASd;AAAA,SARcC,KAQd;AAAA,SAPcC,YAOd;AACA,SAAKT,WAAL,GAAmBJ,SAAnB,CADA,CAEA;;AACA,SAAKG,OAAL,GAAeZ,OAAO,CAACuB,OAAvB;AACA,SAAKT,oBAAL,GAA4BL,SAAS,CAACK,oBAAtC;AACA,SAAKC,IAAL,GAAYN,SAAS,CAACM,IAAtB;AACA,SAAKC,KAAL,GAAaP,SAAS,CAACO,KAAvB;AACA,SAAKC,EAAL,GAAUR,SAAS,CAACQ,EAApB;AACA,SAAKC,IAAL,GAAYT,SAAS,CAACS,IAAtB;AACA,SAAKC,MAAL,GAAcV,SAAS,CAACU,MAAxB;AAEA,SAAKC,SAAL,GAAiBhB,mBAAmB,CAClCK,SAAS,CAACW,SADwB,EAElCR,OAFkC,EAGlCF,eAHkC,EAIlCC,WAJkC,CAApC;AAMA,SAAKW,YAAL,GAAoBlB,mBAAmB,CACrCK,SAAS,CAACa,YAD2B,EAErCV,OAFqC,EAGrCF,eAHqC,EAIrCC,WAJqC,CAAvC;AAMA,SAAKU,KAAL,GAAajB,mBAAmB,CAC9BK,SAAS,CAACY,KADoB,EAE9BT,OAF8B,EAG9BF,eAH8B,EAI9BC,WAJ8B,CAAhC;AAMD;;AA/CiD;;AA0DpD;AACA;AACA;AACA,MAAMa,UAA+B,GAAG;AACtC,GAACxB,OAAO,CAACyB,OAAT,GAAmB,EADmB;AAEtC,GAACzB,OAAO,CAACuB,OAAT,GAAmB;AAFmB,CAAxC;AAKA,MAAMG,UAA8D,GAClE,OAAOC,OAAP,KAAmB,WAAnB,GACI,IAAIA,OAAJ,EADJ,GAEI,IAHN;AAKA,OAAO,SAASC,cAAT,CACLC,IADK,EAELnB,eAFK,EAGLC,WAHK,EAIgB;AACrB,QAAMmB,MAAM,GAAGJ,UAAH,aAAGA,UAAH,uBAAGA,UAAU,CAAEK,GAAZ,CAAgBF,IAAhB,CAAf;AACA,MAAIC,MAAJ,EAAY,OAAOA,MAAP;AAEZ,QAAME,GAAG,GAAGH,IAAI,CAACI,MAAL,CAAYC,MAAZ,CAAmBL,IAAI,CAACM,MAAxB,EAAgCC,MAAhC,CACV,CAACC,YAAD,EAAeC,KAAf,KAAyB;AACvB,UAAMC,gBAAgB,GAAG,IAAIhC,gBAAJ,CACvB+B,KADuB,EAEvB5B,eAFuB,EAGvBC,WAHuB,EAIvBX,OAAO,CAACuB,OAJe,CAAzB;AAMA,QACEc,YAAY,CAACE,gBAAgB,CAAC3B,OAAlB,CAAZ,CACE2B,gBAAgB,CAACzB,oBADnB,MAEM0B,SAHR,EAKE,MAAMC,KAAK,CAAC,mBAAD,CAAX;AACF,WAAO,EACL,GAAGJ,YADE;AAEL,OAACE,gBAAgB,CAAC3B,OAAlB,GAA4B,EAC1B,GAAGyB,YAAY,CAACE,gBAAgB,CAAC3B,OAAlB,CADW;AAE1B,SAAC2B,gBAAgB,CAACzB,oBAAlB,GAAyCyB;AAFf;AAFvB,KAAP;AAOD,GArBS,EAsBV,EAAE,GAAGf;AAAL,GAtBU,CAAZ;AAwBAE,EAAAA,UAAU,SAAV,IAAAA,UAAU,WAAV,YAAAA,UAAU,CAAEgB,GAAZ,CAAgBb,IAAhB,EAAsBG,GAAtB;AACA,SAAOA,GAAP;AACD;AAED,OAAO,SAASW,YAAT,CAAsBC,GAAtB,EAAoE;AAAA;;AAAA;;AACzE,QAAMC,MAAM,GAAG3C,WAAW,CACvB4C,KAAD,IAAWA,KAAK,CAACD,MAAN,CAAaE,KADA,CAA1B;AAGA,QAAMC,QAAQ,GAAG7C,oBAAoB,EAArC;AACA,QAAM8C,OAAO,GAAGL,GAAG,kBAAGC,MAAM,CAACD,GAAD,CAAT,gDAAG,YAAaK,OAAhB,GAA0B,IAA7C;AACA,QAAMC,mBAAmB,GACvBD,OAAO,IAAID,QAAX,GACIC,OAAO,CAAChB,MAAR,CACGC,MADH,CACUe,OAAO,CAACd,MADlB,EAEGH,GAFH,CAEQmB,IAAD,IAAU,CAACA,IAAI,CAAC/B,SAAN,EAAiB+B,IAAI,CAAC9B,KAAtB,EAA6B8B,IAAI,CAAC7B,YAAlC,CAFjB,EAGG8B,IAHH,GAIGC,MAJH,CAIWF,IAAD,IAAU,CAAC,CAACA,IAJtB,EAKGE,MALH,CAKWC,OAAD,IAAa,CAACN,QAAQ,CAAChD,OAAO,CAACuB,OAAT,CAAR,CAA0B+B,OAA1B,CALxB,EAMGD,MANH,CAOKC,OAAD,IACE,CAACC,MAAM,CAACC,MAAP,CAAclD,WAAW,CAACmD,MAAZ,CAAmBC,MAAjC,EAAyCC,IAAzC,CACEtC,KAAD,IACEA,KAAK,CAACiC,OAAN,CAAcM,WAAd,OAAgCN,OAAO,CAACM,WAAR,EAFnC,CARP,EAaGP,MAbH,CAcI,CAACC,OAAD,EAAUO,GAAV,EAAeC,IAAf,KACEA,IAAI,CAACC,SAAL,CACGC,IAAD,IAAUV,OAAO,CAACM,WAAR,OAA0BI,IAAI,CAACJ,WAAL,EADtC,MAEMC,GAjBZ,CADJ,GAoBI,EArBN;AAsBA,QAAMlD,WAAW,GAAGN,SAAS,CAAC6C,mBAAD,CAA7B;AACA,SAAOjD,OAAO,CAAC,MAAM;AACnB,QACE,CAACgD,OAAD,IACA,CAACD,QADD,IAEAE,mBAAmB,CAACe,MAApB,MAA+BtD,WAA/B,aAA+BA,WAA/B,uBAA+BA,WAAW,CAAEsD,MAA5C,CAHF,EAKE,OAAOzC,UAAP;;AACF,QAAI;AACF,aAAOI,cAAc,CAACqB,OAAD,EAAUD,QAAV,EAAoBrC,WAApB,aAAoBA,WAApB,cAAoBA,WAApB,GAAmC,EAAnC,CAArB;AACD,KAFD,CAEE,OAAOuD,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACD,KAAR,CAAc,wCAAd,EAAwDA,KAAxD;AACA,aAAO1C,UAAP;AACD;AACF,GAba,EAaX,CAACyB,OAAD,EAAUD,QAAV,EAAoBE,mBAAmB,CAACe,MAAxC,EAAgDtD,WAAhD,CAbW,CAAd;AAcD;;GA3CegC,Y;UACCzC,W,EAGEC,oB,EAwBGE,S;;;AAiBtB,OAAO,SAAS+D,mBAAT,GAAoD;AAAA;;AACzD,SAAOzB,YAAY,CAAC0B,OAAO,CAACC,GAAR,CAAYC,gCAAb,CAAnB;AACD,C,CAED;;IAJgBH,mB;UACPzB,Y;;;AAIT,OAAO,SAAS6B,YAAT,GAAyC;AAAA;;AAC9C,QAAM3B,MAAM,GAAG3C,WAAW,CACvB4C,KAAD,IAAWA,KAAK,CAACD,MAAN,CAAaE,KADA,CAA1B;AAIA,SAAO9C,OAAO,CACZ,MACEsD,MAAM,CAACkB,IAAP,CAAY5B,MAAZ,EACGb,GADH,CACQY,GAAD,IAASC,MAAM,CAACD,GAAD,CAAN,CAAYK,OAD5B,EAEGI,MAFH,CAEWqB,CAAD,IAA2BC,OAAO,CAACD,CAAD,CAF5C,CAFU,EAKZ,CAAC7B,MAAD,CALY,CAAd;AAOD;;IAZe2B,Y;UACCtE,W","sourcesContent":["import { ChainId } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { AppState } from 'state';\nimport { SyrupListInfo, SyrupRaw, SyrupBasic } from 'types';\nimport { Token } from '@uniswap/sdk';\nimport { TokenAddressMap, useSelectedTokenList } from 'state/lists/hooks';\nimport { getTokenFromAddress } from 'utils';\nimport { useTokens } from 'hooks/Tokens';\nimport { GlobalValue } from 'constants/index';\n\nexport class WrappedSyrupInfo implements SyrupBasic {\n  public readonly stakingInfo: SyrupRaw;\n  public readonly chainId: ChainId;\n  public readonly stakingRewardAddress: string;\n  public readonly rate: number;\n  public readonly ended: boolean;\n  public readonly lp: string;\n  public readonly name: string;\n  public readonly ending: number;\n  public readonly baseToken: Token;\n  public readonly token: Token;\n  public readonly stakingToken: Token;\n\n  constructor(\n    syrupInfo: SyrupRaw,\n    tokenAddressMap: TokenAddressMap,\n    syrupTokens: Token[],\n    chainId: ChainId,\n  ) {\n    this.stakingInfo = syrupInfo;\n    //TODO: Support Multichain\n    this.chainId = ChainId.MAINNET;\n    this.stakingRewardAddress = syrupInfo.stakingRewardAddress;\n    this.rate = syrupInfo.rate;\n    this.ended = syrupInfo.ended;\n    this.lp = syrupInfo.lp;\n    this.name = syrupInfo.name;\n    this.ending = syrupInfo.ending;\n\n    this.baseToken = getTokenFromAddress(\n      syrupInfo.baseToken,\n      chainId,\n      tokenAddressMap,\n      syrupTokens,\n    );\n    this.stakingToken = getTokenFromAddress(\n      syrupInfo.stakingToken,\n      chainId,\n      tokenAddressMap,\n      syrupTokens,\n    );\n    this.token = getTokenFromAddress(\n      syrupInfo.token,\n      chainId,\n      tokenAddressMap,\n      syrupTokens,\n    );\n  }\n}\n\nexport type SyrupInfoAddressMap = Readonly<\n  {\n    [chainId in ChainId]: Readonly<{\n      [stakingInfoAddress: string]: WrappedSyrupInfo;\n    }>;\n  }\n>;\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST: SyrupInfoAddressMap = {\n  [ChainId.TESTNET]: {},\n  [ChainId.MAINNET]: {},\n};\n\nconst syrupCache: WeakMap<SyrupListInfo, SyrupInfoAddressMap> | null =\n  typeof WeakMap !== 'undefined'\n    ? new WeakMap<SyrupListInfo, SyrupInfoAddressMap>()\n    : null;\n\nexport function listToSyrupMap(\n  list: SyrupListInfo,\n  tokenAddressMap: TokenAddressMap,\n  syrupTokens: Token[],\n): SyrupInfoAddressMap {\n  const result = syrupCache?.get(list);\n  if (result) return result;\n\n  const map = list.active.concat(list.closed).reduce<SyrupInfoAddressMap>(\n    (syrupInfoMap, syrup) => {\n      const wrappedSyrupInfo = new WrappedSyrupInfo(\n        syrup,\n        tokenAddressMap,\n        syrupTokens,\n        ChainId.MAINNET,\n      );\n      if (\n        syrupInfoMap[wrappedSyrupInfo.chainId][\n          wrappedSyrupInfo.stakingRewardAddress\n        ] !== undefined\n      )\n        throw Error('Duplicate syrups.');\n      return {\n        ...syrupInfoMap,\n        [wrappedSyrupInfo.chainId]: {\n          ...syrupInfoMap[wrappedSyrupInfo.chainId],\n          [wrappedSyrupInfo.stakingRewardAddress]: wrappedSyrupInfo,\n        },\n      };\n    },\n    { ...EMPTY_LIST },\n  );\n  syrupCache?.set(list, map);\n  return map;\n}\n\nexport function useSyrupList(url: string | undefined): SyrupInfoAddressMap {\n  const syrups = useSelector<AppState, AppState['syrups']['byUrl']>(\n    (state) => state.syrups.byUrl,\n  );\n  const tokenMap = useSelectedTokenList();\n  const current = url ? syrups[url]?.current : null;\n  const syrupTokenAddresses =\n    current && tokenMap\n      ? current.active\n          .concat(current.closed)\n          .map((item) => [item.baseToken, item.token, item.stakingToken])\n          .flat()\n          .filter((item) => !!item)\n          .filter((address) => !tokenMap[ChainId.MAINNET][address])\n          .filter(\n            (address) =>\n              !Object.values(GlobalValue.tokens.COMMON).find(\n                (token) =>\n                  token.address.toLowerCase() === address.toLowerCase(),\n              ),\n          )\n          .filter(\n            (address, ind, self) =>\n              self.findIndex(\n                (addr) => address.toLowerCase() === addr.toLowerCase(),\n              ) === ind,\n          )\n      : [];\n  const syrupTokens = useTokens(syrupTokenAddresses);\n  return useMemo(() => {\n    if (\n      !current ||\n      !tokenMap ||\n      syrupTokenAddresses.length !== syrupTokens?.length\n    )\n      return EMPTY_LIST;\n    try {\n      return listToSyrupMap(current, tokenMap, syrupTokens ?? []);\n    } catch (error) {\n      console.error('Could not show token list due to error', error);\n      return EMPTY_LIST;\n    }\n  }, [current, tokenMap, syrupTokenAddresses.length, syrupTokens]);\n}\n\nexport function useDefaultSyrupList(): SyrupInfoAddressMap {\n  return useSyrupList(process.env.REACT_APP_SYRUP_LIST_DEFAULT_URL);\n}\n\n// returns all downloaded current lists\nexport function useAllSyrups(): SyrupListInfo[] {\n  const syrups = useSelector<AppState, AppState['syrups']['byUrl']>(\n    (state) => state.syrups.byUrl,\n  );\n\n  return useMemo(\n    () =>\n      Object.keys(syrups)\n        .map((url) => syrups[url].current)\n        .filter((l): l is SyrupListInfo => Boolean(l)),\n    [syrups],\n  );\n}\n"]},"metadata":{},"sourceType":"module"}