{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { MaxUint256 } from '@ethersproject/constants';\nimport { TokenAmount, ETHER } from '@uniswap/sdk';\nimport { useCallback, useMemo } from 'react';\nimport { GlobalConst } from 'constants/index';\nimport { useTokenAllowance } from 'data/Allowances';\nimport { Field } from 'state/swap/actions';\nimport { useTransactionAdder, useHasPendingApproval } from 'state/transactions/hooks';\nimport { computeSlippageAdjustedAmounts } from 'utils/prices';\nimport { calculateGasMargin } from 'utils';\nimport { useActiveWeb3React } from 'hooks';\nimport { useTokenContract } from './useContract';\nexport let ApprovalState; // returns a variable indicating the state of the approval and a function which approves if necessary or early returns\n\n(function (ApprovalState) {\n  ApprovalState[ApprovalState[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ApprovalState[ApprovalState[\"NOT_APPROVED\"] = 1] = \"NOT_APPROVED\";\n  ApprovalState[ApprovalState[\"PENDING\"] = 2] = \"PENDING\";\n  ApprovalState[ApprovalState[\"APPROVED\"] = 3] = \"APPROVED\";\n})(ApprovalState || (ApprovalState = {}));\n\nexport function useApproveCallback(amountToApprove, spender) {\n  _s();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const token = amountToApprove instanceof TokenAmount ? amountToApprove.token : undefined;\n  const currentAllowance = useTokenAllowance(token, account !== null && account !== void 0 ? account : undefined, spender);\n  const pendingApproval = useHasPendingApproval(token === null || token === void 0 ? void 0 : token.address, spender); // check the current approval status\n\n  const approvalState = useMemo(() => {\n    if (!amountToApprove || !spender) return ApprovalState.UNKNOWN;\n    if (amountToApprove.currency === ETHER) return ApprovalState.APPROVED; // we might not have enough data to know whether or not we need to approve\n\n    if (!currentAllowance) return ApprovalState.UNKNOWN; // amountToApprove will be defined if currentAllowance is\n\n    return currentAllowance.lessThan(amountToApprove) ? pendingApproval ? ApprovalState.PENDING : ApprovalState.NOT_APPROVED : ApprovalState.APPROVED;\n  }, [amountToApprove, currentAllowance, pendingApproval, spender]);\n  const tokenContract = useTokenContract(token === null || token === void 0 ? void 0 : token.address);\n  const addTransaction = useTransactionAdder();\n  const approve = useCallback(async () => {\n    if (approvalState !== ApprovalState.NOT_APPROVED) {\n      console.error('approve was called unnecessarily');\n      return;\n    }\n\n    if (!token) {\n      console.error('no token');\n      return;\n    }\n\n    if (!tokenContract) {\n      console.error('tokenContract is null');\n      return;\n    }\n\n    if (!amountToApprove) {\n      console.error('missing amount to approve');\n      return;\n    }\n\n    if (!spender) {\n      console.error('no spender');\n      return;\n    }\n\n    let useExact = false;\n    const estimatedGas = await tokenContract.estimateGas.approve(spender, MaxUint256).catch(() => {\n      // general fallback for tokens who restrict approval amounts\n      useExact = true;\n      return tokenContract.estimateGas.approve(spender, amountToApprove.raw.toString());\n    });\n    return tokenContract.approve(spender, useExact ? amountToApprove.raw.toString() : MaxUint256, {\n      gasLimit: calculateGasMargin(estimatedGas)\n    }).then(async response => {\n      addTransaction(response, {\n        summary: 'Approve ' + amountToApprove.currency.symbol,\n        approval: {\n          tokenAddress: token.address,\n          spender: spender\n        }\n      });\n\n      try {\n        await response.wait();\n      } catch (e) {\n        console.debug('Failed to approve token', e);\n        throw e;\n      }\n    }).catch(error => {\n      console.debug('Failed to approve token', error);\n      throw error;\n    });\n  }, [approvalState, token, tokenContract, amountToApprove, spender, addTransaction]);\n  return [approvalState, approve];\n} // wraps useApproveCallback in the context of a swap\n\n_s(useApproveCallback, \"plwsGYaNX4d3wLCzJ71NjiUoggk=\", false, function () {\n  return [useActiveWeb3React, useTokenAllowance, useHasPendingApproval, useTokenContract, useTransactionAdder];\n});\n\nexport function useApproveCallbackFromTrade(trade) {\n  _s2();\n\n  let allowedSlippage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const amountToApprove = useMemo(() => trade ? computeSlippageAdjustedAmounts(trade, allowedSlippage)[Field.INPUT] : undefined, [trade, allowedSlippage]);\n  return useApproveCallback(amountToApprove, chainId ? GlobalConst.addresses.ROUTER_ADDRESS[chainId] : undefined);\n}\n\n_s2(useApproveCallbackFromTrade, \"QhjbDiza7iaVN/W6uza+jjAKmt4=\", false, function () {\n  return [useActiveWeb3React, useApproveCallback];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/hooks/useApproveCallback.ts"],"names":["MaxUint256","TokenAmount","ETHER","useCallback","useMemo","GlobalConst","useTokenAllowance","Field","useTransactionAdder","useHasPendingApproval","computeSlippageAdjustedAmounts","calculateGasMargin","useActiveWeb3React","useTokenContract","ApprovalState","useApproveCallback","amountToApprove","spender","account","token","undefined","currentAllowance","pendingApproval","address","approvalState","UNKNOWN","currency","APPROVED","lessThan","PENDING","NOT_APPROVED","tokenContract","addTransaction","approve","console","error","useExact","estimatedGas","estimateGas","catch","raw","toString","gasLimit","then","response","summary","symbol","approval","tokenAddress","wait","e","debug","useApproveCallbackFromTrade","trade","allowedSlippage","chainId","INPUT","addresses","ROUTER_ADDRESS"],"mappings":"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","sourcesContent":["import { MaxUint256 } from '@ethersproject/constants';\nimport { TransactionResponse } from '@ethersproject/providers';\nimport { Trade, TokenAmount, CurrencyAmount, ETHER } from '@uniswap/sdk';\nimport { useCallback, useMemo } from 'react';\nimport { GlobalConst } from 'constants/index';\nimport { useTokenAllowance } from 'data/Allowances';\nimport { Field } from 'state/swap/actions';\nimport {\n  useTransactionAdder,\n  useHasPendingApproval,\n} from 'state/transactions/hooks';\nimport { computeSlippageAdjustedAmounts } from 'utils/prices';\nimport { calculateGasMargin } from 'utils';\nimport { useActiveWeb3React } from 'hooks';\nimport { useTokenContract } from './useContract';\n\nexport enum ApprovalState {\n  UNKNOWN,\n  NOT_APPROVED,\n  PENDING,\n  APPROVED,\n}\n\n// returns a variable indicating the state of the approval and a function which approves if necessary or early returns\nexport function useApproveCallback(\n  amountToApprove?: CurrencyAmount,\n  spender?: string,\n): [ApprovalState, () => Promise<void>] {\n  const { account } = useActiveWeb3React();\n  const token =\n    amountToApprove instanceof TokenAmount ? amountToApprove.token : undefined;\n  const currentAllowance = useTokenAllowance(\n    token,\n    account ?? undefined,\n    spender,\n  );\n  const pendingApproval = useHasPendingApproval(token?.address, spender);\n\n  // check the current approval status\n  const approvalState: ApprovalState = useMemo(() => {\n    if (!amountToApprove || !spender) return ApprovalState.UNKNOWN;\n    if (amountToApprove.currency === ETHER) return ApprovalState.APPROVED;\n    // we might not have enough data to know whether or not we need to approve\n    if (!currentAllowance) return ApprovalState.UNKNOWN;\n\n    // amountToApprove will be defined if currentAllowance is\n    return currentAllowance.lessThan(amountToApprove)\n      ? pendingApproval\n        ? ApprovalState.PENDING\n        : ApprovalState.NOT_APPROVED\n      : ApprovalState.APPROVED;\n  }, [amountToApprove, currentAllowance, pendingApproval, spender]);\n\n  const tokenContract = useTokenContract(token?.address);\n  const addTransaction = useTransactionAdder();\n\n  const approve = useCallback(async (): Promise<void> => {\n    if (approvalState !== ApprovalState.NOT_APPROVED) {\n      console.error('approve was called unnecessarily');\n      return;\n    }\n    if (!token) {\n      console.error('no token');\n      return;\n    }\n\n    if (!tokenContract) {\n      console.error('tokenContract is null');\n      return;\n    }\n\n    if (!amountToApprove) {\n      console.error('missing amount to approve');\n      return;\n    }\n\n    if (!spender) {\n      console.error('no spender');\n      return;\n    }\n\n    let useExact = false;\n    const estimatedGas = await tokenContract.estimateGas\n      .approve(spender, MaxUint256)\n      .catch(() => {\n        // general fallback for tokens who restrict approval amounts\n        useExact = true;\n        return tokenContract.estimateGas.approve(\n          spender,\n          amountToApprove.raw.toString(),\n        );\n      });\n\n    return tokenContract\n      .approve(\n        spender,\n        useExact ? amountToApprove.raw.toString() : MaxUint256,\n        {\n          gasLimit: calculateGasMargin(estimatedGas),\n        },\n      )\n      .then(async (response: TransactionResponse) => {\n        addTransaction(response, {\n          summary: 'Approve ' + amountToApprove.currency.symbol,\n          approval: { tokenAddress: token.address, spender: spender },\n        });\n        try {\n          await response.wait();\n        } catch (e) {\n          console.debug('Failed to approve token', e);\n          throw e;\n        }\n      })\n      .catch((error: Error) => {\n        console.debug('Failed to approve token', error);\n        throw error;\n      });\n  }, [\n    approvalState,\n    token,\n    tokenContract,\n    amountToApprove,\n    spender,\n    addTransaction,\n  ]);\n\n  return [approvalState, approve];\n}\n\n// wraps useApproveCallback in the context of a swap\nexport function useApproveCallbackFromTrade(\n  trade?: Trade,\n  allowedSlippage = 0,\n): [ApprovalState, () => Promise<void>] {\n  const { chainId } = useActiveWeb3React();\n  const amountToApprove = useMemo(\n    () =>\n      trade\n        ? computeSlippageAdjustedAmounts(trade, allowedSlippage)[Field.INPUT]\n        : undefined,\n    [trade, allowedSlippage],\n  );\n\n  return useApproveCallback(\n    amountToApprove,\n    chainId ? GlobalConst.addresses.ROUTER_ADDRESS[chainId] : undefined,\n  );\n}\n"]},"metadata":{},"sourceType":"module"}