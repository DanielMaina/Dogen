{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$();\n\nimport { ChainId, Token } from '@uniswap/sdk';\nimport { GlobalConst } from 'constants/index';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nconst {\n  DEFAULT_TOKEN_LIST_URL\n} = GlobalConst.utils;\n\n/**\n * Token instances created from token info.\n */\nexport class WrappedTokenInfo extends Token {\n  constructor(tokenInfo, tags) {\n    super(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name);\n    this.tokenInfo = void 0;\n    this.tags = void 0;\n    this.tokenInfo = tokenInfo;\n    this.tags = tags;\n  }\n\n  get logoURI() {\n    return this.tokenInfo.logoURI;\n  }\n\n}\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST = {\n  [ChainId.TESTNET]: {},\n  [ChainId.MAINNET]: {}\n};\nconst listCache = typeof WeakMap !== 'undefined' ? new WeakMap() : null;\nexport function listToTokenMap(list) {\n  const result = listCache === null || listCache === void 0 ? void 0 : listCache.get(list);\n  if (result) return result;\n  const map = list.tokens.reduce((tokenMap, tokenInfo) => {\n    var _tokenInfo$tags$map$f, _tokenInfo$tags, _tokenInfo$tags$map;\n\n    const tags = (_tokenInfo$tags$map$f = (_tokenInfo$tags = tokenInfo.tags) === null || _tokenInfo$tags === void 0 ? void 0 : (_tokenInfo$tags$map = _tokenInfo$tags.map(tagId => {\n      var _list$tags;\n\n      if (!((_list$tags = list.tags) !== null && _list$tags !== void 0 && _list$tags[tagId])) return undefined;\n      return { ...list.tags[tagId],\n        id: tagId\n      };\n    })) === null || _tokenInfo$tags$map === void 0 ? void 0 : _tokenInfo$tags$map.filter(x => Boolean(x))) !== null && _tokenInfo$tags$map$f !== void 0 ? _tokenInfo$tags$map$f : [];\n    const token = new WrappedTokenInfo(tokenInfo, tags);\n    if (tokenMap[token.chainId][token.address] !== undefined) throw Error('Duplicate tokens.');\n    return { ...tokenMap,\n      [token.chainId]: { ...tokenMap[token.chainId],\n        [token.address]: token\n      }\n    };\n  }, { ...EMPTY_LIST\n  });\n  listCache === null || listCache === void 0 ? void 0 : listCache.set(list, map);\n  return map;\n}\nexport function useTokenList(url) {\n  _s();\n\n  const lists = useSelector(state => state.lists.byUrl);\n  return useMemo(() => {\n    var _lists$url;\n\n    if (!url) return EMPTY_LIST;\n    const current = (_lists$url = lists[url]) === null || _lists$url === void 0 ? void 0 : _lists$url.current;\n    if (!current) return EMPTY_LIST;\n\n    try {\n      return listToTokenMap(current);\n    } catch (error) {\n      console.error('Could not show token list due to error', error);\n      return EMPTY_LIST;\n    }\n  }, [lists, url]);\n}\n\n_s(useTokenList, \"CPtzWPSAgVUGbNKI1Wkc4nuPc3o=\", false, function () {\n  return [useSelector];\n});\n\nexport function useSelectedListUrl() {\n  _s2();\n\n  return useSelector(state => state.lists.selectedListUrl);\n}\n\n_s2(useSelectedListUrl, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useSelectedTokenList() {\n  _s3();\n\n  // return useTokenList(useSelectedListUrl());\n  //TODO: Add support for selected list when @latest doesn't store the redirected url\n  return useTokenList(DEFAULT_TOKEN_LIST_URL);\n}\n\n_s3(useSelectedTokenList, \"cCtCsmeSZ7TxYaPWKmdoDg9R5Zk=\", false, function () {\n  return [useTokenList];\n});\n\nexport function useSelectedListInfo() {\n  _s4();\n\n  var _list$current, _list$pendingUpdate;\n\n  const selectedUrl = useSelectedListUrl();\n  const listsByUrl = useSelector(state => state.lists.byUrl);\n  const list = selectedUrl ? listsByUrl[selectedUrl] : undefined;\n  return {\n    current: (_list$current = list === null || list === void 0 ? void 0 : list.current) !== null && _list$current !== void 0 ? _list$current : null,\n    pending: (_list$pendingUpdate = list === null || list === void 0 ? void 0 : list.pendingUpdate) !== null && _list$pendingUpdate !== void 0 ? _list$pendingUpdate : null,\n    loading: (list === null || list === void 0 ? void 0 : list.loadingRequestId) !== null\n  };\n} // returns all downloaded current lists\n\n_s4(useSelectedListInfo, \"eEXQWQZuHgHfEhZccryGmtXRQJM=\", false, function () {\n  return [useSelectedListUrl, useSelector];\n});\n\nexport function useAllLists() {\n  _s5();\n\n  const lists = useSelector(state => state.lists.byUrl);\n  return useMemo(() => Object.keys(lists).map(url => lists[url].current).filter(l => Boolean(l)), [lists]);\n}\n\n_s5(useAllLists, \"CPtzWPSAgVUGbNKI1Wkc4nuPc3o=\", false, function () {\n  return [useSelector];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/state/lists/hooks.ts"],"names":["ChainId","Token","GlobalConst","useMemo","useSelector","DEFAULT_TOKEN_LIST_URL","utils","WrappedTokenInfo","constructor","tokenInfo","tags","chainId","address","decimals","symbol","name","logoURI","EMPTY_LIST","TESTNET","MAINNET","listCache","WeakMap","listToTokenMap","list","result","get","map","tokens","reduce","tokenMap","tagId","undefined","id","filter","x","Boolean","token","Error","set","useTokenList","url","lists","state","byUrl","current","error","console","useSelectedListUrl","selectedListUrl","useSelectedTokenList","useSelectedListInfo","selectedUrl","listsByUrl","pending","pendingUpdate","loading","loadingRequestId","useAllLists","Object","keys","l"],"mappings":"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","sourcesContent":["import { ChainId, Token } from '@uniswap/sdk';\nimport { Tags, TokenInfo, TokenList } from '@uniswap/token-lists';\nimport { GlobalConst } from 'constants/index';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { AppState } from 'state';\nconst { DEFAULT_TOKEN_LIST_URL } = GlobalConst.utils;\n\ntype TagDetails = Tags[keyof Tags];\nexport interface TagInfo extends TagDetails {\n  id: string;\n}\n\n/**\n * Token instances created from token info.\n */\nexport class WrappedTokenInfo extends Token {\n  public readonly tokenInfo: TokenInfo;\n  public readonly tags: TagInfo[];\n  constructor(tokenInfo: TokenInfo, tags: TagInfo[]) {\n    super(\n      tokenInfo.chainId,\n      tokenInfo.address,\n      tokenInfo.decimals,\n      tokenInfo.symbol,\n      tokenInfo.name,\n    );\n    this.tokenInfo = tokenInfo;\n    this.tags = tags;\n  }\n  public get logoURI(): string | undefined {\n    return this.tokenInfo.logoURI;\n  }\n}\n\nexport type TokenAddressMap = Readonly<\n  {\n    [chainId in ChainId]: Readonly<{\n      [tokenAddress: string]: WrappedTokenInfo;\n    }>;\n  }\n>;\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST: TokenAddressMap = {\n  [ChainId.TESTNET]: {},\n  [ChainId.MAINNET]: {},\n};\n\nconst listCache: WeakMap<TokenList, TokenAddressMap> | null =\n  typeof WeakMap !== 'undefined'\n    ? new WeakMap<TokenList, TokenAddressMap>()\n    : null;\n\nexport function listToTokenMap(list: TokenList): TokenAddressMap {\n  const result = listCache?.get(list);\n  if (result) return result;\n\n  const map = list.tokens.reduce<TokenAddressMap>(\n    (tokenMap, tokenInfo) => {\n      const tags: TagInfo[] =\n        tokenInfo.tags\n          ?.map((tagId) => {\n            if (!list.tags?.[tagId]) return undefined;\n            return { ...list.tags[tagId], id: tagId };\n          })\n          ?.filter((x): x is TagInfo => Boolean(x)) ?? [];\n      const token = new WrappedTokenInfo(tokenInfo, tags);\n      if (tokenMap[token.chainId][token.address] !== undefined)\n        throw Error('Duplicate tokens.');\n      return {\n        ...tokenMap,\n        [token.chainId]: {\n          ...tokenMap[token.chainId],\n          [token.address]: token,\n        },\n      };\n    },\n    { ...EMPTY_LIST },\n  );\n  listCache?.set(list, map);\n  return map;\n}\n\nexport function useTokenList(url: string | undefined): TokenAddressMap {\n  const lists = useSelector<AppState, AppState['lists']['byUrl']>(\n    (state) => state.lists.byUrl,\n  );\n  return useMemo(() => {\n    if (!url) return EMPTY_LIST;\n    const current = lists[url]?.current;\n    if (!current) return EMPTY_LIST;\n    try {\n      return listToTokenMap(current);\n    } catch (error) {\n      console.error('Could not show token list due to error', error);\n      return EMPTY_LIST;\n    }\n  }, [lists, url]);\n}\n\nexport function useSelectedListUrl(): string | undefined {\n  return useSelector<AppState, AppState['lists']['selectedListUrl']>(\n    (state) => state.lists.selectedListUrl,\n  );\n}\n\nexport function useSelectedTokenList(): TokenAddressMap {\n  // return useTokenList(useSelectedListUrl());\n  //TODO: Add support for selected list when @latest doesn't store the redirected url\n  return useTokenList(DEFAULT_TOKEN_LIST_URL);\n}\n\nexport function useSelectedListInfo(): {\n  current: TokenList | null;\n  pending: TokenList | null;\n  loading: boolean;\n} {\n  const selectedUrl = useSelectedListUrl();\n  const listsByUrl = useSelector<AppState, AppState['lists']['byUrl']>(\n    (state) => state.lists.byUrl,\n  );\n  const list = selectedUrl ? listsByUrl[selectedUrl] : undefined;\n\n  return {\n    current: list?.current ?? null,\n    pending: list?.pendingUpdate ?? null,\n    loading: list?.loadingRequestId !== null,\n  };\n}\n\n// returns all downloaded current lists\nexport function useAllLists(): TokenList[] {\n  const lists = useSelector<AppState, AppState['lists']['byUrl']>(\n    (state) => state.lists.byUrl,\n  );\n\n  return useMemo(\n    () =>\n      Object.keys(lists)\n        .map((url) => lists[url].current)\n        .filter((l): l is TokenList => Boolean(l)),\n    [lists],\n  );\n}\n"]},"metadata":{},"sourceType":"module"}