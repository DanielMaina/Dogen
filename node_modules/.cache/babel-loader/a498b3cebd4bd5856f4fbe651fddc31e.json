{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$();\n\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from 'hooks';\nimport { useAddPopup } from 'state/application/hooks';\nimport { addTransaction, finalizeTransaction } from './actions';\n// helper that can take a ethers library transaction response and add it to the list of transactions\nexport function useTransactionAdder() {\n  _s();\n\n  const {\n    chainId,\n    account\n  } = useActiveWeb3React();\n  const dispatch = useDispatch();\n  return useCallback(function (response) {\n    let {\n      summary,\n      approval,\n      claim\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!account) return;\n    if (!chainId) return;\n    const {\n      hash\n    } = response;\n\n    if (!hash) {\n      throw Error('No transaction hash found.');\n    }\n\n    dispatch(addTransaction({\n      hash,\n      from: account,\n      chainId,\n      approval,\n      summary,\n      claim\n    }));\n  }, [dispatch, chainId, account]);\n}\n\n_s(useTransactionAdder, \"MEh+TAztv1BWq5c2lTL2SEy/Uq8=\", false, function () {\n  return [useActiveWeb3React, useDispatch];\n});\n\nexport function useTransactionFinalizer() {\n  _s2();\n\n  const {\n    chainId,\n    account\n  } = useActiveWeb3React();\n  const dispatch = useDispatch();\n  const addPopup = useAddPopup();\n  return useCallback(function (receipt) {\n    let {\n      summary\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!account) return;\n    if (!chainId) return;\n    const {\n      transactionHash\n    } = receipt;\n\n    if (!transactionHash) {\n      throw Error('No transaction hash found.');\n    }\n\n    dispatch(finalizeTransaction({\n      chainId,\n      hash: transactionHash,\n      receipt: {\n        blockHash: receipt.blockHash,\n        blockNumber: receipt.blockNumber,\n        contractAddress: receipt.contractAddress,\n        from: receipt.from,\n        status: receipt.status,\n        to: receipt.to,\n        transactionHash: receipt.transactionHash,\n        transactionIndex: receipt.transactionIndex\n      }\n    }));\n    addPopup({\n      txn: {\n        hash: transactionHash,\n        success: receipt.status === 1,\n        summary: summary\n      }\n    }, transactionHash);\n  }, [dispatch, chainId, account, addPopup]);\n} // returns all the transactions for the current chain\n\n_s2(useTransactionFinalizer, \"U4Wcgp6rC05JvA1PJjT3C6ERRtg=\", false, function () {\n  return [useActiveWeb3React, useDispatch, useAddPopup];\n});\n\nexport function useAllTransactions() {\n  _s3();\n\n  var _state$chainId;\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const state = useSelector(state => state.transactions);\n  return chainId ? (_state$chainId = state[chainId]) !== null && _state$chainId !== void 0 ? _state$chainId : {} : {};\n}\n\n_s3(useAllTransactions, \"3FhVoM2yUUuTIyL07ycVqdy9Zqs=\", false, function () {\n  return [useActiveWeb3React, useSelector];\n});\n\nexport function useIsTransactionPending(transactionHash) {\n  _s4();\n\n  const transactions = useAllTransactions();\n  if (!transactionHash || !transactions[transactionHash]) return false;\n  return !transactions[transactionHash].receipt;\n}\n/**\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\n * @param tx to check for recency\n */\n\n_s4(useIsTransactionPending, \"hqz1TRfIl9I1+vK9TqtScGR9Kdg=\", false, function () {\n  return [useAllTransactions];\n});\n\nexport function isTransactionRecent(tx) {\n  return new Date().getTime() - tx.addedTime < 86400000;\n} // returns whether a token has a pending approval transaction\n\nexport function useHasPendingApproval(tokenAddress, spender) {\n  _s5();\n\n  const allTransactions = useAllTransactions();\n  return useMemo(() => typeof tokenAddress === 'string' && typeof spender === 'string' && Object.keys(allTransactions).some(hash => {\n    const tx = allTransactions[hash];\n    if (!tx) return false;\n\n    if (tx.receipt) {\n      return false;\n    } else {\n      const approval = tx.approval;\n      if (!approval) return false;\n      return approval.spender === spender && approval.tokenAddress === tokenAddress && isTransactionRecent(tx);\n    }\n  }), [allTransactions, spender, tokenAddress]);\n} // watch for submissions to claim\n// return null if not done loading, return undefined if not found\n\n_s5(useHasPendingApproval, \"VezVe/KwFqNDaRAkqywKb3KU5lg=\", false, function () {\n  return [useAllTransactions];\n});\n\nexport function useUserHasSubmittedClaim(account) {\n  _s6();\n\n  const allTransactions = useAllTransactions(); // get the txn if it has been submitted\n\n  const claimTxn = useMemo(() => {\n    const txnIndex = Object.keys(allTransactions).find(hash => {\n      const tx = allTransactions[hash];\n      return tx.claim && tx.claim.recipient === account;\n    });\n    return txnIndex && allTransactions[txnIndex] ? allTransactions[txnIndex] : undefined;\n  }, [account, allTransactions]);\n  return {\n    claimSubmitted: Boolean(claimTxn),\n    claimTxn\n  };\n}\n\n_s6(useUserHasSubmittedClaim, \"VV0KKHrbuq348q6dk6Qn9MylTW8=\", false, function () {\n  return [useAllTransactions];\n});","map":{"version":3,"sources":["/Users/danielmaina/Downloads/_newCrptProj/clientBase/DEX/interface-v2-master/src/state/transactions/hooks.ts"],"names":["useCallback","useMemo","useDispatch","useSelector","useActiveWeb3React","useAddPopup","addTransaction","finalizeTransaction","useTransactionAdder","chainId","account","dispatch","response","summary","approval","claim","hash","Error","from","useTransactionFinalizer","addPopup","receipt","transactionHash","blockHash","blockNumber","contractAddress","status","to","transactionIndex","txn","success","useAllTransactions","state","transactions","useIsTransactionPending","isTransactionRecent","tx","Date","getTime","addedTime","useHasPendingApproval","tokenAddress","spender","allTransactions","Object","keys","some","useUserHasSubmittedClaim","claimTxn","txnIndex","find","recipient","undefined","claimSubmitted","Boolean"],"mappings":"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","sourcesContent":["import {\n  TransactionResponse,\n  TransactionReceipt,\n} from '@ethersproject/providers';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport { useActiveWeb3React } from 'hooks';\nimport { useAddPopup } from 'state/application/hooks';\nimport { AppDispatch, AppState } from 'state';\nimport { addTransaction, finalizeTransaction } from './actions';\nimport { TransactionDetails } from './reducer';\n\n// helper that can take a ethers library transaction response and add it to the list of transactions\nexport function useTransactionAdder(): (\n  response: TransactionResponse,\n  customData?: {\n    summary?: string;\n    approval?: { tokenAddress: string; spender: string };\n    claim?: { recipient: string };\n  },\n) => void {\n  const { chainId, account } = useActiveWeb3React();\n  const dispatch = useDispatch<AppDispatch>();\n\n  return useCallback(\n    (\n      response: TransactionResponse,\n      {\n        summary,\n        approval,\n        claim,\n      }: {\n        summary?: string;\n        claim?: { recipient: string };\n        approval?: { tokenAddress: string; spender: string };\n      } = {},\n    ) => {\n      if (!account) return;\n      if (!chainId) return;\n\n      const { hash } = response;\n      if (!hash) {\n        throw Error('No transaction hash found.');\n      }\n      dispatch(\n        addTransaction({\n          hash,\n          from: account,\n          chainId,\n          approval,\n          summary,\n          claim,\n        }),\n      );\n    },\n    [dispatch, chainId, account],\n  );\n}\n\nexport function useTransactionFinalizer(): (\n  receipt: TransactionReceipt,\n  customData?: {\n    summary?: string;\n    approval?: { tokenAddress: string; spender: string };\n    claim?: { recipient: string };\n  },\n) => void {\n  const { chainId, account } = useActiveWeb3React();\n  const dispatch = useDispatch<AppDispatch>();\n  const addPopup = useAddPopup();\n\n  return useCallback(\n    (\n      receipt: TransactionReceipt,\n      {\n        summary,\n      }: {\n        summary?: string;\n        claim?: { recipient: string };\n        approval?: { tokenAddress: string; spender: string };\n      } = {},\n    ) => {\n      if (!account) return;\n      if (!chainId) return;\n\n      const { transactionHash } = receipt;\n      if (!transactionHash) {\n        throw Error('No transaction hash found.');\n      }\n      dispatch(\n        finalizeTransaction({\n          chainId,\n          hash: transactionHash,\n          receipt: {\n            blockHash: receipt.blockHash,\n            blockNumber: receipt.blockNumber,\n            contractAddress: receipt.contractAddress,\n            from: receipt.from,\n            status: receipt.status,\n            to: receipt.to,\n            transactionHash: receipt.transactionHash,\n            transactionIndex: receipt.transactionIndex,\n          },\n        }),\n      );\n      addPopup(\n        {\n          txn: {\n            hash: transactionHash,\n            success: receipt.status === 1,\n            summary: summary,\n          },\n        },\n        transactionHash,\n      );\n    },\n    [dispatch, chainId, account, addPopup],\n  );\n}\n\n// returns all the transactions for the current chain\nexport function useAllTransactions(): { [txHash: string]: TransactionDetails } {\n  const { chainId } = useActiveWeb3React();\n\n  const state = useSelector<AppState, AppState['transactions']>(\n    (state) => state.transactions,\n  );\n\n  return chainId ? state[chainId] ?? {} : {};\n}\n\nexport function useIsTransactionPending(transactionHash?: string): boolean {\n  const transactions = useAllTransactions();\n\n  if (!transactionHash || !transactions[transactionHash]) return false;\n\n  return !transactions[transactionHash].receipt;\n}\n\n/**\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\n * @param tx to check for recency\n */\nexport function isTransactionRecent(tx: TransactionDetails): boolean {\n  return new Date().getTime() - tx.addedTime < 86_400_000;\n}\n\n// returns whether a token has a pending approval transaction\nexport function useHasPendingApproval(\n  tokenAddress: string | undefined,\n  spender: string | undefined,\n): boolean {\n  const allTransactions = useAllTransactions();\n  return useMemo(\n    () =>\n      typeof tokenAddress === 'string' &&\n      typeof spender === 'string' &&\n      Object.keys(allTransactions).some((hash) => {\n        const tx = allTransactions[hash];\n        if (!tx) return false;\n        if (tx.receipt) {\n          return false;\n        } else {\n          const approval = tx.approval;\n          if (!approval) return false;\n          return (\n            approval.spender === spender &&\n            approval.tokenAddress === tokenAddress &&\n            isTransactionRecent(tx)\n          );\n        }\n      }),\n    [allTransactions, spender, tokenAddress],\n  );\n}\n\n// watch for submissions to claim\n// return null if not done loading, return undefined if not found\nexport function useUserHasSubmittedClaim(\n  account?: string,\n): { claimSubmitted: boolean; claimTxn: TransactionDetails | undefined } {\n  const allTransactions = useAllTransactions();\n\n  // get the txn if it has been submitted\n  const claimTxn = useMemo(() => {\n    const txnIndex = Object.keys(allTransactions).find((hash) => {\n      const tx = allTransactions[hash];\n      return tx.claim && tx.claim.recipient === account;\n    });\n    return txnIndex && allTransactions[txnIndex]\n      ? allTransactions[txnIndex]\n      : undefined;\n  }, [account, allTransactions]);\n\n  return { claimSubmitted: Boolean(claimTxn), claimTxn };\n}\n"]},"metadata":{},"sourceType":"module"}